<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Cpp中的字符串优化]]></title>
    <url>%2F2018%2F06%2F05%2FCpp%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[字符串是程序代码中使用最频繁的几种数据类型之一，在C++中基本是以std::string出现（当然还有C中的字符数组），尽管它被正确和频繁的使用，但多数coder仍然会忽略可以明显改善性能的地方。 字符串的重要特性动态分配C++中字符串的内容是自动增长的，相比C中固定长度的字符数组（需要手动分配和释放内存），拥有更好的便捷灵活性，但为了实现内容的自动增长，字符串被设计为动态分配，而动态分配内存相比一些操作更耗费资源。 虽然C++中的字符串是动态分配的（字符串增长的情况），但实际上字符串内部的buffer的大小在一段时间内仍然是固定的。详细可以解释为字符串向内存管理器申请的buffer的大小并非与字符串所需存储的字符数完全一致，而是更大的空间（通常是现在所需的两倍大小）。这带来的好处就是随着字符串变得更长，在字符串后面再添加字符或是字符串的开销近似于一个常量（降低向内存管理器动态申请内存的次数），而代价则是字符串携带了一些未使用的内存空间。 大量复制字符串的行为与普通的整型值类似，即修改一个字符串不能改变其他字符串的值，表现得就像拥有自己的私人副本。 实现这种行为的最简单的方式是当创建字符串、赋值或是将其作为参数传递给函数的时候就进行一次复制。如果字符串是以这种方式实现的，那么赋值和参数传递的开销将会变得很大，但是变值函数（mutating function）和非常量引用的开销却很小。 另一种方式就是“写时复制”（copy on write），它可以让对象与值具有同样的表现，尽管写时复制的字符串在赋值和参数传递的开销很小，但是写时复制是不符合 C++11 标准的实现方式，而且写时复制（也就是变值函数（mutating function）和非常量引用）的开销同样大。 针对字符串在程序中存在的大量复制问题，C++11及之后的版本推出了“右值引用”和“移动语义”的概念，可以而且特别是在一些赋值和参数传递情况下减轻复制字符串带来的负担，提高性能，但在这篇博客中并不重点叙述“右值引用”和“移动语义”的概念。 字符串的常用性能优化方法在介绍常用优化手段前，引入一个例子（之后的代码片段和性能数据都来自Optimized C++），这个函数的功能是从一个由 ASCII 字符组成的字符串中移除控制字符： 12345678910std::string remove_ctrl(std::string s)&#123; std::string result; for (int i = 0; i &lt; s.length(); ++i) &#123; if(s[i] &gt;= 0x20) result = result + s[i]; &#125; return result;&#125; 使用复合赋值操作避免临时字符串字符串连接运算符的开销是很大的。因为它会调用内存管理器去构建一个新的临时字符串对象来保存连接后的字符串。 如果传递给 remove_ctrl() 的参数是一个由可打印的字符组成的字符串，那么 remove_ctrl() 几乎会为 s 中的每个字符都构建一个临时字符串对象，这显然是不可接受的。 而使用复合赋值操作来避免临时字符串，是针对字符串两种最重要特性（动态分配和大量复制）的优化。 小小的改动移除了所有为分配临时字符串对象来保存连接结果而对内存管理器的调用，以及相关的复制和释放临时字符串的操作。赋值时的分配和复制操作也可以被移除，不过这取决于字符串的实现方式（C++11实现了右值引用和移动语义，连接表达式的结果由于是一个右值，编译器可以调用 result 的移动构造函数，而无需调用复制构造函数，程序将会执行一次高效的指针复制）。 12345678910std::string remove_ctrl_mutating(std::string s)&#123; std::string result; for (int i = 0; i &lt; s.length(); ++i) &#123; if(s[i] &gt;= 0x20) result += s[i]; &#125; return result;&#125; 通过预留存储空间减少内存的重新分配针对字符串的动态分配特性，通过使用 std::string() 的 reserve() 成员函数预先分配足够的内存空间来优化 remove_ctrl_mutating()。使用reserve() 不仅移除了字符串缓冲区的重新分配，还改善了函数所读取的数据的缓存局部性（cache locality）。 1234567891011std::string remove_ctrl_reserve(std::string s)&#123; std::string result; result.reserve(s.length); for (int i = 0; i &lt; s.length(); ++i) &#123; if(s[i] &gt;= 0x20) result += s[i]; &#125; return result;&#125; 使用 pass by ref 消除对参数字符串的复制通过值（即所谓的 pass-by-value）将一个字符串参数传递给一个不会修改该字符串的函数对一个严格的C++程序员来说是不可接受的。 如果该字符串实参是由表达式产生的（更准确地说它是右值），C++11编译器将会调用移动构造函数执行一次高效的指针复制，这还算好的情况；但如果实参是一个变量（更准确地说它是左值），那么将会调用字符串的拷贝构造函数，这会导致一次内存分配和复制。不要小看一次的内存分配和复制，随着传入字符串的长度增长，该函数的调用性能会越差。 在此处的例子中移除实参复制，使用 pass by reference 可以省去一次昂贵的内存分配和字符串内容的深拷贝。 1234567891011std::string remove_ctrl_ref_args(const std::string&amp; s)&#123; std::string result; result.reserve(s.length); for (int i = 0; i &lt; s.length(); ++i) &#123; if(s[i] &gt;= 0x20) result += s[i]; &#125; return result;&#125; 将 s 从字符串修改为字符串引用后可能会因为其他因素（比如解引指针，C++中的引用变量实际是作为指针实现的，当程序中每次出现 s 时，都需要解引指针）抵消节省内存分配带来的性能提升，使得整体的性能较 remove_ctrl_reserve 还要差。 使用迭代器消除指针解引字符串迭代器是指向字符缓冲区的简单指针。与不使用迭代器的代码 remove_ctrl_ref_args 相比，可以节省两次解引操作。 1234567891011std::string remove_ctrl_ref_args_it(const std::string&amp; s)&#123; std::string result; result.reserve(s.length); for (auto it = s.begin(); it != s.end(); ++it) &#123; if(*it &gt;= 0x20) result += *it; &#125; return result;&#125; 为了了解使用 pass by reference 的 remove_ctrl_ref_args 的性能是否有改善，需要控制变量实现 remove_ctrl_reserve 的迭代器版本 remove_ctrl_reserve_it，测试比较 remove_ctrl_reserve_it 和 remove_ctrl_ref_args_it ，结果说明将参数类型修改为字符串引用确实提高了程序性能。 同时编写上述所有代码的迭代器版本与非迭代器版本进行比较，就现有例子的结果，使用迭代器的都比非迭代器的要快，但这个优化手段 并不总是有效。 消除对返回的字符串的复制remove_ctrl() 是通过值返回处理结果的。C++编译器会调用复制构造函数将结果设置到调用上下文中。实际上编译器自身有可能进行C++返回值优化，即RVO，省去拷贝构造，尽管在大多数情况下能提高性能，但是却难以受程序员控制。（此处不具体讨论RVO，详情参考此链接） 想要确保不会发生复制，有一种比较简单的方式是将字符串作为输出参数返回，这种方法适用于所有的 C++ 版本以及字符串的所有实现方式。虽然性能有些许提升，但是该函数的接口并不直观，很容易导致调用方误用这个函数。 12345678910111213void remove_ctrl_ref_result_it( std::string&amp; result, const std::string&amp; s)&#123; result.clear(); result.reserve(s.length); for (auto it = s.begin(); it != s.end(); ++it) &#123; if(*it &gt;= 0x20) result += *it; &#125; return result;&#125; 舍弃 C++ 特性，使用 C 风格字符数组remove_ctrl_cstrings() 这种转换为C风格字符数组的优化方式成本较高（常用于一些高性能服务和严格的嵌入式环境），而且很不C++。但尽管如此，remove_ctrl_cstrings() 仍然说明：只要开发人员愿意用C风格字符数组完全重写关于字符串的函数和接口，就可以获得很大的性能提升。 123456789void remove_ctrl_cstrings(char* dst, const char* src, size_t size)&#123; for (size_t i = 0; i &lt; size; ++i) &#123; if (src[i] &gt;= 0x20) *dst++ = src[i]; &#125; *dst = 0;&#125; 字符串的其他性能优化方法使用更好的算法算法优化是各种优化手段中的第一选择。 在没有选择较优算法的情形下过早优化其实是吃力不讨好的。好的算法可能在第一次编写代码时就获得远比坏算法优化迭代多次的结果还要好的性能，而且上述的常用优化手段也能应用到好的新算法中，进一步提升性能。 12345678910111213141516171819std::string remove_ctrl_block_append(std::string s)&#123; std::string result; result.reserve(s.length()); for (size_t b = 0, i = b; b &lt; s.length(); b = i+1) &#123; for (i = b; i &lt; s.length(); ++i) &#123; if (s[i] &lt; 0x20) break; &#125; // substr() 仍然生成临时字符串。 // 由于这个函数将字符添加到了 result 的末尾， // 开发人员可以通过重载 std::string 的 append() 成员函数 // 来复制子字符串，且无需创建临时字符串。 // result = result + s.substr(b, i-b); result.append(s, b, i-b); &#125; return result;&#125; 使用更好的编译器和字符串库C++只规定了标准，各个编译器内部的具体实现各式各样。因此一个好的编译器能做到更多的自我优化。 std::string 的定义曾经非常模糊，这让开发人员在实现字符串时有更广泛的选择。后来，对性能和可预测性的需求最终迫使 C++ 标准明确了它的定义，导致很多新奇的实现方式不再适用。比如 C++ 标准要求迭代器能够随机访问，而且禁止写时复制语义，这样更容易定义 std::string，而且更容易推论出哪些操作会使 std::string 中正在使用的迭代器无效，这也推动 std::string 的实现趋于简单。 就我个人而言，标准 C++ 字符串库已经够用了（尽管缺少了一些字符集的转换函数）。标准 C++ 中共有几种字符串实现方式： 模板化的、支持迭代器访问的、可变长度的std::string 字符串 简单的、基于迭代器的 std::vector 老式的、C 风格的以空字符结尾的、固定长度的字符数组 std::stringstream 。std::stringstream 类以一种不同的方式封装了一块动态大小的缓冲区（通常就是一个 std::string），数据可以被添加至这个实体中。由于被修改为了一个实体，很长的插入表达式不会创建任何临时字符串，因此不会发生内存分配和复制操作。如果 std::stringstream 是用 std::string 实现的，那么它在性能上永远不能胜过 std::string，但好在可以防止某些降低程序性能的编程实践。 通过移除一个或多个限制（迭代器、索引、C 风格访问、简单性），自定义的字符串类可以优化那些因使用了 std::string 而无法优化的代码。（尽量在设计初期就确定） string_view 可以解决 std::string 的某些问题。它包含一个指向字符串数据的无主指针和一个表示字符串长度的值，所以它可以表示为 std::string 或字面字符串的子字符串。与 std::string 相比，它的 substring 和 trim 等操作更高效，但问题在于无主指针，程序员必须确保每个 string_view 的生命周期都不会比它所指向的 std::string 的生命周期长。 使用更好的内存分配器每个 std::string 的内部都是一个动态分配的字符数组。std::string 可以看成是如下通用模板的一种特化： 123456789namespace std &#123;template &lt;class charT, class traits = char_traits&lt;charT&gt;, class Alloc = allocator&lt;charT&gt;&gt;class basic_string;typedef basic_string&lt;char&gt; string;...&#125;; 第三个模板参数 Alloc 定义了一个分配器——一个访问 C++ 内存管理器的专用接口。默认情况下，Alloc 是 std::allocator，它会调用 operator new() 和operator delete()——两个全局的 C++ 内存分配器函数。 operator new() 和 operator delete() 实际很复杂，为了实现各种情形下良好的通用性，它们在设计上做出了一些妥协。因此在一些特定场景中自定义一种更加特化的分配器可能会更好地提升性能。但就我这个C++菜鸡而言，我肯定是使用默认的allocator，不会去编写自己的内存分配器。 消除字符串无谓转换和不同字符集间的转换一些场景下 char 转换为 std::string 是无谓的。std::string 有一个参数为 char 的构造函数，因此当返回值被赋值给一个字符串或是作为参数传递给另外一个函数时，会自动进行转换。也就是说将返回值的转换推迟至它真正被使用的时候。如下： 1234567char const* MyClass::Name() const&#123; return "MyClass";&#125;char const* p = myInstance-&gt;Name(); // 没有转换std::string s = myInstance-&gt;Name(); // 转换为'std::string'std::cout &lt;&lt; myInstance-&gt;Name(); // 没有转换 在多字符集的场景下，不同字符集间的频繁转换也是性能优化的一个热点，移除不同字符集间转换的最佳方法是为所有的字符串选择一种固定的格式，并将所有字符串都存储为这种格式。个人而言首推 UTF-8格式（windows万恶的GBK），因为它能够表示所有的 Unicode 码点，并可以直接与 C 风格的字符串进行比较（是否相同）。 PS: 下一篇C++优化的主题内容应该是关于标准库算法的，特别是查找和排序的优化。]]></content>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Write a simple PriorityQueue]]></title>
    <url>%2F2018%2F05%2F28%2FWrite-a-simple-PriorityQueue%2F</url>
    <content type="text"><![CDATA[最近我在重看算法导论，所以为了更好地巩固算法，打算为每个重要部分都写一篇博客，其实在大学的时候我就干过类似的事情，只不过上次是在leanote上写的并且发布到了leanote的博客上，介于leanote的会员到期，因此决定重写编写之前关于算法导论部分的博客内容并放到github上来，但是这次重写将主要着重强调具体的编码实现。 HeapPriorityQueue是二叉堆（Heap）的一个常见应用，所以想要写一个PriorityQueue之前肯定需要对堆有所了解。 Heap与PriorityQueue一样都是一种抽象数据类型（Abstract Data Type，ADT），实际存储结构常常是一个数组，且将其看成一个近似的完全二叉树（最底层可能不是完全满的），如下图所示。 二叉堆分为两种： 最大堆：除了根以外的所有结点i都要满足 结点i的父亲的值大于等于结点i的值，即Heap[parent(i)] &gt;= Heap[i] 最小堆：除了根以外的所有结点i都要满足 结点i的父亲的值小于等于结点i的值，即Heap[parent(i)] &lt;= Heap[i] 123456789101112template&lt;class T, class Container = std::vector&lt;T&gt;, class Compare = std::less&lt;typename Container::value_type&gt;&gt;class PriorityQueue&#123;public:private: Container container; Compare comp;&#125;]]></content>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The goals of 2018]]></title>
    <url>%2F2018%2F01%2F01%2FThe-goals-of-2018%2F</url>
    <content type="text"><![CDATA[前天在小姨家，小姨提议让我给自己制定一些2018年的目标，正好博客重开并且坚持写下去就是我的新一年的一个小目标，那索性就直接把2018年的目标写到博客里，等到这年结束时，再回头看看这一年的完成情况。 The goals既然写都要写了，那就分类写得稍微整洁点。 Learning 通过找一些有趣的idea来巩固自己对C++11之后的标准的理解。ps: 顺便在之后的博客中把先前欠下的《Modern Effective C++》的笔记给补上。具体的项目可以先从一些简单的轮子上手，比如一些 parser 和 CG demo，还能加深些编译原理和图形学的知识。 博客有关技术的内容要保持至少一周一更的更新频率。 完成初阶 Rust 的学习，并进行 Rust 官方文档里高阶部分的学习。 CG的学习，通读 Real-time Rendering 和 PBRT，分别对实时渲染和离线渲染的基础算法有一定的了解。 IT 技术书籍和金融理财相关书籍的阅读，一年的预计总数为 20 份（包含中英文和一些系统性的技术文档）。 英文听说和写能力的提高，因为我单词量还不错，所以今年内希望达到至少 English native speaker 简单日常使用的水平，具体的计划还需按阶段详细制定，比如阶段性的考核。 Life 健身的频率要从一周2-3次提高到3-4次，并且对每周每次的健身内容做好计划。脑子里现在暂时有一些想法，但具体的计划需要等我先进行一两周的试练再做调整。ps: 短期的目标是在过春节前减重5斤，也就是一个半月内。 再结交同学和同事之外的几位好友，可以是技术相关的，也可以是爱好相关的，当然两者都相关是最好不过的，不过我知道这很难。彼女的话我想在换工作环境前是没有任何可能（笑。 希望今年能用上一次我前年办的护照23333，顺便坐一下因为恐高而没尝试的飞机（其实是没机会。 Deposit 能达到 100K，换工作前和没搞副业前估计是没办法了（笑。 Work 为今年暑假的 leave 和 interview 做好准备，算法题是肯定要刷起来的，还要想好下一份工作的方向，不要盲目选择，对下一家公司也需要做详细的分析。 希望下一份工作能找到城西西溪附近的好公司和好岗位，因为还能省下一笔房租2333。 Fighting~ 后续若有详细计划会继续更新]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Deploy gogs step by step]]></title>
    <url>%2F2018%2F01%2F01%2FDeploy-gogs-step-by-step%2F</url>
    <content type="text"><![CDATA[Gogs就像 Gogs 项目的README里所说，Gogs是一个简单的私人自助Git服务，由Golang编写，理论上来说支持所有Golang所支持的平台。 你可能要问不是有 Github 可以用么？Github 好是好，但毕竟私人仓库是要收费的，而且有些垃圾代码实在不适合放到 Github 上污染民那桑的眼睛，所以就用自己的服务器搭建一个私人 Git 托管服务。 Step1. Download Gogs from Github根据官方文档，下载分为二进制/源码/包管理，服务器我这里使用的是 Vultr 的 Cloud Instance，系统是 Ubuntu16.04。由于包管理只支持 Ubuntu12.04/14.04，而且包管理均为第三方提供，所以我就跳过源码编译直接用二进制安装（当然用 Archlinux 的也可以直接用 AUR 源进行安装），总之分系统类型进行，我个人比较推荐新手直接用部署更为方便的二进制，若之后想更新Gogs二进制，官方文档也提供了如何升级二进制的教程： 下载最新版的压缩包 删除当前的 templates 目录。 解压压缩包并将所有内容复制粘贴到相应（当前）的位置。 废话不多说，直接 wget 下载链接， 然后解压： 12wget https://dl.gogs.io/0.11.34/linux_amd64.zipunzip linux_amd64.zip 目录如下： 123456789101112root@Ubuntu16:~/gogs# ls -ltotal 31384drwxr-xr-x 3 root root 4096 Dec 23 15:30 customdrwx------ 4 root root 4096 Dec 23 15:59 data-rwxr-xr-x 1 root root 32091291 Nov 22 20:01 gogs-rw-r--r-- 1 root root 1054 Feb 11 2017 LICENSEdrwxr-xr-x 2 root root 4096 Jan 1 00:07 logdrwxr-xr-x 8 root root 4096 Nov 22 20:01 public-rw-r--r-- 1 root root 8032 Nov 22 20:01 README.md-rw-r--r-- 1 root root 5329 Nov 19 18:54 README_ZH.mddrwxr-xr-x 7 root root 4096 Nov 22 20:01 scriptsdrwxr-xr-x 11 root root 4096 Nov 22 20:01 templates Step2. Deploy Gogs直接后台运行gogs二进制： 1./gogs web &amp;&amp; 运行成功后，浏览器首次进入 localhost:3000/ 会跳转到 /install，进行首次部署基本配置，比如数据库的选择，账号注册等等，由于我是一个人用，数据库使用 sqlite 绰绰有余。 Step3. Configuration默认配置文件从v0.6.0开始就被嵌入了二进制中，若要进行自定义配置，只需要修改 custom/conf/app.ini，比如 Git仓库根目录、数据库配置或者是否支持注册等。 像我，则是在安装部署和注册账号完成后，禁止了其他人的注册，因为毕竟这只是我个人的 Git 托管服务。若是一个团队协同使用，就不需要关闭注册功能。 123456789101112131415161718192021222324252627282930313233343536373839404142root@Ubuntu16:~/gogs/custom/conf# cat app.iniAPP_NAME = GogsRUN_USER = rootRUN_MODE = prod[database]DB_TYPE = sqlite3#...[repository]ROOT = /root/gogs-repositories[server]DOMAIN = localhostHTTP_PORT = 3000ROOT_URL = http://localhost:3000/DISABLE_SSH = falseSSH_PORT = 22START_SSH_SERVER = falseOFFLINE_MODE = false[mailer]ENABLED = false[service]REGISTER_EMAIL_CONFIRM = falseENABLE_NOTIFY_MAIL = falseDISABLE_REGISTRATION = trueENABLE_CAPTCHA = trueREQUIRE_SIGNIN_VIEW = false[picture]DISABLE_GRAVATAR = falseENABLE_FEDERATED_AVATAR = true[session]PROVIDER = file[log]MODE = fileLEVEL = InfoROOT_PATH = /root/gogs/log Step4. Forward port在部署和配置完成后，其实就已经可以很好的使用Gogs的自助Git服务了，但是在浏览器敲ip地址和端口号太麻烦了，所以我就利用我现有的域名，在DNSPOD上再加了一条二级域名解析，直接取个好记的域名 git.koushiro.me。当然如果你是在狗爹上买的域名并且用得狗爹自己的域名解析，那添加二级域名就更简单了，而且也不需要自己配置端口转发，狗爹的域名解析和跳转支持二级域名直接转发到某个ip地址的端口，但如果你也是和我一样使用DNSPOD来进行域名解析的，那还得多做一步，就是用 nginx 进行 3000 端口的转发。 这一步实际也很简单： 通过包管理安装 Nginx： 12apt install nginx # Debian / Ubuntupacman -S nginx # Archlinux 安装完成后，nginx 的默认配置在 /etc/nginx/nginx.conf 里 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253http &#123; ## # Basic Settings ## sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; # server_tokens off; # server_names_hash_bucket_size 64; # server_name_in_redirect off; include /etc/nginx/mime.types; default_type application/octet-stream; ## # SSL Settings ## ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE ssl_prefer_server_ciphers on; ## # Logging Settings ## access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; ## # Gzip Settings ## gzip on; gzip_disable &quot;msie6&quot;; # gzip_vary on; # gzip_proxied any; # gzip_comp_level 6; # gzip_buffers 16 8k; # gzip_http_version 1.1; # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; ## # Virtual Host Configs ## include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*;&#125; 可以看到最后的 Virtual Host Configs 里的 include， 显而易见，我们只需要在 /etc/nginx/conf.d 新建一个配置文件，然后 reload nginx 服务，就能完成端口转发。 这里我根据我的域名新建一个配置文件 git.koushiro.me.conf，内容如下： 12345678server &#123; server_name git.koushiro.me listen 80; location / &#123; proxy_pass http://localhost:3000; &#125;&#125; 这里我将 git.koushiro.me 的 80 端口请求转发到服务器本地的 3000 端口，也就是 Gogs 服务的默认端口。 OK~ DONE~ PS: 快一年多没写博客了，也正好趁 2018 年的到来，重拾博客，记录些学习和生活，本想继续写篇博客记录下自己一些 2018 年的目标，但时间也不早了，明天还得上班糊代码，那2018目标的那篇博客就放到明天写好了，顺便给自己多一天时间仔细想想，也希望新的一年我能好好完成自己将要定下的目标。]]></content>
      <categories>
        <category>Config</category>
      </categories>
      <tags>
        <tag>gogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Note4 of Effective C++]]></title>
    <url>%2F2017%2F02%2F20%2FEffective-Cpp-Note4%2F</url>
    <content type="text"><![CDATA[这部分主要涉及 new 和 delete 这两个 keyword，它们的一些高级用法在课堂上或者一些 C++ 初学者书籍中很难见到，对于编码者也很少用到这部分内容，当然我对此也不是特别了解。好吧，我其实就是图新鲜【逃 Customizing new and delete本部分的两个主角是：operator new 和 operator delete，配角是 new-handler——这是当无法满足用户的内存需求时所调用的函数。 注意：operator new 和 operator delete 只适用于分配单一对象， Arrays 所用的内存由 operator new[] 分配，并由 operator delete[] 归还。此外 STL container 所使用的 heap 内存是由容器所拥有的分配器对象（allocator object）管理，不是被 new 和 delete 直接管理的。【本部分不会太多地讨论 STL allocator】 既然标题是 Customizing new and delete，那么定制 new 和 delete（或者说重载 new 和 delete）用在哪些时候呢？某些应用程序对内存分配有特殊需求，因此无法将标准内存管理机制直接应用于此类程序，它们常常需要自定义内存分配的细节，比如使用关键字 new 将对象放置在特定的内存空间中。为此，应用程序需要重载 new 运算符和 delete 运算符以控制内存分配的过程。 其实说成 “重载 new 和 delete” 并不太好（我认为“定制”这个词会好些），因为实际上重载这两个运算符与重载其他运算符的过程不同。new 和 delete 的工作原理如下： new 表达式实际执行三步操作 12string *pStr = new string("value"); // 分配并初始化一个 string 对象string *pArr = new string[10]; // 分配10个默认初始化的 string 对象 new 表达式调用名为 operator new 或者（operator new[]）的标准库函数，该函数分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的对象（或对象数组）。 编译器运行相应的构造函数以构造这些对象，并为其传入初始值。 对象被分配了空间并构造完成，返回一个指向该对象的指针 delete 表达式实际执行两步操作 12delete pStr; // 销毁*pStr，然后释放pStr指向的内存空间delete[] pArr; // 销毁数组中的元素，然后释放对应的内存空间 对 pStr 所指的对象或者 pArr 所指数组中的元素执行对应的析构函数 编译器调用名为 operator delete（或者 operator delete[]）的标准库函数释放内存空间。 好了，现在可以知道：如果应用程序希望控制内存分配的过程，即需要定义自己的 operator new 和 operator delete。它们既可以定义在全局作用域，也可以定义为成员函数（定义为成员函数时，它们是隐式静态的，但我建议还是显式声明为 static，因为 operator new 用在对象构造之前而 operator delete 用在对象销毁之后）。当编译器发现 new 或 delete 后，将在程序中查找可供调用的 operator 函数，其匹配查找顺序为：类及其基类的作用域 -&gt; 全局作用域 -&gt; 标准库定义的版本。 标准库定义了 operator new 函数 和 operator delete 函数 的 8个重载版本，前4个版本可能抛出 bad_alloc 异常，后4个版本则不抛出异常： // 可能抛出异常的版本 void* operator new(size_t); void* operator new[](size_t); void* operator delete(void*) noexcept; void* operator delete[](void*) noexcept; // 不会抛出异常的版本 void* operator new(size_t, nothrow_t&amp;) noexcept; void* operator new[](size_t, nothrow_t&amp;) noexcept; void* operator delete(void*, nothrow_t&amp;) noexcept; void* operator delete[](void*, nothrow_t&amp;) noexcept; 与析构函数类似，operator delete 也不允许抛出异常（Item8），重载运算符时必须使用 noexcept 异常说明符指定其不抛出异常。 nothrow_t 是定义在 new 头文件中的一个 struct，nothrow 是一个类型为 nothrow_t 的 const 对象，用户可通过这个对象请求 new 的非抛出版本。 最近有很多书要看 懒癌发作话说剩下的部分不是很熟悉的就是完全没接触过，应该也不会接下去写了，碰到问题再说吧。 最近也入了 Effective Modern C++11/14 和 C++ Template，接下去应该会整理这两本吧（笑） 毕设和找工作一起好忙啊…]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Note3 of Effective C++]]></title>
    <url>%2F2017%2F02%2F11%2FEffective-Cpp-Note3%2F</url>
    <content type="text"><![CDATA[书中第三部分是讲资源管理（Resource Management），只有不足20页，尽管不是专门讲动态内存（dynamical memory）和智能指针（smart pointer），但还是占较大篇幅的，我会结合 C++11 新标准对其进行一些扩充。今日も顽张りましょう。 Tips : 我会在 C++11/14 标准的基础上作笔记 (Effective C++, 3rd Edition 中的内容并不是按照 C++11/14 标准） Resourse ManagementItem 13 : 以对象管理资源 Use objects to manage resourses 123456789101112Object* factory(T arg) // factory 返回指针，指向动态分配的对象&#123; ... return new Object(arg); // 调用者负责释放此内存&#125;void use_factory(T arg)&#123; // 由内置指针（非智能指针）管理的动态内存在被显式释放前一直都会存在 Object* p = factory(arg); ... delete p;&#125; 在某些情况下，use_factory 可能无法删除从 factory 得到的资源对象【这是在实际中很容易放的错】——或许因为 “…” 区域内过早的一个 return；有或者 “…” 区域内的语句抛出异常。无论 delete 如何被忽略过去，泄露的不仅仅是内含 Object 对象的那块内存，还包括对象所保存的任何资源。 使用 new 和 delete 管理动态内存资源的三个常见问题： 忘记 delete 内存。（例子中可能存在的问题） 使用已经释放掉的对象。 同一块内存释放两次。 因此为确保内存等资源总是被释放，需要将资源放进对象。实际上这正是本条款背后的半边想法：把资源放进对象内，依赖 C++ 的 “析构函数自动调用机制” 确保资源被释放。（另半边想法之后讨论） 许多资源被动态分配于 heap 内而后被使用于某个作用域（除了静态内存和栈内存，每个程序还有一个内存池，被称为 free store 或 heap，程序用其来存储动态分配的对象，即运行时分配的对象），它们应该在离开该作用域时被释放。C++ 标准库提供了一类智能指针 unique_ptr，智能指针是个“类指针（pointer-like）”对象，其析构函数自动对其所指对象调用 delete。 12345void function()&#123; std::unique_ptr&lt;Object&gt; pObject(factory()); // 为简洁，factory 中不加实参 ...&#125; // 经由 unique_ptr 的析构函数自动删除 pObject 这个例子展示了 “以对象管理资源” 的两个关键想法： 获得资源后立即放进管理对象（managing object）内。实际上 “以对象管理资源” 的观念常被称为 “资源取得时便是初始化时机（Resource Acquisition Is Initialization，RAII）”，因为实际中几乎总是在获得一笔资源后于同一语句内以该资源初始化某个管理对象。 管理对象（managing object）运用析构函数确保资源被释放。一旦对象被销毁（例如对象离开当前作用域），其析构函数会被自动调用以释放资源。如果使用内置指针管理内存，资源释放前（delete前）抛出异常且未被 catch，这种情况可能会有点麻烦，直接管理的内存是不会自动释放的，但使用智能指针就不存在这样的问题。 unique_ptr 类注意事项： 一个 unique_ptr “拥有” 它所指的对象，也就是说，某个时刻只能有一个 unique_ptr 指向一个给定对象【不然怎么叫 unique →_→. 定义一个 unique_ptr 时，需要将其绑定到一个 new 返回的指针上【不像 shared_ptr，它没有类似 make_shared 的标准库函数返回一个 unique_ptr，后面会提】；而初始化 unique_ptr 必须采用直接初始化形式。 由于 unique_ptr 拥有它所指对象，因此 unique_ptr 不支持普通拷贝和赋值操作。但可通过调用 release 或 reset 将指针的所有权从一个（非const）unique_ptr 转移给另一个 unique。 12345678910111213unique_ptr&lt;string&gt; p1(new string("Hello")); // 正确unique_ptr&lt;string&gt; p2(p1); // 错误：unique_ptr 不支持 拷贝unique_ptr&lt;string&gt; p3;p3 = p2; // 错误：unique_ptr 不支持 赋值// ==========================================================================// 将所有权从 p1 转移到 p2unique_ptr&lt;string&gt; p1(new string("Hello"));unique_ptr&lt;string&gt; p2(p1.release()); // release 将 p1 置为空// 将所有权从 p3 转移到 p2unique_ptr&lt;string&gt; p3(new string("World"));p2.reset(p3.release()); // reset 释放了 p2 原来指向的内存 由于 unique_ptr 不支持普通的拷贝和赋值操作，也就意味着 unique_ptr 并非动态分配资源的利器。举个例子，STL 容器要求其元素发挥“正常的” 拷贝行为，因此这些容器不能使用 unique_ptr。 shared_ptr 类unique_ptr 的替换方案是 “引用计数型智能指针” （reference-counting smart pointer，RCSP）。RCSP 提供的行为类似 垃圾回收（garbage collection），它持续追踪记录指向某笔资源的对象个数，并在无人指向它时自动删除该资源，不同的是 RCSP 无法打破 “环状引用”（cycles of reference，例如两个其实已经没被使用的对象彼此互指，因此好像还处在“被使用”的状态）。 标准库中的 shared_ptr 就是个 RCSP，由于其拷贝行为相比 unique_ptr 显得更”正常”，可被用于 STL 容器以及其他 unique_ptr 不适用的地方。 注意事项： 最安全的分配和使用动态内存的方法是调用名为 make_shared 的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的 shared_ptr。之所以推荐 make_shared 而不是 new 是因为能在分配对象的同时就将 shared_ptr 与之绑定，从而避免无意中将同一块内存绑定到多个独立创建的 shared_ptr 上。【该函数也被定义在头文件 memory 中】 1234// 指向值为 666 的 int 的 shared_ptrshared_ptr&lt;int&gt; pInt = make_shared&lt;int&gt;(666);// 指向值为 “666” 的 stringshared_ptr&lt;string&gt; pString = make_shared&lt;string&gt;(3, '6'); shared_ptr 通过析构函数完成对象销毁和和内存释放的自动化，其析构函数会递减它所指的对象的引用计数，如果引用计数变为 0，shared_ptr 的析构函数就会销毁对象，并释放它所占的内存。 1234567shared_ptr&lt;int&gt; p = make_shared&lt;int&gt;(123); // p 指向的对象只有 p 一个引用者shared_ptr&lt;int&gt; q(p); // p 和 q 指向相同对象，此对象有两个引用者shared_ptr&lt;int&gt; r = make_shared&lt;int&gt;(666); // r 指向的 int 只有一个引用者r = q; // 给 r 赋值，令它指向另一个地址 // 递增 q 指向对象的引用计数，递减 r 原来指向对象的引用计数 // r 原来指向的对象已没有引用者，会自动释放 虽说写了这么多关于 unique_ptr 和 shared_ptr 的东西，但本条款真正强调的是 “以对象管理资源” 的重要性，unique_ptr 和 shared_ptr 只是实际例子。 扩展（智能指针支持的操作） shared_ptr 和 unique_ptr 都支持的操作 shared_ptr&lt;T&gt; sp 空智能指针，可以指向类型为 T 的对象 unique_ptr&lt;T&gt; up p 将 p 用作一个条件判断，若 p 指向一个对象，则为 true *p 解引用 p，获得它指向的对象 p-&gt;mem 等价于 (*p).mem p.get() 返回 p 中保存的指针。若智能指针释放了其对象，get() 返回的指针所指向的对象也就消失，因此不要 delete get() 返回的指针，这会导致同个资源被多次释放 swap(p,q) 交换 p 和 q 中的指针 p.swap(q) shared_ptr 独有的操作 make_shared&lt;T&gt;(args) 返回一个 shared_ptr，指向一个动态分配的类型为 T 的对象，使用 args 初始化此对象 shared_ptr&lt;T&gt; p(q) p 是 shared_ptr q 的拷贝；此操作会递增 q 中的计数器，q 中的指针必须能转换为 T* p = q p 和 q 都是 shared_ptr，所保存的指针必须能相互转换；此操作会递减 p 的引用计数，递增 q 的引用计数，若 p 的引用计数为 0，则将其管理的原内存释放 p.unique() 若 p.use_count() 为 1，返回 true；否则返回 false p.use_count() 返回与 p 共享对象的智能指针数量；可能很慢，主要用于调试 unique_ptr 独有的操作 unique_ptr&lt;T&gt; u1 空 unique_ptr，可以指向类型为 T 的对象，u1 会用 delete 来释放它的指针； unique_ptr&lt;T, U&gt; u2 u2 会使用一个类型为 D 的可调用对象（即删除器）来释放它的指针 unique_ptr&lt;T, U&gt; u(d) 空 unique_ptr，指向类型为 T 的对象，用类型为 D 的对象 d 代替 delete u = nullptr 释放 u 指向的对象，将 u 置为空 u.release() u 放弃对指针的控制权，返回指针，并将 u 置为空 u.reset() 释放 u 指向的对象 u.reset(q) 如果提供了内置指针 q，令 u 指向这个对象；否则将 u 置为空 u.reset(nullptr) 定义和改变 shared_ptr 的其他方法 shared_ptr&lt;T&gt; p(q) p 管理内置指针 q 所指向的对象；q 必须指向 new 分配的内存，且能转换为 T* 类型 shared_ptr&lt;T&gt; p(u) p 从 unique_ptr u 那里接管了对象的所有权；将 u 置为空 shared_ptr&lt;T&gt; p(q, d) p 接管了内置指针 q 所指对象的所有权。q 必须能转换为 T* 类型。p 将使用可调用对象 d 来代替 delete shared_ptr&lt;T&gt; p(p2, d) p 是 shared_ptr p2 的拷贝；唯一的区别是 p 将用可调用对象 d 来代替 delete p.reset() 若 p 是唯一指向其对象的 shared_ptr，reset 会释放此对象。 p.reset(q) 若传递了可选参数内置指针 q ，会令 p 指向 q，否则会将 p 置为空 p.reset(q, d) 若还传递了参数 d，将会调用 d 而不是 delete 来释放 q 请记住 为防止资源泄露，请使用 RAII（Resource Acquisition Is Initialization） 对象，这些对象在构造函数获得资源并在析构函数释放资源。 常被使用的 RAII class 分别是 shared_ptr 和 unique_ptr （标准库较早版本包含auto_ptr，它有 unique_ptr 的部分特性，虽然它还是标准库的一部分，但不建议使用，编写程序时应该使用 unique_ptr）。此外，标准库还定义了 weak_ptr 的伴随类，它是种弱引用，指向 shared_ptr 管理的对象。这三种类型都定义在 memory 头文件中。 Item 14 : 在资源管理类中小心 copying 行为 Think carefully about copying behavior in resourse-managing classes 之前谈论到了 RAII 的概念，也描述了 unique_ptr 和 shared_ptr 如何将这个观念表现在 heap-based 资源上。然而并非所有资源都是 heap-based，对此类资源，像 unique_ptr 和 shared_ptr 这样的智能指针往往不适合作为资源掌控者（resource handler），可能需要建立自己的资源管理类。 既然要建立自己的资源管理类，那肯定要考虑到当一个 RAII 对象被复制时会发生些什么？这是需要面对的问题，大多数时候会有以下两种选择： 禁止复制。如果复制动作对 RAII 对象并不合理，便应该禁止之。在 Item 6 中我已经提及过了：可以将 copying 操作声明为 private 但不定义它；或者使用 C++11 引入的 deleted function。 对底层资源用出 “引用计数法（reference-count）”。有时希望保有资源，直到它最后一个使用者被销毁。这种情况下复制 RAII 对象时，应该将资源的 “被引用数” 递增，shared_ptr 便是如此。但 shared_ptr 的缺省行为是 “当引用次数为0时删除其所指物”，这很有可能不是我们所要的行为，例如使用智能指针管理的资源不是 new 分配的内存。还好 shared_ptr 允许指定 “删除器（deleter）” ——一个函数或函数对象，当引用次数为0时便被调用。【unique_ptr 也允许指定 “删除器”，但管理 “删除器” 的方式与 shared_ptr 不同】 复制底部资源。 需要 “资源管理类” 的唯一理由是：当不再需要某个复件时确保它被释放。在此情况下复制资源管理对象，应该同时也复制其所包含的资源。也就是说，复制资源管理对象时，进行的是 “深度拷贝”。 转移底部资源的所有权。某些场合可能会希望永远只有一个 RAII 对象指向一个未加工资源（raw resource），即使 RAII 对象被复制也如此。此时，资源的拥有权会从被复制物转移到目标物。例如 unique_ptr 中的 release 和 reset 操作。 扩展（shared_ptr 和 unique_ptr 的删除器）shared_ptr 和 unique_ptr 之间明显的不同已经在 Item13 中谈到过了，是它们管理所保存的指针的策略 —— 前者给予共享指针所有权的能力，后者则独占指针。另一个差异是它们允许指定用户重载默认删除器的方式。 重载 shared_ptr 的删除器很容易，只要创建或 reset 指针时传递给它一个可调用对象即可。 12345678void end_connection(connection *p) &#123; disconnect(*p); &#125;void f(destination &amp;d /* 其他参数 */)&#123; connection c = connect(&amp;d); // 打开连接 shared_ptr&lt;connection&gt; p(&amp;c, end_connection); // 使用连接 // 当 f 退出时（即使由于异常而退出），connection 会被正确关闭&#125; 与之相反，删除器的类型是一个 unique_ptr 对象类型的一部分，用户必须在定义 unique_ptr 时以显式模板实参的形式提供删除器的类型。 123456789void f(destination &amp;d /* 其他参数 */)&#123; connection c = connect(&amp;d); // 打开连接 unique_ptr&lt;connection, decltype(end_connection)*&gt; p(&amp;c, end_connection); // 使用连接 // 当 f 退出时（即使由于异常而退出），connection 会被正确关闭&#125;// decltype(end_connection) 返回函数类型，// 必须添加一个 * 来指出我们正在使用该类型的一个指针 尽管不知道标准库类型是如何实现的，但可以推断出 shared_ptr 必须能直接访问其删除器，即删除器必须保存为一个指针或一个封装了指针的类。 可以确定 shared_ptr 不是将删除器直接保存为一个成员的原因，是因为 shared_ptr 重载的删除器类型是直到运行时才会知道的【实际上，在一个 shared_ptr 的生存期内，可以随时改变其删除器的类型】，而通常类成员在运行时是不能改变的，因此，不能将删除器直接保存为一个成员。 而在 unique_ptr 类中，由于删除器的类型是 unique_ptr 类型的一部分，因此删除器成员的类型在编译时是知道的，从而删除器可以直接保存在 unique_ptr 对象中。 通过在编译时绑定删除器，unique_ptr 避免了间接调用删除器的运行时开销；通过在运行时绑定删除器，shared_ptr 使用户重载删除器更为方便。 请记住 复制 RAII 对象必须一并复制它所管理的资源，所以资源的 copying 行为决定 RAII 对象的 copying 行为。 普遍而常见的 RAII class copying 行为是：抑制 copying 行为、施行引用计数法（reference counting）。 Item 15 : 在资源管理类中提供对原始资源的访问 Provide access to raw resourse in resourse-managing classes 实际中许多 API 直接涉及资源，所以除非承诺永不使用这样的 API，否则只得绕过资源管理对象（resource-managing object）直接访问原始资源（raw resource）。 举个例子，再次使用 Item 13 中的代码：123456789Object* factory(T arg) // factory 返回指针，指向动态分配的对象&#123; ... return new Object(arg); // 调用者负责释放此内存&#125;// =====================================================std::unique_ptr&lt;Object&gt; pObject(factory());// 假如有某个 function 希望处理 Object 对象，如下int function(const Object* o); 若想要像下面这么调用 function，是通不过编译的。因为 function 需要的是 Object* 指针，而不是你传给它的类型为 unique_ptr&lt;Object&gt; 的对象。1int ret = function(pObject); // 错误 这时候你需要一个函数可将 RAII class 对象转换为其所内含的原始资源（本例为 Object*），有两种做法可以做到： 显式转换：unique_ptr 和 shared_ptr 都提供了一个 get 成员函数，用来执行显式转换，也就是它会返回智能指针内部的原始指针（的复件）： 1int ret = function(pObject.get()); 隐式转换：unique_ptr 和 shared_ptr 重载了指针取值（pointer dereference）操作符（operator-&gt; 和 operator*），它们允许隐式转换至底部原始指针： 12345678910111213class Object&#123;public: bool IsReal() const; ...&#125;;Object* factory(); // 为代码简洁，此处省略实参shared_ptr&lt;Object&gt; p1(factory());bool ret1 = p1-&gt;IsReal(); // 经由 operator-&gt; 访问资源...unique_ptr&lt;Object&gt; p2(factory());bool ret2 = (*p2).IsReal(); // 经由 operator * 访问资源... 扩展（智能指针的一些使用注意事项）接受指针参数的智能指针的构造函数是 explicit 的，因此必须使用直接初始化形式来初始化一个智能指针【当然更推荐使用 make_shared 来初始化 shared_ptr，前面有提及过原因】：1234shared_ptr&lt;int&gt; p1 = new int(1024); // 错误，必须使用直接初始化形式shared_ptr&lt;int&gt; p2(new int(1024)); // 正确 // shared_ptr 更推荐用 make_shared 初始化shared_ptr&lt;int&gt; p3 = make_shared&lt;int&gt;(1024); 出于相同的原因，一个返回 shared_ptr 的函数不能在其返回语句中隐式转换一个普通指针：12345678910shared_ptr&lt;int&gt; clone(int p)&#123; // 错误，不能隐式转换 return new int(p); &#125;shared_ptr&lt;int&gt; clone(int p)&#123; // 正确，显式地用 int* 创建 shared_ptr&lt;int&gt; return shared_ptr&lt;int&gt;(new int(p));&#125; 不要混合使用普通指针和智能指针，因为当一个 shared_ptr 绑定到一个普通指针时，内存的管理责任就交给了这个 shared_ptr。而继续使用该普通指针很可能会指向（已经释放的）内存【毕竟复杂情况下很难知道对象何时会被销毁】，导致该指针的值是未定义的，这是很危险的。1234567891011121314void process(shared_ptr&lt;int&gt; ptr); // pass-by-valueshared_ptr&lt;int&gt; p(new int(1024)); // 引用计数为 1process(p); // 拷贝 p 会递增它的引用计数，引用计数为 2int i = *p; // 正确，引用计数为 1int *x(new int(1024)); // 危险：x 是普通指针// process(x); // 错误，不能将int* 转换为shared_ptr&lt;int&gt;/* 下面是合法的，但内存会被释放!** 因为是一个临时 shared_ptr传递给 process，当调用表达式结束时，该临时对象就会被销毁。** 销毁这个临时变量会递减引用计数，此时引用计数就变为0，该临时变量所指向的内存会被释放。*/process(shared_ptr&lt;int&gt;(x)); int j = *x; // 未定义的：x 是个空悬指针 也不要使用 get 初始化另一个智能指针 或 为智能指针赋值，因为设计 get 函数的目的是 “为了向不能使用智能指针的代码传递一个内置指针（或者说是如下一部分内容中 必须要取得RAII class对象内原始资源的情况）”。 【注意：只有在代码不会 delete 指针的情况下才能使用 get，特别是，永远不要用 get 初始化另一个智能指针 或 为另一个智能指针赋值，尽管编译器不会给出错误信息】123456shared_ptr&lt;int&gt; p(new int(1024)); // 引用计数为 1int *q = p.get(); // 正确：但使用 q 时要注意，不要让它管理的指针被释放&#123;// 新程序块 shared_ptr&lt;int&gt; (q); // q 和 p 指向相同的内存，q 的引用计数为 1&#125;// 程序块结束，q 被销毁，并且 q 所指向的内存被释放int foo = *p; // 未定义：p 指向的内存已经被释放了 必须要取得 RAII class 对象内原始资源的情况套用书中的例子： 12FontHandle getFont(); // 这是个 C API，为简化暂略参数void releaseFont(FontHandle fh);// 来自同一组 C API 123456789class Font&#123;public: // 采用 pass-by-value，因为 C API 这么做 explicit Font(FontHandle fh) : f(fh) &#123; &#125; ~Font() &#123; releaseFont(f); &#125; // 释放资源private: FontHandle f; // 原始字体资源&#125;; 如果有大量的 C API，它们处理的是 FontHandle，那么 “将 Font 对象转换为 FontHandle” 会是一种频繁的需求。Font class 可为此提供一个如下的显式转换函数，但这使得用户每当要使用 API 时就必须调用 get，这不免会让某些人觉得厌烦。 12345678// 显式转换函数class Font&#123;public: ... FontHandle get() const &#123; return f; &#125; ...&#125;; 另一个办法是令 Font 提供如下的隐式转换函数，转型为 FontHandle，这会使得用户调用 C API 时更为轻松自然。但这份隐式转换会增加错误发生机会。例如用户可能会在需要 Font 时意外创建一个 FontHandle。 12345678// 隐式转换函数class Font&#123;public: ... operator FontHandle() const &#123; return f; &#125; ...&#125;; 1234567// 需要 Font 时意外创建一个 FontHandleFont f1(getFont());...FontHandle f2 = f1;// 原意是要拷贝一个 Font 对象，// 却反而将 f1 隐式转换为其底部的 FontHandle，然后才复制它。// 当 f1 被销毁时，字体被释放，而 f2 会因此成为 “虚吊的（dangle）”。 是否该提供一个显式转换函数（例如 get 成员函数）将 RAII class 转换为其底部资源，或是应该提供隐式转换，答案主要取决于 RAII class 被设计者执行的特点工作，以及它被使用的情况。通常显式转换函数如 get 是比较受欢迎的，因为它将“非故意之类型转换” 的可能性最小化，然而有时候隐式转换所带来的“自然用法”的好处更大。 请记住 API 往往要求访问原始资源（raw resource），所以每一个 RAII class 应该提供一个 “取得其所管理资源” 的办法。 对原始资源的访问可能经由显式转换或隐式转换。一般而言，显式转换比较安全，但隐式转换对客户比较自然。 Item 16 : 成对使用 new 和 delete 时要采取相同形式 Use the same form in corresponding uses of new and delete 该条款，我想稍微会使用动态内存分配的C++编码者应该都了解，所以此处写的比较随便，看看就好。 当你使用 new（也就是通过 new 动态生成一个对象），有两件事发生： 第一，内存被分配出来（通过名为 operator new 的函数，之后会讲） 第二，针对此内存会有一个（或更多）构造函数被调用 当你使用 delete 也有两件事发生： 第一，针对此内存会有一个（或更多）析构函数被调用 第二，然后内存才被释放（通过名为 operator delete 的函数） delete 最大的问题在于：即将被删除的内存内究竟有多少对象，这也意味着究竟有多少个析构函数必须被调用。或者更通俗点来说，即将被删除的指针，其所指的是单一对象还是对象数组。 数组所用的内存通常还包括“数组大小”的记录，以便 delete 知道需要调用多少次析构函数，而单一对象的内存则没有这个记录。 唯一能够让 delete 知道内存中是否存在一个 “数组大小记录” 的办法就是：由编码者告诉编译器，如果使用 delete[]，delete 便认定指针指向一个数组，否则便认定指针指向单一对象。12345678std::string* pStr1 = new std::string;std::string* pStr2 = new std::string[100];...delete pStr1; // 删除单一对象delete[] pStr2; // 删除一个对象数组// =======================================delete[] pStr1; // 结果未定义delete pStr2; // 结果未定义 上述的规则对喜欢使用 typedef 的编码者也很重要，因为它意味着 typedef 的作者必须说清楚，当以 new 创建该种 typedef 类型对象时，该以哪一种 delete 形式删除它。比如下面这种问题：1234567typedef std::string AddressLines[4];// 注意，"new AddressLines" 返回一个 string*，就像"new string[4]" 一样std::string* pAL = new AddressLines;// 必须匹配 “数组形式” 的 delete delete pAL; // 行为未定义delete[] pAL; // 正确 为了避免这样的问题，**最好尽量不要对数组形式做 typedef 动作，而且C++标准库中有许多容器（如vector,string等 templates）可以实现类似数组的需求。 请记住 如果在 new 表达式中使用 []，必须在相应的 delete 表达式中也使用 []；如果一个不用，另一个也一定不要使用。 Item 17 : 以独立语句将 newed 对象置入智能指针 Store newed objects in smart pointers in standalone statements 假设有一个函数用来揭示处理程序的优先权，另一个函数用来在某动态分配所得的 Object 上进行某些带有优先权的处理：12int priority();void processObject(std::shared_ptr&lt;Object&gt; pObj, int priority); 1234// processObject(new Object, priority()); // 错误，编译不通过// 由于 shared_ptr 的构造函数是个 explicit 构造函数，无法进行隐式转换// 只有写成下面这样才能通过编译processObject(std::shared_ptr&lt;Object&gt;(new Object), priority()); 尽管在此使用了 “对象管理式资源”（object-managing resources），但上述调用却仍可能泄露资源。 究其原因，要从 C++ 完成函数参数的核算次序说起。不像 Java 和 C# 语言一样以特定次序完成函数参数的核算，C++编译器对以什么次序来完成这些事情弹性很大。 拿上面的代码举例，C++ 编译器产出一个 processObject 调用码之前，必须首先核算即将被传递的各个实参。此处第二个实参只是单纯地对 priority 函数的调用，但第一个实参 std::shared_ptr&lt;Object&gt;(new Object) 由两部分组成： 执行 &quot;new Object&quot; 表达式 调用 std::shared_ptr 的构造函数 于是在调用 processObject 之前，编译器必须创建代码做以下三件事： 调用 priority() 执行 &quot;new Object&quot; 调用 std::shared_ptr 的构造函数 由于 C++ 核算函数参数的次序不确定，对 priority() 的调用可以排在第一或第二或第三行。【可以确定的是 &quot;new Object&quot; 一定执行于 std::shared_ptr 构造函数被调用之前】 因此如果编译器选择以第二顺位执行 priority 函数【说不定编译器可以生成更高效的代码，谁知道呢!】，最终获得这样的操作序列： 执行 &quot;new Object&quot; 调用 priority() 调用 std::shared_ptr 的构造函数 此时，万一对 priority() 的调用抛出异常，&quot;new Object&quot; 返回的指针将会遗失，因为它尚未被置入我们期盼用来防止资源泄露的 std::shared_ptr 内。 避免这类问题的办法很简单：使用分离语句，分别写出 创建 Object ，将它置入一个智能指针内 然后再把那个智能指针传给 processObject123std::shared_ptr&lt;Object&gt; pObj(new Object);processObject(pObj, priority()); 上面的代码之所以能行得通，是因为编译器对于 “跨越语句的各项操作” 没有重新排列的自由（只有在语句内它才拥有那个自由度）。 请记住 以独立语句将 newd 对象存储于智能指针内。如果不这么做，一旦异常被抛出，有可能导致难以察觉的资源泄露。 【备注】：还有一类智能指针 weak_ptr 在此并没有被讲到，但值得了解。]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Note2 of Effective C++]]></title>
    <url>%2F2017%2F02%2F03%2FEffective-Cpp-Note2%2F</url>
    <content type="text"><![CDATA[过年好像并没有想象的这么闲，无聊又麻烦的事情比较多【这也是我过年期间中的daikirai】，所以第二部分的整理来的有些迟，这一部分的 Items 相比第一部分要短小简洁，而且这部分 Items 中对我来说绝大多数都是较熟悉的【毕竟构造和析构这种东西写的太多了】，除了 Item 8 ，可能是实际中异常我用的比较少。总之，Let’s do it ! Tips : 我会在 C++11/14 标准的基础上作笔记 (Effective C++, 3rd Edition 中的内容并不是按照 C++11/14 标准） Constructor, Destructor, and Assignment OperatorItem 5 : 了解C++默默编写并调用哪些函数 Know what functions C++ silently writes and calls 在一个空类中，若没有自定义 类内特殊成员函数（ default constructor、copy constructor、copy assignment operator、destructor） 的声明，则编译器就会为其对应地声明（编译器版本）一个，所有这些编译器自动生成的函数都是 public 且 inline。例如：1class Empty &#123; &#125;; 就像写下了这样的代码：12345678910111213141516class Empty&#123;public: Empty() &#123;...&#125; // default constructor Empty(const Empty&amp; rhs) &#123; ... &#125; // copy constructor Empty&amp; operator=(const Empty&amp; rhs) &#123; ... &#125; // copy assignment operator ~Empty() &#123; ... &#125; // destructor&#125;;// ==============================================int main()&#123; Empty e1; // call default constructor Empty e2(e1); // call copy constructor e2 = e1; // call copy assignment operator return 0; // call destructor&#125; 注意 只有当这些函数被需要（即被调用）时，才会被编译器创建出来。 编译器产出的 destructor 是个 non-virtual，除非该 class 的 base class 自身声明有 virtual destructor。 至于编译器创建的 copy constructor 和 copy assignment operator 只是单纯地将来源对象的每一个 non-static 成员变量拷贝到目标对象。 编译器拒绝为 class 生出 operator= 的情况： 打算在一个 “内含 reference 成员” 的 class 内支持赋值操作（assignment），必须自定义 copy assignment operator 面对 “内含 const 成员” 的 class，编译器反应一样 若某个 base class 将 copy assignment operator 声明为 private，则编译器拒绝为其 derived class 生成一个 copy assignment operator 在此，我给出自己的建议，那就是：不论是要使用编译器默认生成的,还是自定义的，一律都显式地写出。一致的规则难道不是更好记么？【当然非必要的情况不要提供 default constructor（具体见 More Effective C++,Item 4），具体来说 凡是可以“从无到有生成对象”的 classes 都应该内含 default constructor，而“必须有某些外来信息才能生成对象”的 classes 则不必拥有 default constructor，因为这类 classes 没有获得外来信息产生的对象显然毫无意义】 此外，C++11 标准还引进了 defaulted function ，defaulted function 特性 仅适用于类的特殊成员函数，即 可以显式地写出编译器自动生成的版本，而且 defaulted function 既可以在类体内定义，也可以在类体外定义。比如上述代码可改为：12345678class Empty&#123;public: Empty() = default; Empty(const Empty&amp; rhs) = default; Empty&amp; operator=(const Empty&amp; rhs) = default; ~Empty() = default;&#125;; 请记住 编译器可以自己为 class 创建 default constructor、copy constructor、copy assignment operator，以及 destructor。 Item 6 : 若不想使用编译器自动生成的函数，就该明确拒绝 Explicitly disallow the use of compiler-generated functions you do not want 有些东西是先天独一无二的，而能对这些对象进行拷贝显然是我们不乐意看到的。 通常不希望 class 支持某一特定功能，只要不声明对应函数就行。但这个策略对 copy constructor 和 copy assignment operator 却不起作用，因为尽管不声明它们，编译器也会暗自为我们声明。 那怎么办呢，在 C++11 标准以前，阻止拷贝较受欢迎的做法便是：将这类独一无二的对象的 copy constructor 和 copy assignment operator 声明为 private 但不定义它们 。123456789class UniqueObject&#123;public: ...private: ... UniqueObject(const UniqueObject&amp;); // 只有声明 UniqueObject&amp; operator=(const UniqueObject&amp;);&#125; 因为通过明确声明成员函数可以阻止编译器暗自创建其专属版本，而令这些函数为 private 可以阻止开发人员调用它，但只做到此显然并不绝对安全，因为 成员函数 和 友元函数 还能调用同一个类中的 private 函数。在此之上，还必须要不定义它们，以便有人不慎调用任何一个，链接器能返回一个链接错误（linkage error）。 而在 C++11 标准引入了 deleted function 之后，解决方法就显得简单多了：1234567class UniqueObject&#123;public: ... UniqueObject(const UniqueObject&amp;) = delete; UniqueObject&amp; operator=(const UniqueObject&amp;) = delete;&#125; deleted function 的注意事项 =delete 和 =default 不同，必须出现在函数第一次声明时。 可以对任何函数指定 =delete，但主要用途还是禁止拷贝控制成员。 不能将 destructor 指定为 =delete。 编译器合成的拷贝控制成员也可能是 deleted。 请记住 C++11标准前：为驳回编译器自动提供的功能（更具体说是为了阻止拷贝），可将相应的成员函数（即 copy constructor 和 copy assignment operator）声明为 private 并且不予实现。 C++11标准后：通过将 copy constructor 和 copy assignment operator 指定 =delete 即可禁止拷贝。 Item 7 : 为多态基类声明virtual析构函数 Declare destructors virtual in polymorphic base classes C++ 明白指出：当 derived class 对象经由一个 base class 指针被删除，而该 base class 带着一个 non-virtual 析构函数，其结果是未定义的——实际执行时通常发生的是 对象的 base class 成分被销毁，然而其 derived 成分没被销毁，造成一个 “局部销毁” 对象。 举个例子【我知道这例子很做作，也请先不要理会手工delete这件事，看看就好→_→】：1234567891011121314class Animal&#123;public: Animal(); ~Animal(); // 解决办法：virtual ~Animal(); ...&#125;;class Cat : public Animal &#123; ... &#125;;class Rat : public Animal &#123; ... &#125;;// ================================Cat tom;Animal* pA = &amp;tom;...delete pA; 解决办法很简单：给 base class 一个 virtual 析构函数，因为 virtual 函数的目的就是允许 derived class 的实现得以客制化。 注意： “给 base class 一个 virtual 析构函数” 这个规则 只适用于 polymorphic（带多态性质的）base class 身上，目的是为了用来 “通过 base class 接口处理 derived class 对象”，而并非所有 base class 的设计目的都是为了多态用途。 例如标准string 和 STL容器，如果你企图继承一个STL容器 或 任何其他“带有 non-virtual 析构函数”的 class，就可能会导致刚开始就讲到的未定义错误【很可惜C++中没有提供类似 C#中的 sealed class 那样的“禁止派生”机制】。 这里要提及一下 pure virtual 函数，它也涉及到 virtual destructor【可能会带来些许便利】。pure virtual 函数导致 abstract class——即不能被实例化的 class，也就是不能创建这类型的对象。 有时候会希望拥有一个 abstract class，该怎么做呢？由于 abstract class 总是被当做一个 base class 来用，而又由于 base class 应该有一个 virtual 析构函数，因此做法很简单：为期望成为抽象的 class 声明一个 pure virtual destructor。12345class AbstractClass&#123;public: virtual ~AbstractClass() = 0; // 声明 pure virtual 析构函数&#125;; 还有个小窍门：必须为 pure virtual destructor 提供一份定义。1AbstractClass::~AbstractClass() &#123; &#125; // pure virtual 析构函数的定义 这样做的原因是：对象的析构是会调用 derived class 的析构函数，然后接着调用 base class 的析构函数。也就是说编译器会在 AbstractClass 的 derived class 的析构函数中创建一个对 ~AbstractClass 的调用动作，所以必须提供定义，不然链接器会拿小拳拳捶你胸口的→_→ 扩展（关于vptr和vtbl）关于 virtual 关键字，我想稍微有点C++编码经验的应该大致了解其语法，这里并不想多说，而是把重点放在 “不论class是否为base class，都令其析构函数为virtual” 这种做法不好在哪里。 要实现人们期望的 virtual 函数的功能，对象必须携带某些信息——主要用于在运行期决定哪一个 virtual 函数该被调用。这份信息通常由一个所谓 虚表指针（vptr）指出，虚表指针（vptr）指向一个由函数指针构成的数组——称为虚表（vtbl）。每一个带有 virtual 函数的 class 都有一个相应的 vtbl，当对象调用某一 virtual 函数，实际调用的函数取决于该对象的 vptr 所指的那个 vtbl ——编译器在其中寻找适当的函数指针。 讲了这么多，其实重点是想说明某个内含 virtual 函数的 class，其对象的体积会增加一个 vptr 指针的大小【具体大小要看计算机体系结构】。还有像书中所说，更有甚者将这样一个对象传给其他语言【比如C】编写的函数，这也将不再可能（因为其他语言的对应物并没有 virtual），除非你自己明确地补偿 vptr，这不是给自己找罪受吗(⊙_⊙)？ 请记住 polymorphic（带有多态性质的）base classes 应该声明一个 virtual 析构函数。如果 class 带有任何 virtual 函数，它也就应该拥有一个 virtual 析构函数。 某 class 的设计目的若不是作为 base class 使用，或不是为了具备多态性（polymorphically），就不该声明 virtual 析构函数。 Item 8 : 别让异常逃离析构函数 Prevent exceptions from leaving destructors C++ 并不禁止析构函数抛出异常，但不鼓励这么做。比如下面的代码：1234567891011class Object&#123;public: ... ~Object() &#123; ... &#125; // 假设抛出一个异常&#125;;void doSomething()&#123; std::vector&lt;Object&gt; v; ...&#125; // 此处 v 被销毁 假设【就是有这么多假设】v 中含有10个 Object，析构第一个时抛出一个异常，但其他9个还是应该被销毁，此时若有第二个 Object 抛出异常，那么在两个异常同时存在的情况下，C++程序不是过早结束执行就是导致不明确行为【本例会导致不明确行为】。说实话，其实我之前根本不知道这个，谁让我异常写得少【逃。 特殊情况若析构函数必须要执行某个动作，但该动作可能会在失败时抛出异常，你就说这尴不尴尬… 说实话，我觉得书中负责数据库连接的例子并不是非常简单明了【这估计也是因为我很少写异常→_→ 所以…我就不打算放上来了，感觉自己一时半会也想不出来一个好例子，先不写实例代码了【如果有人能给出的话，不甚感激 避免问题的两个办法： 抛出异常就结束程序，通常通过调用 std::abort() 完成。 吞下抛出的异常，一般而言，这是个坏主意，它压制了某些动作失败的重要信息，但有时候吞下异常也比负担 “草率结束程序”或“发生不明确行为”的风险要好。 这两个办法都没有什么吸引力，都无法对“导致抛出异常”的情况作出反应。 那要怎么做呢？一个较佳策略是：重新设计可能会抛出异常的接口，使客户（即使用者）有机会对可能出现的问题作出反应。有人可能会觉得把析构函数的部分工作转移给客户对客户是一种负担，其实不然，这只是给他们一个处理错误的机会，否则他们没机会响应，如果他们认为这个机会没用，ok，直接可以忽略它。如果之后他们再抱怨异常的发生，让他们滚蛋，已经给过他们机会了。【没毛病，很有道理… 回到特殊情况上来，如果某个操作可能在失败时抛出异常，但又因为某种需要必须处理该异常，那么这个异常必须来自析构函数以外的某个函数。因为析构函数抛出异常就是危险，总会带来“过早结束程序”或“发生不明确行为”的风险。 请记住 析构函数绝对不要抛出异常。如果某个被析构函数调用的函数可能会抛出异常，析构函数应该能catch所有异常，并将它们吞下（不传播）或结束程序。 若需要对某个操作函数运行期间抛出的异常做出反应，class 应该提供一个普通函数（而非析构函数）执行该操作。 Item 9 : 绝不在构造和析构过程中调用virtual函数 Never call virtual function during construction or destruction 既然标题已经这么明显了，那么肯定会有人问为什么这么做【至少我会想一想 套用书中一个明显看出违反本条款的例子【懒得自己想了1234567891011121314151617181920212223242526class Transaction&#123;public: Transaction(); // 记录交易日志 virtual void logTransaction() const = 0; // pure virtual function ...&#125;;Transaction::Transaction()&#123; ... logTransaction();&#125;class BuyTransaction : public Transaction&#123;public: virtual void logTransaction() const; ...&#125;;class SellTransaction : public Transaction&#123;public: virtual void logTransaction() const; ...&#125;; 若执行 BuyTransaction b，显然会调用 BuyTransaction 构造函数，而调用 BuyTransaction 构造函数之前一定要调用基类 Transaction 的构造函数——使得 derived class 对象内的 base class 成分先构造完。 问题在于：例子中的 Transaction 构造函数却在最后调用了 virtual 函数 logTransaction。 注意： 这时候被调用的 logTransaction 是 Transaction 内的版本，不是 BuyTransaction 内的版本——即使当前要建立的对象类型是 BuyTransaction，也就是说 base class 构造期间，virtual 函数绝不会下降到 derived class 层面。或者换一种更哲♂学的说法：在 derived class 对象的 base class 构造期间，对象类型是 base class 而不是 derived class。 想想看，当 base class 构造函数在执行时，derived class 的成员变量尚未初始化，若此时 virtual 函数下降到 derived class 层面，derived class 中的函数一般会取用 local 成员变量，而这些变量又没初始化，那肯定会导致未定义行为。 相同道理也适用于 析构函数。一旦 derived class 析构函数开始执行，目标对象内的 derived class 成员变量所占的资源即将归还系统，此时这些成员变量便呈现未定义值【这么说不知道恰不恰当】，C++ 也仿佛视它们不存在，进入 base class 析构函数后，对象就成为了一个 base class 对象，C++ 的任何部分包括 virtual 函数等也都这么看待它。 不易察觉的情况及避免方法上述示例中，应该很容易就能看出不符合标题，但很多情况并不会被轻易察觉。 比如，Transaction 有多个构造函数，而且都要执行某些相同工作，显然代码复用是个很好的主意。123456789101112131415class Transaction&#123;public: Transaction(.) &#123; init(); ... &#125; Transaction(..) &#123; init(); ... &#125; ... virtual void logTransaction() const = 0; ...private: void init() // 复用的代码 &#123; ... logTransaction(); &#125;&#125;; 此时由于 logTransaction 是个 pure virtual 函数【调用pure virtual函数，一般程序会被系统直接中止】，若 logTransaction 是个 impure virtual 函数，那么这样的代码通常不会引发编译器和链接器的组合小拳拳，但显然也会发生上面提及的问题。因此，唯一能够避免此问题的做法就是：确定构造函数和析构函数都没有（在对象被创建和被销毁期间）调用 virtual 函数，而它们调用的所有函数也都服从同一约束。 可能有人发现了，讲了一大堆，若真的想 在对象被创建时 调用适当的 logTransaction，那该怎么办？书中给出了一种做法：将 logTransaction 改为 non-virtual，然后要求 derived class构造函数传递必要信息给 Transaction 构造函数，而后便可安全调用 non-virtual 的 logTransaction。 123456789101112131415161718192021222324class Transaction&#123;public: explicit Transaction(const std::string&amp; logInfo); void logTransaction(const std::string&amp; logInfo) const; ...&#125;;Transaction::Transaction(const std::string&amp; logInfo)&#123; ... logTransaction(logInfo);&#125;class BuyTransaction : public Transaction&#123;public: BuyTransaction( parameters ) : Transaction(createLogString( parameters )) &#123; ... &#125; ...private: // 此函数为 static，也就不可能意外指向 BuyTransaction 对象内初期尚未初始化的变量 static std::string createLogString( parameters );&#125;; 怎么感觉这个 Item 这么长啊… 果然我好垃圾啊… 但是垃圾的我还是要牢牢记住这个 Item 的标题和下面的”请记住”条目… 请记住 在构造和析构期间不要调用 virtual 函数，而它们调用的所有函数也都服从同一约束，因为这类调用从不下降到 derived class （比起当前执行构造函数和析构函数的那层）。 Item 10 : 令 operator= 返回一个 reference to *this Have assignment operators return a reference to *this 赋值采用右结合律，连锁赋值形式 x = y = z = 1 被解析为 x = (y = (z = 1))。 为了实现自定义 class 的 “连锁赋值” 操作， class 应该遵循协议：赋值操作符必须返回一个 reference 指向操作符的左侧实参。 该协议不仅适用于标准赋值形式，也适用于所有赋值相关运算，如： 123456789101112131415161718192021222324class Object&#123;public: ... // 返回类型为 reference，指向当前对象 Object&amp; operator = (const Object&amp; rhs) &#123; ... return *this; &#125; // 也适用于 +=，-=，*= 等运算操作 Object&amp; operator += (const Object&amp; rhs) &#123; ... return *this; &#125; // 此函数也适用，即使此操作符的参数类型不符协定 Object&amp; operator = (int rhs) &#123; ... return *this; &#125; ...&#125;; 注意：这只是个协议，并无强制性，若不遵守该协议，代码仍然能编译通过。但是 这份协议被所有内置类型和标准程序库提供的类型共同遵守，所以没有什么特别的理由，还是遵守它比较好。 请记住 令赋值（assignment）操作符返回一个 reference to *this。 Item 11 : 在 operator= 中处理“自我赋值” Handle assignment to self in Operator = 自我赋值，顾名思义，发生在对象被赋值给自己时，有些自我赋值一眼就能看出，而另一些则很难看出来，这类很难看出来的自我赋值可能会导致一些意料之外的错误，这里套用书中的例子，建立一个 class 用来保存一个指针指向一块动态分配的位图（bitmap）： 1234567891011121314class Bitmap &#123; ... &#125;;class Object&#123;...private: Bitmap* pb; // 指向一个从 heap 分配得到的对象&#125;;// 一份不安全的 operator = 实现版本Object&amp; Object::operator = (const Object&amp; rhs)&#123; delete pb; pb = new Bitmap(*rhs.pb); return *this;&#125; 此处可能存在的自我赋值问题是：operator = 函数内的 *this 和 rhs 有可能是同个对象。若是同个对象的话，当前对象 delete pb 的时候顺便也销毁了 rhs 的 bitmap，最后函数返回的是一个指针指向一个已被删除的对象，这显然不行。 传统的解决办法：通过 “证同测试（identity test）” 检验自我赋值。123456789Object&amp; Object::operator = (const Object&amp; rhs)&#123; // 若是自我赋值，不做任何事 if (this == rhs) return *this; delete pb; pb = new Bitmap(*rhs.pb); return *this;&#125; 但该版本仍然会导致异常，比如 “new Bitmap” 时抛出异常。由于 让 operator = 具备“异常安全性”往往自动获得“自我赋值安全”的回报，因此许多人把重心放在实现“异常安全性”上。比如：1234567Object&amp; Object::operator = (const Object&amp; rhs)&#123; Bitmap* pOrigin = pb; // 存储原先的 pb pb = new Bitmap(*rhs.pb); delete pOrigin; // 删除原先的 pb return *this;&#125; 此处函数内对原 bitmap 做了一个复件、删除原 bitmap、然后指向新创建的那个复件，即使 new Bitmap 抛出异常，pb 仍保持原状。虽说这种做法不高效，但行得通。 另一种替换方案，即 copy and swap技术 可以确保代码不但“异常安全”，而且“自我赋值安全”，并且比起上面在 operator= 函数内手工排列语句显得更简洁【说实话这个部分的 swap 我都还没弄清楚，所以先将就看看，之后弄懂了再来补充，希望想的起来→_→】。1234567891011121314151617181920class Object&#123;...void swap(Object&amp; rhs); // 交换 *this 和 rhs 的数据，具体实现【未完】... &#125;;Object&amp; Object::operator = (const Object&amp; rhs)&#123; Object temp(rhs); swap(temp); // 将 *this 数据 和 复件数据 交换 return *this;&#125;/*// 这种做法尽管聪明，但感觉会让代码不够清晰Object&amp; Object::operator = (Object rhs)&#123; swap(rhs); return *this;&#125;*/ 请记住 确保当前对象自我赋值时，operator = 有着良好的行为，其中涉及的技术包括：比较“来源对象”和“目标对象”的地址、精心周到的语句顺序、以及 copy-and-swap 技术。 Item 12 : 复制对象时勿忘其每一个成分 Copy all parts of an object copying 函数 包括 copy constructor 和 copy assignment operator，这两个函数负责对象拷贝。 我在最开始部分（即 Item 5）说过，就我个人而言，我更推荐声明自己的 default constructor、destructor、copying 函数（copy constructor、copy assignment operator），此时编译器就仿佛自己的权威受到了挑战，在代码显然出错的地方也不会告诉你。套用书中的例子：1234567891011121314151617181920212223void logCall(const std::string&amp; funcName);class Customer&#123;public: Customer() = default; ~Customer() = default; Customer(const Customer&amp; rhs); Customer&amp; operator = (const Customer&amp; rhs);private: std::string name;&#125;;Customer::Customer(const Customer&amp; rhs) : name(rhs.name)&#123; logCall("Customer copy constructor");&#125;Customer&amp; Customer::operator = (const Customer&amp; rhs)&#123; logCall("Customer copy assignment operator"); name = rhs.name; return *this;&#125; 若此时再加入另一个成员变量–顾客的最近交易日期【如下】，问题就出现了，当前既有的 copying 函数执行的是 局部拷贝（partial copy）：的确复制了顾客的 name，但没有复制新添加的 lastTransaction。大多数编译器【包括VC++】对此不出任何怨言–即使在最高警告级别中，但是这也不能说是编译器的责任，谁让你不把新加入的变量写进 copying 函数里【说到底还是编码者的责任→_→123456789class Date &#123; ... &#125;; // 具体内容随便写class Customer&#123;public: ...private: std::string name; Date lastTransaction;&#125;; 还有注意在继承中，derived class 容易在 copying 函数中遗漏 base class 的成分，忘记的话就是你自己的锅了→_→，比如正确的情况如下：123456789101112131415161718192021222324class PriorityCustomer : public Customer&#123;public: ... PriorityCustomer(const PriorityCustomer&amp; rhs); PriorityCustomer&amp; operator = (const PriorityCustomer&amp; rhs); ...private: int priority;&#125;;PriorityCustomer::PriorityCustomer(const PriorityCustomer&amp; rhs) : Customer(rhs), // 调用 base class 的 copy constructor priority(rhs.priority)&#123; logCall("PriorityCustomer copy constructor");&#125;PriorityCustomer&amp; PriorityCustomer::operator = (const PriorityCustomer&amp; rhs)&#123; logCall("PriorityCustomer copy assignment operator"); Customer::operator=(rhs); // 对 base class 成分进行赋值动作 priority = rhs.priority; reference *this;&#125; 可能有人觉得两个 copying 函数有相似的实现内容，可以像之前说过的在 const 和 non-const 成员函数中避免代码重复一样，用某个调用另一个。但其实只要认真思考一下：copy constructor 用来初始化新对象，而 copy assignment operator 只能作用在已初始化的对象身上，不管是构造一个已经存在的对象，还是对一个尚未构造好的对象赋值 显然都是荒谬的，无意义的。 请记住 copying 函数应确保复制 “对象内的所有成员变量” 以及 “所有 base class 成分”。 不要尝试以某个 copying 函数实现另一个 copying 函数，应将共同功能放进另一个函数，供这两个 copying 函数调用。]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Note1 of Effective C++]]></title>
    <url>%2F2017%2F01%2F26%2FEffective-Cpp-Note1%2F</url>
    <content type="text"><![CDATA[之前买了这本书后只是草草翻过，这半个多月以来，断断续续把这本书从头到尾看了一遍，虽然其中的一些条款内容早就熟记于心，但难免还有晦涩之处，所以打算在过年空闲期间把整本书的每个条款的重点进行系统的整理。不得不说 C++ 是门不好学的语言，自认为也没那么聪明，整理总结对我来说不失为一个深入学习的好方法。 Tips : 我会在 C++11/14 标准的基础上作笔记 (Effective C++, 3rd Edition 中的内容并不是按照 C++11/14 标准） Accustoming Yourself to C++Item 1 : 视C++为一个语言联邦 View C++ as a federation of languages C++ 是个多重范式编程语言，同时支持： 过程形式（procedural） 面向对象形式（objecr-oriented） 函数形式（functional） 泛型形式（generic） 元编程形式（metaprogramming） 将 C++ 视为一个语言联邦而非单一语言，可以更易理解。在其某个次语言中（sublanguage）中，各守则与通例都倾向简单、直观易懂，并且容易记住。 C++ 主要的次语言，有四个： C：C++ 以 C 为基础，这没什么好说的。 Object-Oriented C++：无非就是 classes（包括构造函数和析构函数）、封装（encapsulation）、继承（inheritance）、多态（polymorphic）、virtual函数（动态绑定）… 这一部分应该是所有面向对象语言的基础。 Template C++：C++ 的泛型编程部分，template 威力强大，也带来了崭新的编程范式，也就是所谓的 template metaprogramming （TMP，模板元编程），TMP相关规则很少与 C++ 主流编程互相影响。最基本的 TMP 应该就是求阶乘，这会在后面的专题中讲到。 STL：顾名思义，C++ 的标准模板库，对 容器（container）、迭代器（iterator）、算法（algorithm）以及函数对象（function object）的规约有极佳的紧密配合与协调。 请记住 C++ 高效编程守则视状况而变换，取决于使用 C++ 的哪一部分。 Item 2 : 尽量以 const, enum, inline 替换 #define Prefer const, enum, and inline to #define 以 const 替换 #define#define 不被视为需要编译语言的一部分，它是被交给预处理器处理的。如果某个宏比如 #define MAGIC_NUM 123 被定义在非自己所写的头文件中，那么很可能在编译出错获得编译错误信息时，对出现的 123 而不是 MAGIC_NUM 这么一个数据的出现感到莫名其妙。 但如果将其声明为一个 const 常量 const int magic_num = 123 或者 此处也可声明为一个常量表达式 constexpr int magic_num = 123 （注：constexpr 是 C++11 标准中引入的，指值不会改变并且在编译过程就能得到计算结果的表达式，显然字面值属于常量表达式），作为一个语言常量，就肯定会被编译器看到。 至于对浮点常量而言，使用常量可能比使用 #define 导致较小量的码 这种情况我觉得作用不大，就不用记住了。（所谓的较小量的码指的是预处理器盲目地将宏名称 MAGIC_NUM 替换为 123 可能导致目标码出现多份 123，而改用常量则不会出现这种情况） 这里还要说下以常量 const 替换 #define 的两种特殊情况： 定义常量指针（constant pointers），由于常量定义式通常被放在头文件内，因此有必要将指针声明为 const。 定义 class 专属常量，为将常量作用域限制在 class 内，必须让其成为 class 的一个成员（member），而为确保此常量至多只有一份实体，必须让其成为一个 static 成员， 例如 static const int value = 1;。此处是 value 的声明式而非定义式，通常 C++ 要求对使用的任何东西提供一个定义式，但如果它是个 class 专属常量（const）又是 static 且为整数类型（例如 int， char，bool），则需特别处理：只要不取其地址，可以只声明并使用它而无需提供定义式。 而 #define 并不重视作用域，也就无法创建一个 class 专属常量，也不能提供任何封装性，而 const 成员变量可以被封装。 以 enum 替换 #define这一部分是接着上面的 class 专属常量 展开叙述的。 所谓的 in-class 初值设定只允许对整数常量（例如int、char、bool）进行。即下面的代码是无法通过编译的 12345class Test&#123;private: static const double value = 0.5; // 无法通过编译&#125;; 不过有些旧式编译器（我电脑上的都能编译通过）（错误地）不允许 “static 整数型 class 常量” 完成 “in-class 初值设定”，可改用所谓的 “the enum hack” 补偿做法。原因是：一个属于枚举类型（enumerated type）的数值可权充 int 被使用，即如下 123456class Test&#123;private: // 可权充 static const int value = 1; enum &#123; value = 1&#125;;&#125;; 除了编译器层面上的理由外，认识 enum hack 还有两个理由： 这个理由看看就行，平常也用不太到。enum hack 的行为某方面说比较像 #define 而不像 const，但有时这也是我们想要的。例如不想让别人获得一个 pointer 或 reference 指向某个整数常量，enum 可以帮助实现这个约束，因为取一个 enum 的地址是不合法的，而取一个 #define 的地址通常也不合法，但取一个 const 的地址是合法的。此外，不够优秀的编译器可能会为 “整数型 const 对象” 设定另外的存储空间，但 enum 和 #define 一样绝不会导致非必要的内存分配。 纯粹是为了实用主义，因为许多代码中用到了它，所以也就必须要了解其含义。事实上，enum hack 是 TMP（模板元编程）的基础技术，但我自己本身更喜欢直接用 static const int 之类的 in-class 初值设定（谁会用连这个都编译不通过的编译器啊）。 例如，下面的代码是最简单的 TMP 代码之一（实现阶乘），不理解 TMP 的看看就好 12345678910111213template&lt;unsigned n&gt;struct Factorial&#123; enum &#123; value = n * Factorial&lt;n-1&gt;::value &#125;; // static const int value = n * Factorial&lt;n-1&gt;::value;&#125;;template&lt;&gt;struct Factorial&lt;0&gt;&#123; enum &#123; value = 1 &#125;; // static const int value = 1;&#125;; 以 inline 替换 #define用 #define 实现宏（macros）是一种常见的做法，宏看起来像函数，但不会有函数调用（function call）带来的额外开销。例如12// 以 a 和 b 的较大值调用 f#define CALL_WITH_MAX(a,b) f( (a) &gt; (b) ? (a) : (b) ) 书中说以 #define 实现宏是误用情况，我不这么认为，至少现在绝大多数的单元测试代码中都包含大量 #define 实现的宏，前提是正确的使用。如上述 CALL_WITH_MAX 这般长相的宏的确存在的太多缺点： 写出这种宏时记住必须要为 宏中所有实参 加上小括号，否则在某些表达式调用这个宏时会得不到想要的结果。（这部分学过C++的应该都知道，就不细说了） 但纵使为所有实参加上小括号，也会出现意料之外的事，比如 12345int a = 5, b = 0;// (++a) &gt; (b) ? (++a) : (b) CALL_WITH_MAX(++a, b); // a 被累加二次// (++a) &gt; (b+10) ? (++a) : (b+10)CALL_WITH_MAX(++a, b+10); // a 被累加一次 此处调用 f 之前，a 的递增次数竟然取决于 “它被拿来和谁比较”，你说这种情况还不令人恶心么？ 因此 C++ 引入了 inline ，不仅获得了宏带来的效率，还有一般函数的所有可预料行为和类型安全性（type safety）。 上面的宏就可改写为一个 template inline 函数：12345template&lt;typename T&gt;inline void call_with_max(const T&amp; a, const T&amp; b)&#123; f(a &gt; b ? a : b);&#125; 此外，由于 call_with_max 是个真正的函数，它遵守作用域和访问规则。 请记住 对于单纯常量，最好以 const 对象或 enum 替换 #define 对于形似函数的宏（macros），最好改用 inline 函数替换 #define 有了 const、enum、inline，对预编译器（特别是#define）的需求降低了，但并非完全消除。 Item 3 : 尽可能使用 const Use const whenever possible C++ 对常量性的定义只要某个值不变，就该明确定义为 const，因为说出来可以获得编译器的帮助，确保约束不被违反。 可以用它在 classes 外部修饰 global 或 namespace 作用域的常量，或修饰文件、函数、或区块作用域中被声明为 static 的对象。也可以用它修饰 classes 内部的 static 和 non-static 成员变量。面对指针时，也可以指出指针本身、指针所有物、或两者都（或都不）是 const，如下：12345char array[] = "Hello World";char* p = array; // non-const pointer, non-const dataconst char* p = array; // non-const pointer, const datachar* const p = array; // const pointer, non-const dataconst char* const p = array; // const pointer, const data 虽说绝大部分 C++ 开发者肯定都应该知道这一点， 但我还是决定在此写一遍：const 出现在 * 号左边，表示被指物是常量；出现在 * 号右边，表示指针本身是常量；出现在 * 号两边，表示被指物和指针都是常量。 此外，还要提及两种 被指物是常量的 编写习惯：123// 我相信大多数人都应该会跟我一样，更习惯第一种的编写void f1(const T* p);void f2(T const * p); STL 迭代器类似于指针，因为其本身就是为了模仿指针的作用，但要注意的一点是：若希望迭代器所指的东西不可改动，应该需要的是 const_iterator （即模仿一个 const T* 指针）。 const 成员函数成员函数是 const 意味着什么（怎么听起来这么哲♂学呢）？ const 实施于成员函数是为了确认该成员函数可作用于 const 对象，使得“操作 const 对象”成为可能。 书中提及的两个概念 bitwise constness 和 logical constness（这两个名词是我之前没有听说过的，不知道其他人的情况，但有关内容我是了解的，姑且在此整理一番） bitwise constness 此阵营认为：成员函数只有在不更改对象的任何成员变量（static 除外）时才可说是 const。这正是 C++ 对常量性（constness）的定义，因此 const 成员函数不可以更改对象内任何 non-static 成员变量。 不幸的是许多成员函数虽不完全具备 const 性质却能通过 bitwise 测试，更具体地说，一个更改了 “指针所有物” 的成员函数虽然不能算是 const，但如果只有指针（而非其所指物）隶属于对象，那么称此函数为 bitwise constness 不会引发编译器异议。套用书中例子： 123456789101112131415class CTextBlock&#123;public: ... // bitwise const 声明，但不恰当 char&amp; operator [] (std::size_t pos) const &#123; return pText[pos]; &#125;private: char* pText;&#125;;// ===================================const CTextBlock cctb("Hello"); // 声明常量对象char* pc = &amp;cctb[0]; // 调用 const operator[] 取得一个指针*pc = 'J'; 上述代码尽管创建了一个常量对象并设以某值，而且只对它调用 const 成员函数，但终究还是改变了它的值。 logical constness 此阵营认为：一个 const 成员函数可以修改其所处理对象内的某些 bit ，但只有在客户端侦测不出的情况下才得如此。 若数据被修改对 const 对象而言虽可接受，而编译器不同意，但却想要坚持 bitwise constness，可以通过关键字 mutable 释放掉 non-static 成员变量的 bitwise constness 约束。更通俗点说，在一个成员函数内不能改变 non-static 数据成员的值，而将数据成员加上 mutable，就能做到改变。 在 const 和 non-const 成员函数中避免重复套用书中的 重载下标运算符 [] 的例子。 若一个类包含下标运算符，通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并返回常量引用。当该下标运算符作用于常量对象时，会对应调用返回常量引用的那个重载运算符函数以确保不会给返回的对象赋值。 但一般来说重载下标运算符函数内的代码不多，我平常也就直接 Ctrl-C 和 Ctrl-V 一下，但如果像书中的例子，重载运算符 [] 的函数内还存在许多其他操作，那么适量地复用代码就显然可以缩短编译时间，减少代码膨胀等带来的维护难问题。 复用代码前：1234567891011121314151617181920212223// 此处为了代码紧凑，直接将函数内容写在了类内，请忽略此处可能形成的 超长隐式的 `inline` 函数问题// 虽说好的编译器会帮助你优化这点（逃class TextBlock&#123;public: ... const char&amp; operator [] (std::size_t pos) const &#123; ... // 边界检查（bound checking） ... // 记录数据访问（log access data） ... // 检验数据完整性（verify data integrity） return text[pos]; &#125; char&amp; operator [] (std::size_t pos) &#123; ... // 边界检查（bound checking） ... // 记录数据访问（log access data） ... // 检验数据完整性（verify data integrity） return text[pos]; &#125;private: std::string text;&#125;; 复用代码后：1234567891011121314151617181920class TextBlock&#123;public: ... const char&amp; operator [] (std::size_t pos) const &#123; ... // 边界检查（bound checking） ... // 记录数据访问（log access data） ... // 检验数据完整性（verify data integrity） return text[pos]; &#125; char&amp; operator [] (std::size_t pos) &#123; return const_cast&lt;char&amp;&gt;( // 将operator[]返回值的const转除 static_cast&lt;const TextBlock&amp;&gt;(*this) // 为 *this 加上 const [pos] // 调用 const operator[] ); &#125;...&#125;; 一般而言，转型（casting）的确不是个好选择，但显然代码重复也不是什么好鸟【那些为了可读性的代码重复除外】。 上述例子中，const 版本已经完全做掉了 non-const 版本的任务，唯一不同是其返回类型多了 const 修饰，在这种情况下将返回值的 const 转除并以此实现 non-const 版本是安全的，因为不论谁调用 non-const operator [] 都一定要先有个 non-const 对象，否则显然不能调用 non-const 函数。【可以反过来思考下令 const 版本调用 non-const 版本的可能性，下面会进行解释说明】 non-const operator [] 内部若直接单纯调用 operator []，会递归调用自己，所以显然必须明确指出调用的是 const operator []。 这里用了两次转型： 第一次：用来为 *this 添加 const （使接下来调用 operator [] 时得以调用 const），将 *this 从其原始类型 TextBlock&amp; 强制转型为 const TextBlock&amp;，将 non-const 对象强制转型为 const 对象，使用 static_cast。 第二次：是从 const operator [] 的返回值中移除 const，移除 const 的转型动作在 C++ 中只能通过 const_cast 完成。 虽然这样的语法形式会比较难看，但是这种技术还是值得了解的。而更应该值得了解的是 不应该去做其反向做法（令 const 版本调用 non-const 版本），因为 const 成员函数承诺绝不改变其对象的逻辑状态（改成 non-const 属于改变逻辑状态），而 non-const 成员函数则没有这般承诺，它本来就可以对其对象做任何动作，所以在其中调用一个 const 成员函数并不会带来风险。 请记住 将某些东西声明为 const 可帮助编译器侦测出错误用法。const 可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。 【这条感觉特别玄学…】编译器强制实施 bitwise constness，但编写程序时应该使用 “概念上的常量性” （conceptual constness）。 当 const 和 non-const 成员函数有着实质等价的实现时，令 non-const 版本调用 const 版本可避免代码重复。 Item 4 : 确定对象被使用前已先初始化 Make sure that objects are initialized before they’re used 显然读取未初始化的值会导致不明确的行为，而 C++ 中关于对象初始化何时发生的规则很复杂，所以最佳的处理办法便是：永远在使用对象之前先将它初始化。 初始化的常见部分 对于无任何成员的内置类型，必须手工完成此事。例如 int x = 0; 对于内置类型外的任何其他东西，初始化的责任在于构造函数，即确保每一个构造函数都将对象的每一个成员初始化。 注意： 不要混淆赋值（assignment）和初始化（initialization），C++ 规定对象的成员变量的初始化动作发生在进入构造函数本体之前，较佳做法便是 使用成员初始化列表（member initialization list），其实成员初始化列表的本质是做 copy 构造。 对大多数类型而言，比起先调用 default 构造函数再调用 copy assignment 操作符，单只调用一次 copy 构造函数显然是更高效的。而对于内置型对象来说，其初始化和赋值成本相同，但为了强迫症的一致性（还有一些内置型对象必须被初始化的缘故，例如对象是 const 或 reference），所以最好也是最简单的做法就是：总是使用成员初始化列表来初始化。 相比 C++ 对象初始化何时发生的情况，C++ 的成员初始化次序就显得十分固定而简单了：base classes 更早于其 derived classes 被初始化，而 class 的成员变量总是以其声明的次序被初始化，所以当在成员初始化列表中列出各个成员时，最好总是以其在 class 中的声明次序为次序。【虽说不按次序也是合法的，但有可能会发生一些稀奇古怪的错误，你自己决定吧→_→】 初始化的特殊部分好，现在初始化部分就只剩最后一件事需要关心了，这样看条理是不是比较清晰…【也可能不清晰？ 不同编译单元内定义的 non-local static 对象的初始化，说实话，我之前根本没有想过这部分与一般初始化的区别，所以整理的不好别见怪。【还好这里书中用到的解决办法是大多数人熟悉的一种设计模式–单例模式（Singleton 模式） 函数内的 static 对象称为 local static 对象，其他 static 对象称为 non-local static 对象，而编译单元（translation unit）是指产出单一目标文件的那些源码。 这里的问题是涉及至少两个源码文件，每一个内含至少一个 non-local static 对象。因为 C++ 对 “定义在不同编译单元内的 non-local static 对象” 的初始化次序并无明确定义， 所以可能出现一种情况：某个编译单元内的某个 non-local static 对象的初始化使用了另一个编译单元内的某个 non-local static 对象，而被使用到的这个对象可能尚未被初始化。 可能你会要问 C++ 对此没有明确定义的原因，书中给出了：那就是决定其初始化次序相当困难，甚至根本无解。最常见的形式：多个编译单元的 non-local static 对象经由“模板隐式实例化（implicit template instantiation）” 形成，而后者自己可能也是经由“模板隐式实例化”形成的，不但不可能决定正确的初始化次序，甚至往往不值得去做。 套用书中的实例123456789101112131415161718192021class FileSystem // 你的程序库&#123;public: ... std::size_t numDisks() const; ...&#125;;extern FileSystem tfs;class Directory // 由程序库客户建立&#123;public: Directory( params ); ...&#125;;Directory::Directory( params )&#123; ... std::size_t disks = tfs.numDisks(); // 用到了tfs对象 ...&#125; 假设客户决定创建一个 Directory 目录对象用来放置临时文件，即1Directory tempDir( params ); 显然，除非 tfs 在 tempDir 之前被初始化，否则 tempDir 的构造函数会用到尚未初始化的 tfs，而 tfs 和 tempDir 是不同人建立在不同的源码文件上的，即定义于不同编译单元内的 non-local static 对象。 解决办法就像先前提到的，即实现 Singleton 模式：将每个 non-local static 对象搬到自己的专属函数内（该对象在此函数内被声明为 static），这些函数返回一个 reference 指向它所含的对象。也就是使用函数返回的 “指向 static 对象” 的 reference，而不再使用 static 对象本身。12345678910111213141516171819class FileSystem &#123; ... &#125;;FileSystem&amp; tfs() // 这个函数用来替换 tfs 对象&#123; static FileSystem fs; return fs;&#125;class Directory &#123; ... &#125;;Directory::Directory( params )&#123; ... std::size_t disks = tfs().numDisks(); ...&#125;Directory&amp; tempDir() // 这个函数用来替换 tempDir 对象&#123; static Directory td; return td;&#125; 因为 C++ 保证函数内的 local static 对象会在“该函数被调用期间”“首次遇上该对象的定义式”时被初始化，所以如果用函数调用（返回一个 reference 指向 local static 对象）替换“直接访问 non-local static 对象”，就能保证获得的那个 reference 将指向一个历经初始化的对象。更棒的是，如果未调用 non-local static 对象的“仿真函数”，就绝不会引发构造和析构的成本。  【这部分仅作了解，毕竟此处重点并不是多线程问题】但从另一个角度说，内含 static 对象的函数在多线程系统中带有不确定性，更具体地说，任何一种 non-const static 对象，不论是 local 或 non-local，在多线程环境下都会有麻烦。解决此麻烦的一种做法是：在程序的单线程启动阶段手工调用所有 reference-returning 函数，消除与初始化有关的“竞速形势（race conditions）”。 请记住 为内置型对象进行手工初始化，因为C++不保证初始化它们。 构造函数最好使用成员初始化列表（member initialization list），而不要在构造函数本体内使用赋值操作（assignment）。初始化列表的成员变量，其排列次序应该和它们在 class 中的声明次序相同。 为免除“跨编译单元之初始化次序”问题，请以 local static 对象替换 non-local static 对象。]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Deploy Hexo blog on Github Page]]></title>
    <url>%2F2017%2F01%2F02%2FDeploy-hexo-blog-on-github-page%2F</url>
    <content type="text"><![CDATA[This is a simple tutorial to deploy your hexo blog on Github Page. Deploy Hexo blog on Github PageInstall Node.js and Git Node.js Git 具体情况可见 hexo official document. 之前我本来想配置在archlinux上的，后来发现直接在windows上配置也是行得通的。 Node.js 就直接用 windows 的 Latest LTS version. Git 就直接下个 Git bash. 打开 Git bash， 为本地 Git 配置全局 user 和 email 参数，当然你肯定要有 Github 账户. 12$ git config --global user.name "your github account name"$ git config --global user.email "your github account email" 然后在本地生成 SSH 私钥，并将公钥保存到你的 GitHub 账户中去。 1$ ssh-keygen -t rsa -C "your github account email" 生成过程会有提示要输入，直接一路enter. 进入Github 的 setting 界面，选择 SSH and GPG keys ，点击 New SSH key ，在展开的窗口中填写公钥信息。 title 可以随意起，key 那一栏则是把刚刚生成的 id_rsa.pub 的内容复制进去。最后点击按钮添加。 Install HexoNode.js 在 windows 上的安装默认会直接安装上 npm. 1$ npm install -g hexo-cli 创建并进入 Hexo 目录 1$ mkdir Hexo &amp;&amp; cd Hexo 使用 hexo 生成博客框架 12345$ hexo init blog$ cd blog$ npm install$ hexo generate (or hexo g)$ hexo server (or hexo s) hexo init blog 过程可能比较慢，因为过程中要远程从 github 上下载默认的主题。 通过 hexo server 运行起 hexo 内置的服务器。这时候就可以开始在本地访问了，默认地址为 localhost:4000 . Hexo modules _config.yml ：站点配置文件，可以修改网站的主题、标题、作者等信息。 public ：由 hexo 根据 source 文件夹中的资源进行渲染生成的文件夹，里边存储着最终的静态网页文件。 scaffolds ：模板文件，当要给博客添加新文章的时候，可以根据对应的模板进行创建。 source ：用于存储用户资源，比如文章与新页面等。其中以 _ 开头的文件夹中除了 _posts 文件夹中的 markdown 或 HTML 文件会在执行 generate 操作的时候被渲染添加到 public 文件夹中之外，其他均被忽略。而且在初始化博客的过程中 _posts 目录底会自带一个 hello-world.md 的文件。 themes ：主题文件，自带默认主题 landscape 。 ThemeNexT 主题 下载你喜欢的版本并解压到 themes 目录下，将解压后的文件夹名称改名为 next. 打开 _config.yml （即站点配置文件），找到 theme 字段，将默认主题 landscape 改为 next，通过之前的两条命令重新生成网页文件： 12$ hexo g$ hexo s 应该就可以在本地浏览器看见新主题了。 主题更具体的配置请见 NexT 的官方文档，官方文档写得很有条理，而且里面还有各种第三方服务的配置。 Deploy to Github Page首先要创建一个 new repository，注意仓库名格式必须为 your_github_name.github.io ，这个仓库将作为你的静态博客文件的存放仓库。 12$ cd Hexo/blog$ git clone git@github.com:your_github_name/your_github_name.github.io.git 部署要做的事就是把 public 文件目录下的博客文件都复制到你的本地仓库中，并将本地仓库 push 到 github 仓库上。这样当其他人访问你的博客链接的时候 github 将会自动将该仓库中的相应文件展示出来。 你可以把上面的部署方法写成 shell 脚本一键部署： 12345$ cp -R public/ * your_github_name.github.io/$ cd your_github_name.github.io$ git add .$ git commit -m 'update blog'$ git push 或者使用更方便的方法，即安装 hexo-deployer-git: 1$ npm install hexo-deployer-git --save 修改站点配置文件 _config.yml：123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:your_github_name/your_github_name.github.io.git branch: master 然后执行 1$ hexo deploy (or hexo d) Addtion：为 Github Page 绑定独立域名首先当然要有自己的域名，接着就是域名解析，这类教程网上一抓一大把，这里就不细讲了。 在本地博客的 source 目录下（例如：Hexo/blog/source）创建文件 CNAME （这个文件名一定要大写，并且没有文件后缀名），编辑内容为你的域名，比如我的域名为 koushiro.me ，那么 CNAME 中就填写这个。然后将这个 CNAME 文件放到 source 目录下，执行 hexo g 时会自动加入到 public 目录， 最后执行 hexo d 将 public 目录里的文件 push 到 github 的主页仓库当中。 ps: 我的域名解析是在 DNSPOD 上解析的，只要在域名解析中加上一条记录类型是 CNAME，记录值为 your_github_name.github.io 的记录就可以了。]]></content>
      <tags>
        <tag>tech</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F12%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
