<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Koushiro&#39;s Blog</title>
  
  <subtitle>Tech &amp; Life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://koushiro.me/"/>
  <updated>2018-12-02T09:03:16.096Z</updated>
  <id>http://koushiro.me/</id>
  
  <author>
    <name>koushiro</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rust-trait-Drop</title>
    <link href="http://koushiro.me/2018/10/29/Rust-trait-Drop/"/>
    <id>http://koushiro.me/2018/10/29/Rust-trait-Drop/</id>
    <published>2018-10-29T05:20:01.000Z</published>
    <updated>2018-12-02T09:03:16.096Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Rust" scheme="http://koushiro.me/categories/Rust/"/>
    
    
      <category term="rust" scheme="http://koushiro.me/tags/rust/"/>
    
      <category term="trait" scheme="http://koushiro.me/tags/trait/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm-SkipList</title>
    <link href="http://koushiro.me/2018/10/23/Algorithm-SkipList/"/>
    <id>http://koushiro.me/2018/10/23/Algorithm-SkipList/</id>
    <published>2018-10-23T09:05:16.000Z</published>
    <updated>2018-10-26T14:33:32.192Z</updated>
    
    <content type="html"><![CDATA[<center> An extended data structure based on ordered linked list. </center><a id="more"></a><hr><h1 id="Algorithm-SkipList"><a href="#Algorithm-SkipList" class="headerlink" title="Algorithm-SkipList"></a>Algorithm-SkipList</h1>]]></content>
    
    <summary type="html">
    
      &lt;center&gt; An extended data structure based on ordered linked list. &lt;/center&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Algorithm-Graph</title>
    <link href="http://koushiro.me/2018/10/17/Algorithm-Graph/"/>
    <id>http://koushiro.me/2018/10/17/Algorithm-Graph/</id>
    <published>2018-10-17T12:54:04.000Z</published>
    <updated>2018-10-26T14:28:13.543Z</updated>
    
    <content type="html"><![CDATA[<center> Implementation of common graph algorithm. </center><a id="more"></a><hr><h1 id="Algorithm-Graph"><a href="#Algorithm-Graph" class="headerlink" title="Algorithm-Graph"></a>Algorithm-Graph</h1><p>图结构的常用表示无非<strong>邻接矩阵</strong>（用于稠密图，更直观易懂）和<strong>邻接表</strong>（用于稀疏图，更为常用）。<br>这篇博客里将会使用邻接表结构。</p><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>广度优先搜索通过给定图和一个源点 s 可以生成一棵广度优先搜索树，s 为该树根结点。<br>在该树中从结点 s 到结点 v 的简单路径所对应的就是图中两结点的最短路径。</p><p>实现方式很简单，只需要通过一个先进先出的队列来管理搜索过程中发现的结点（即代码中 <code>status</code> 为 <code>DISCOVERED</code> 的结点）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> Graph = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> VertexStatus &#123; UNDISCOVERED, DISCOVERED, VISITED &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span> &#123;</span></span><br><span class="line">    VertexStatus status;</span><br><span class="line">    pair&lt;<span class="keyword">size_t</span>, <span class="keyword">size_t</span>&gt; time;</span><br><span class="line">    <span class="keyword">size_t</span> parent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">const</span> Graph&amp; G, <span class="built_in">vector</span>&lt;Vertex&gt;&amp; A, <span class="keyword">size_t</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s &gt; G.size()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; A.size(); ++i) &#123;</span><br><span class="line">        A[i] = &#123; UNDISCOVERED, &#123;&#125;, i &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A[s].status = DISCOVERED;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">size_t</span>&gt; Q;</span><br><span class="line">    Q.push(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> u = Q.front();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : G[u]) &#123; <span class="comment">// 处理 u 的邻接表</span></span><br><span class="line">            <span class="keyword">if</span> (A[v].status == UNDISCOVERED) &#123;</span><br><span class="line">                A[v] = &#123; UNDISCOVERED, &#123;&#125;, u &#125;;</span><br><span class="line">                Q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Q.pop();</span><br><span class="line">        A[u].status = VISITED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"BFS:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Graph G1 = &#123;&#123;&#125;, &#123;<span class="number">0</span>, <span class="number">2</span>&#125;, &#123;<span class="number">0</span>, <span class="number">4</span>&#125;, &#123;<span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Vertex&gt; A1(G1.size());</span><br><span class="line">    BFS(G1, A1, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; A1.size(); ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">"-&gt;"</span> &lt;&lt; A1[i].parent &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BFS:</span><br><span class="line">0-&gt;1</span><br><span class="line">1-&gt;1</span><br><span class="line">2-&gt;1</span><br><span class="line">3-&gt;4</span><br><span class="line">4-&gt;2</span><br></pre></td></tr></table></figure><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>不像广度优先搜索，深度优先搜索会形成一个由多棵深度优先树组成的深度优先森林。<br>此外，深度优先搜索在每个结点上记录两个时间戳，即 <code>Vertex</code> 结构体中的 <code>time.first</code> 和 <code>time.second</code>。<br><code>time.first</code> 用于记录该结点被发现的时间，<code>time.second</code> 用于记录该结点搜索完其邻接表的时间。<br>此处具体实现使用了递归。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">depth_first_search</span><span class="params">(<span class="keyword">const</span> Graph&amp; G, <span class="built_in">vector</span>&lt;Vertex&gt;&amp; A, <span class="keyword">size_t</span> u, <span class="keyword">size_t</span>&amp; counter)</span> </span>&#123;</span><br><span class="line">    A[u].time.first = counter++;</span><br><span class="line">    A[u].status = DISCOVERED;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : G[u]) &#123;  <span class="comment">// 处理 u 的邻接表</span></span><br><span class="line">        <span class="keyword">if</span> (A[v].status == UNDISCOVERED) &#123;</span><br><span class="line">            A[v].parent = u;</span><br><span class="line">            depth_first_search(G, A, v, counter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[u].time.second = counter++;</span><br><span class="line">    A[u].status = VISITED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">const</span> Graph&amp; G, <span class="built_in">vector</span>&lt;Vertex&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; A.size(); ++i) &#123;</span><br><span class="line">        A[i] = &#123; UNDISCOVERED, &#123;&#125;, i &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> u = <span class="number">0</span>; u &lt; G.size(); ++u) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[u].status == UNDISCOVERED) &#123;</span><br><span class="line">            depth_first_search(G, A, u, counter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"DFS:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Graph G2 = &#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;, &#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">5</span>&#125;, &#123;<span class="number">5</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Vertex&gt; A2(G2.size());</span><br><span class="line">    DFS(G2, A2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; A2.size(); ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; A2[i].time.first &lt;&lt; <span class="string">"/"</span> &lt;&lt; A2[<span class="number">2</span>].time.second &lt;&lt; <span class="string">")"</span></span><br><span class="line">            &lt;&lt;  i &lt;&lt; <span class="string">"-&gt;"</span> &lt;&lt; A2[i].parent &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DFS:</span><br><span class="line">(0/5)0-&gt;0</span><br><span class="line">(1/5)1-&gt;0</span><br><span class="line">(2/5)2-&gt;1</span><br><span class="line">(3/5)3-&gt;2</span><br><span class="line">(8/5)4-&gt;4</span><br><span class="line">(9/5)5-&gt;4</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt; Implementation of common graph algorithm. &lt;/center&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://koushiro.me/categories/Algorithm/"/>
    
    
      <category term="tech" scheme="http://koushiro.me/tags/tech/"/>
    
      <category term="algorithm" scheme="http://koushiro.me/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Rust trait: Clone and Copy</title>
    <link href="http://koushiro.me/2018/09/27/Rust-trait-Clone-and-Copy/"/>
    <id>http://koushiro.me/2018/09/27/Rust-trait-Clone-and-Copy/</id>
    <published>2018-09-27T04:09:31.000Z</published>
    <updated>2018-10-23T13:58:16.153Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Rust" scheme="http://koushiro.me/categories/Rust/"/>
    
    
      <category term="rust" scheme="http://koushiro.me/tags/rust/"/>
    
      <category term="trait" scheme="http://koushiro.me/tags/trait/"/>
    
  </entry>
  
  <entry>
    <title>教各位friend安装ArchLinux</title>
    <link href="http://koushiro.me/2018/08/02/%E6%95%99%E5%90%84%E4%BD%8Dfriend%E5%AE%89%E8%A3%85ArchLinux/"/>
    <id>http://koushiro.me/2018/08/02/教各位friend安装ArchLinux/</id>
    <published>2018-08-02T08:15:19.000Z</published>
    <updated>2018-10-22T14:22:37.538Z</updated>
    
    <content type="html"><![CDATA[<p>最近新买了 ThinkPad X1C，顺便又买了块 SSD （ 东芝 RC100 2242 规格，PCIe/NVMe）来装 ArchlLinux，尽管是咱第二次装 ArchLinux，还是遇到了不少坑，因此根据 ArchWiki 和网上的几篇博客整理了一篇可以让各位 friends 都能上手的安装教程。</p><a id="more"></a><hr><h1 id="教各位friend安装ArchLinux"><a href="#教各位friend安装ArchLinux" class="headerlink" title="教各位friend安装ArchLinux"></a>教各位friend安装ArchLinux</h1><h2 id="制作启动U盘"><a href="#制作启动U盘" class="headerlink" title="制作启动U盘"></a>制作启动U盘</h2><p>由于咱是在 windows 上做的安装介质（也是多数 friends 的情况），所以在此就只针对 windows 系统给出说明，其他平台可以参考 <a href="https://wiki.archlinux.org/index.php/USB_flash_installation_media" target="_blank" rel="noopener">ArchWiki</a>。</p><p>windows 上咱使用 <a href="https://rufus.akeo.ie/?locale=zh_CN/" target="_blank" rel="noopener">rufus</a> 来制作U盘驱动器，rufus也是 ArchLinux 官方推荐的哦。</p><p>当然制作之前要先<a href="https://www.archlinux.org/download/" target="_blank" rel="noopener">下载 archlinux</a>，friend 可以自己选择源来下载，咱是直接用了 <a href="https://mirrors.ustc.edu.cn/archlinux/iso/2018.08.01/" target="_blank" rel="noopener">ustc 源</a> ，rufus 的具体设置如图：</p><p><img src="rufus.png" alt="rufus"></p><p><strong>注意</strong>：目前的引导方式主要分为 <strong>EFI 引导 + GPT 分区表</strong> 与 <strong>BIOS(LEGACY) 引导 + MBR 分区表</strong> 两种，几乎比较新的机器都采用了EFI/GPT引导的方式（也是咱选择的方式）。</p><p>安装U盘制作完成后，插入电脑，调整硬盘的启动顺序从U盘启动 ArchLinux。</p><p>拿咱的 ThinkPad X1C 具体举例，ThinkPad X1C 还需要在 BIOS 里将 Security Boot 选项设置为 Disabled，然后在 Startup 栏把 UEFI/Legacy Boot 选项设置为 Both / UEFI First / Yes。这样才能调整启动顺序从U盘启动 ArchLinux 系统。</p><p>如果 friend 不确定自己的引导方式，U盘启动成功后请在命令提示符下执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /sys/firmware/efi/efivars</span><br></pre></td></tr></table></figure><p>如果提示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls: cannot access <span class="string">'/sys/firmware/efi/efivars'</span>: No such file or directory</span><br></pre></td></tr></table></figure><p>表明 friend 是BIOS方式引导，否则为EFI方式引导。</p><h2 id="硬盘分区和系统挂载"><a href="#硬盘分区和系统挂载" class="headerlink" title="硬盘分区和系统挂载"></a>硬盘分区和系统挂载</h2><p>咱是直接使用 fdisk 命令来进行分区的，fdisk 命令自带有简洁说明，对命令内容还有问题的 friend 可以问问搜索引擎。</p><p>这是咱的分区结果（东芝那块 SSD 就是nvme1n1），总共分了三个 partition，都是 GPT 格式的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/dev/nvme1n1p1  512M        EFI System</span><br><span class="line">/dev/nvme1n1p2  16G         Linux swap</span><br><span class="line">/dev/nvme1n1p3  all left    Linux filesystem     <span class="comment"># 剩余空间都留给根分区</span></span><br></pre></td></tr></table></figure><p>分完区后需要格式化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># EFI</span></span><br><span class="line">mkfs.fat -F32 /dev/nvme1n1p1</span><br><span class="line"><span class="comment"># swap</span></span><br><span class="line">mkswap /dev/nvme1n1p2</span><br><span class="line"><span class="comment"># 根分区</span></span><br><span class="line">mkfs.ext4 /dev/nvme1n1p3</span><br></pre></td></tr></table></figure><p>格式化完分区后需要挂载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先需要挂载根分区</span></span><br><span class="line">mount /dev/nvme1n1p3 /mnt</span><br><span class="line"></span><br><span class="line"><span class="comment"># EFI/GPT引导方式，执行以下命令创建/boot文件夹并将引导分区挂载到上面</span></span><br><span class="line">mkdir -p /mnt/boot</span><br><span class="line">mount /dev/nvme1n1p1 /mnt/boot</span><br><span class="line"></span><br><span class="line"><span class="comment"># swap分区</span></span><br><span class="line">swapon /dev/nvme1n1p2</span><br></pre></td></tr></table></figure><p>执行 <code>lsblk</code> 看看是否都挂载成功。</p><h2 id="选择镜像"><a href="#选择镜像" class="headerlink" title="选择镜像"></a>选择镜像</h2><p>备份一份 mirrorlist， 并修改 mirrorlist，只留下China的镜像源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.backup</span><br><span class="line">vim /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure><h2 id="安装基本系统"><a href="#安装基本系统" class="headerlink" title="安装基本系统"></a>安装基本系统</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacstrap -i /mnt base base-devel</span><br></pre></td></tr></table></figure><h2 id="配置Fstab"><a href="#配置Fstab" class="headerlink" title="配置Fstab"></a>配置Fstab</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</span><br><span class="line">cat /mnt/etc/fstab</span><br></pre></td></tr></table></figure><p>强烈建议 在执行完以上命令后，后检查一下生成的 <code>/mnt/etc/fstab</code> 文件是否正确。</p><h2 id="Chroot-Change-root"><a href="#Chroot-Change-root" class="headerlink" title="Chroot (Change root)"></a>Chroot (Change root)</h2><p>chroot 命令相当于把操纵权交给新安装（或已经存在）的Linux系统。<br>之前的所有操作都是在U盘里的，而执行了这步以后，操作都相当于在磁盘上新装的系统中进行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot /mnt</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>: 如果以后系统出现了问题，只要插入U盘并启动，将系统根分区挂载到了/mnt下（如果有其他分区也要之前那样挂载到相应目录下），再通过这条命令就可以进入系统进行修复操作。</p></blockquote><h2 id="设置时区"><a href="#设置时区" class="headerlink" title="设置时区"></a>设置时区</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">hwclock --systohc</span><br><span class="line">date</span><br></pre></td></tr></table></figure><p><code>date</code> 命令用于查看时间，如果时间有问题， friend 可以直接手动设置时间并同步到硬件时钟里：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">date -s MM/DD/YYYY</span><br><span class="line">date -s HH:MM:SS</span><br><span class="line">hwclock --systohc</span><br></pre></td></tr></table></figure><h2 id="连接网络"><a href="#连接网络" class="headerlink" title="连接网络"></a>连接网络</h2><p>ArchLinux 并不能离线安装，因此需要联网来下载需要的组件。</p><ul><li><p>有线网并且路由器支持DHCP的话插上网线后先执行以下命令获取IP地址：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dhcpcd</span><br></pre></td></tr></table></figure></li><li><p>由于咱是笔记本也没网线，就使用无线网：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wifi-menu</span><br></pre></td></tr></table></figure></li></ul><p>连上之后测试下网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 3 www.baidu.com</span><br></pre></td></tr></table></figure><h2 id="提前安装必须软件包"><a href="#提前安装必须软件包" class="headerlink" title="提前安装必须软件包"></a>提前安装必须软件包</h2><p>Chroot 到了新的系统中，只有一些最基本的包（组件），特别是 wifi-menu 是需要下面其中一些包的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S vim dialog wpa_supplicant ntfs-3g networkmanager</span><br></pre></td></tr></table></figure><h2 id="设置Locale"><a href="#设置Locale" class="headerlink" title="设置Locale"></a>设置Locale</h2><p><code>/etc/locale.gen</code> 是一个仅包含注释文档的文本文件。<br>指定 friend 需要的本地化类型，只需移除对应行前面的注释符号（＃）即可，建议选择 UTF-8的项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/locale.gen</span><br></pre></td></tr></table></figure><p>咱的话只要英文和简体中文</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">en_US.UTF-8 UTF-8</span><br><span class="line">zh_CN.UTF-8 UTF-8</span><br></pre></td></tr></table></figure><p>接着执行 <code>locale-gen</code> 以生成 <code>locale</code> 讯息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locale-gen</span><br></pre></td></tr></table></figure><p><code>/etc/locale.gen</code> 会生成指定的本地化文件.</p><p>打开（不存在时会创建）/etc/locale.conf文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/locale.conf</span><br></pre></td></tr></table></figure><p>在文件的第一行加入以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LANG=en_US.UTF-8</span><br></pre></td></tr></table></figure><p><strong>警告</strong>: 不推荐在此设置任何中文locale，或导致tty乱码。</p><h2 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h2><p>打开（不存在时会创建）/etc/hostname文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hostname</span><br></pre></td></tr></table></figure><p>在文件的第一行输入 friend 自己设定的一个 hostname，咱用的是tp-arch，保存并退出。</p><p>编辑/etc/hosts文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure><p>作如下修改（将 tp-arch 替换成 friend 自己设定的主机名）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1   localhost.localdomain   localhost</span><br><span class="line">::1         localhost.localdomain   localhost</span><br><span class="line">127.0.1.1   tp-arch.localdomain     tp-arch</span><br></pre></td></tr></table></figure><h2 id="设置-root-密码"><a href="#设置-root-密码" class="headerlink" title="设置 root 密码"></a>设置 root 密码</h2><p>执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure><p>按提示设置并确认就可以了。</p><h2 id="安装Intel-ucode（非IntelCPU可以跳过此步骤）"><a href="#安装Intel-ucode（非IntelCPU可以跳过此步骤）" class="headerlink" title="安装Intel-ucode（非IntelCPU可以跳过此步骤）"></a>安装Intel-ucode（非IntelCPU可以跳过此步骤）</h2><p>直接pacman安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S intel-ucode</span><br></pre></td></tr></table></figure><p>安装Bootloader, 这里咱安装最流行的Grub2。<br>首先安装os-prober这个包，它可以配合Grub检测已经存在的系统，自动设置启动选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S os-prober</span><br></pre></td></tr></table></figure><h2 id="安装引导程序"><a href="#安装引导程序" class="headerlink" title="安装引导程序"></a>安装引导程序</h2><p>由于咱的电脑是EFI/GPT引导方式，所以安装 <code>grub</code> 与 <code>efibootmgr</code> 两个包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S grub efibootmgr</span><br></pre></td></tr></table></figure><p>部署grub：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=grub</span><br></pre></td></tr></table></figure><p>生成配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><p>如果 friend 发现错误，请仔细检查是否正确完成上面的过程。</p><p>如果报 <code>warning failed to connect to lvmetad，falling back to device scanning.</code> 错误，简单的方法是编辑 <code>/etc/lvm/lvm.conf</code> 这个文件，搜索到 <code>use_lvmetad = 1</code> 将 <code>1</code> 修改为 <code>0</code>，保存，再重新配置 <code>grub</code> 即可。</p><h2 id="安装后检查"><a href="#安装后检查" class="headerlink" title="安装后检查"></a>安装后检查</h2><p>如果 friend 是多系统（咱是在一块全新 SSD 上装的 ArchLinux），请注意上面一节中对 <code>os-prober</code> 这个包的安装。</p><p>强烈建议使用如下命令检查是否成功生成各系统的入口，如果没有正常生成会出现开机没有系统入口的情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><p>检查接近末尾的 <code>menuentry</code> 部分是否有 windows 或其他系统名入口。</p><p>由于咱是新的 SSD 所以没有这种烦恼。</p><h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2><p>输入 exit 或按 Ctrl+D 退出 chroot 环境。<br>最后，通过执行 reboot 重启系统，systemd 将自动卸载仍然挂载的任何分区。<br>注意这个时候 friend 可能会卡在有两行提示的地方无法正常关机，长按电源键强制关机即可，没有影响。<br>关机后拔出U盘，调整硬盘启动顺序，如果一切顺利就能进入系统，然后使用 root 帐户登录到新系统。</p><p>好了，是成功安装了 ArchLinux 的 friend了！</p><hr><h2 id="安装完-ArchLinux-后的基础配置"><a href="#安装完-ArchLinux-后的基础配置" class="headerlink" title="安装完 ArchLinux 后的基础配置"></a>安装完 ArchLinux 后的基础配置</h2><h3 id="还是要连接网络"><a href="#还是要连接网络" class="headerlink" title="还是要连接网络"></a>还是要连接网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有线网并且路由器支持DHCP的话插上网线后先执行以下命令获取IP地址</span></span><br><span class="line">dhcpcd</span><br><span class="line"><span class="comment"># 无线网, 进入 wifi-menu 按界面提示进行操作</span></span><br><span class="line">wifi-menu</span><br></pre></td></tr></table></figure><p>同样可以使用ping命令来测试是否正常联网。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 3 www.baidu.com</span><br></pre></td></tr></table></figure><h3 id="新建用户和用户组"><a href="#新建用户和用户组" class="headerlink" title="新建用户和用户组"></a>新建用户和用户组</h3><p>创建一个名为 <code>xxx</code> 的用户（<code>xxx</code> 为 friend 自己的用户名），并使用 <code>zsh</code> 作默认 <code>shell</code>。<br>在此之前，请不要忘记安装zsh：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman -S zsh</span><br><span class="line">useradd -m -g users -G wheel -s /bin/zsh xxx</span><br></pre></td></tr></table></figure><p>并为所创建用户 <code>xxx</code> 设定密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd xxx</span><br></pre></td></tr></table></figure><h3 id="权限提升，配置sudo"><a href="#权限提升，配置sudo" class="headerlink" title="权限提升，配置sudo"></a>权限提升，配置sudo</h3><p>sudo本身也是一个软件包，所以咱需要通过pacman来安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S sudo</span><br></pre></td></tr></table></figure><p>用专门的 <code>visudo</code> 命令来编辑 <code>sudo</code> 的配置文件，使用 <code>visudo</code> 是为了对编辑后的文件进行检查防止格式的错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visudo  <span class="comment"># 实际上就是 vim 的操作</span></span><br></pre></td></tr></table></figure><p>找到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%wheel ALL=(ALL)ALL</span><br></pre></td></tr></table></figure><p>这行，去掉之前的 <code>#</code> 注释符，保存并退出就可以了。</p><p>这里的 <code>%wheel</code> 就是代表 <code>wheel</code> 用户组，意味着 <code>wheel</code> 用户组中的所有用户都可以使用 <code>sudo</code> 命令。当然为了安全使用 <code>sudo</code> 命令，<code>wheel</code> 用户组中的所有用户还是需要输入当前用户的密码来进行提权操作。</p><p>配置好 <code>sudo</code> 以后，咱进行一次重启，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><p>重启以后输入 friend 刚创建的用户名与密码来登录。注意登录后还是要重新进行联网操作。</p><hr><h2 id="图形界面安装"><a href="#图形界面安装" class="headerlink" title="图形界面安装"></a>图形界面安装</h2><h3 id="显卡驱动"><a href="#显卡驱动" class="headerlink" title="显卡驱动"></a>显卡驱动</h3><p>咱的电脑是intel的集成显卡（绝大多数人的情况，其他情况请看 <a href="https://wiki.archlinux.org/index.php/Xorg" target="_blank" rel="noopener">ArchWiki</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S xf86-video-intel</span><br></pre></td></tr></table></figure><p>安装 Xorg 及相关组件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S xorg</span><br></pre></td></tr></table></figure><h3 id="安装桌面环境"><a href="#安装桌面环境" class="headerlink" title="安装桌面环境"></a>安装桌面环境</h3><p>Linux下有很多著名的桌面环境如Xfce、KDE(Plasma)、Gnome、Unity、Deepin等等，它们的外观、操作、设计理念等各方面都有所不同， 在它们之间的比较与选择网上有很多的资料可以去查。</p><p>咱本人只用过 <code>Gnome</code> 和 <code>Deepin</code> 的，也正打算用用 <code>i3wm</code>。<br>当然 friend 可以把它们全部装上换着用……因为 <code>Linux</code> 的模块化，这样完全没有问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gnome桌面和 gnome 组件</span></span><br><span class="line">pacman -S gnome gnome-extra</span><br><span class="line"><span class="comment">#然后安装gdm登录管理器</span></span><br><span class="line">pacman -S gdm</span><br><span class="line"><span class="comment"># 将gdm设置为开机自启动，这样开机时会自动载入桌面</span></span><br><span class="line">systemctl <span class="built_in">enable</span> gdm</span><br></pre></td></tr></table></figure><h3 id="提前配置网络"><a href="#提前配置网络" class="headerlink" title="提前配置网络"></a>提前配置网络</h3><p>到现在已经安装好了桌面环境，但是还有一件事情需要提前设置一下。<br>由于之前使用的一直都是 <code>netctl</code> 这个自带的网络服务，而桌面环境使用的是 <code>NetworkManager</code> 这个网络服务，所以需要禁用 <code>netctl</code> 并启用NetworkManager：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">disable</span> netctl</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> NetworkManager <span class="comment">#注意大小写</span></span><br></pre></td></tr></table></figure><p>重新启动后，如果 friend 看到桌面管理器的界面，选择 friend 需要的桌面环境并输入用户名与密码登陆后，就能看到 <code>Gnome</code> 桌面了。</p><p>好了，是能用桌面系统的 friend 了。</p><hr><h2 id="推荐的包"><a href="#推荐的包" class="headerlink" title="推荐的包"></a>推荐的包</h2><h3 id="yaourt"><a href="#yaourt" class="headerlink" title="yaourt"></a>yaourt</h3><p>最简单安装 Yaourt 的方式是添加 Yaourt 源至 friend 的 /etc/pacman.conf，在文件最后加入:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line"><span class="comment">#The Chinese Arch Linux communities packages.</span></span><br><span class="line">SigLevel = Optional TrustAll</span><br><span class="line">Server   = https://mirrors.ustc.edu.cn/archlinuxcn/<span class="variable">$arch</span></span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Syu yaourt</span><br></pre></td></tr></table></figure><h3 id="中文字体与中文输入法"><a href="#中文字体与中文输入法" class="headerlink" title="中文字体与中文输入法"></a>中文字体与中文输入法</h3><h4 id="Fcitx-简体中文"><a href="#Fcitx-简体中文" class="headerlink" title="Fcitx (简体中文))"></a><a href="https://wiki.archlinux.org/index.php/Fcitx_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">Fcitx (简体中文)</a>)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S wqy-microhei</span><br></pre></td></tr></table></figure><p>记得在 Gnome Settings - Region &amp; Language - Input Sources 选项中加入中文.</p><h4 id="fcitx-输入法"><a href="#fcitx-输入法" class="headerlink" title="fcitx 输入法"></a>fcitx 输入法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx-im fcitx-configtool</span><br></pre></td></tr></table></figure><p>使用 fcitx 之前，friend 必须先进行一些环境设定。<br>如果 friend 采用 KDM、GDM、LightDM 等显示管理器，请在~/.xprofile (没有则新建一个)中加入如下3行，<br>如果 friend 采用 startx 或者 Slim 启动 （即使用.xinitrc的场合），则在 ~/.xinitrc 中加入，<br>如果 friend 使用的是较新版本的GNOME，使用 Wayland 显示管理器，则请在/etc/environment中加入：`</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> XMODIFIERS=@im=fcitx</span><br><span class="line"><span class="built_in">export</span> GTK_IM_MODULE=fcitx</span><br><span class="line"><span class="built_in">export</span> QT_IM_MODULE=fcitx</span><br></pre></td></tr></table></figure><p>重新登录后让环境变量生效。</p><p><code>fcitx-diagnose</code> 命令通常能告诉 friend： 有关 <code>fcitx</code> 的配置是否有问题。</p><h4 id="安装中文输入法（咱装的是sogoupinyin）"><a href="#安装中文输入法（咱装的是sogoupinyin）" class="headerlink" title="安装中文输入法（咱装的是sogoupinyin）"></a>安装中文输入法（咱装的是sogoupinyin）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx-sogoupinyin</span><br></pre></td></tr></table></figure><p>打开配置工具 <code>fcitx-configtool</code> 添加中文输入法。<br>对于新安装的英文系统，要取消只显示当前语言的输入法（Only Show Current Language），才能看到和添加中文输入法(Pinyin, SogouPinyin等)。</p><p>输入法部分常用默认快捷键：</p><ul><li>Ctrl + Space 激活输入法</li><li>左Shift 临时切换到英文</li><li>Ctrl + Shift 输入法间切换</li></ul><h3 id="浏览器-Google-Chrome-or-Firefox"><a href="#浏览器-Google-Chrome-or-Firefox" class="headerlink" title="浏览器 Google Chrome or Firefox"></a>浏览器 Google Chrome or Firefox</h3><p>前面已经加入了archlinuxcn，这里只要</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S google-chrome</span><br><span class="line">sudo pacman -S firefox</span><br></pre></td></tr></table></figure><h3 id="oh-my-zsh-配置"><a href="#oh-my-zsh-配置" class="headerlink" title="oh-my-zsh 配置"></a>oh-my-zsh 配置</h3><p>前提是已经装了 <code>zsh</code>，并切换了当前的 <code>shell</code> 到 <code>zsh</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S git</span><br><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></table></figure><h3 id="图标包和主题"><a href="#图标包和主题" class="headerlink" title="图标包和主题"></a>图标包和主题</h3><ul><li><p>图标包</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yaourt -S numix-circle-icon-theme-git</span><br></pre></td></tr></table></figure></li><li><p>主题</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yauort -S adapta-gtk-theme</span><br></pre></td></tr></table></figure></li></ul><p>再到 <code>tweak-tool</code> 里设置就行了，friend 当然也可以选择其他图标包和主题啦。</p><h3 id="ShadowsocksR-客户端"><a href="#ShadowsocksR-客户端" class="headerlink" title="ShadowsocksR 客户端"></a>ShadowsocksR 客户端</h3><p>这里是用的 python 版本的，其他版本请移步 <a href="https://github.com/shadowsocksr-backup" target="_blank" rel="noopener">github</a>。<br>当然使用客户端的前提是已经部署了服务端，相信爱折腾的 friend 应该早已经做啦。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/shadowsocksr-backup/shadowsocksr.git</span><br><span class="line"><span class="built_in">cd</span> shadowsocksr</span><br><span class="line">git checkout -b manyuser origin/manyuser</span><br><span class="line">vim config.json <span class="comment">#修改成自己的配置，或者拷贝一份config.json用于修改成自己的配置</span></span><br><span class="line"><span class="built_in">cd</span> shadowsocks</span><br><span class="line">sudo python local.py -c ../config.json -d start</span><br></pre></td></tr></table></figure><blockquote><p>当然除了 ShadowsocksR 之外还有其他工具，比如 <a href="https://github.com/shadowsocks" target="_blank" rel="noopener">Shadowsocks</a>，<a href="https://github.com/v2ray" target="_blank" rel="noopener">v2ray</a>，就看 friend 哪个用的顺手啦</p></blockquote><h3 id="SwitchyOmega-浏览器插件"><a href="#SwitchyOmega-浏览器插件" class="headerlink" title="SwitchyOmega 浏览器插件"></a><a href="https://github.com/FelisCatus/SwitchyOmega/releases" target="_blank" rel="noopener">SwitchyOmega 浏览器插件</a></h3><p>链接里 chrome 和 firecfox 的版本都有</p><p>这里就讲一下在 chrome 上的安装吧。下载完 <code>SwitchyOmega-xxx.crx</code> 文件， 把后缀名改成 <code>.zip</code> 再解压得到需要的文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S unzip</span><br><span class="line"><span class="built_in">cd</span> Downloads</span><br><span class="line">mv SwitchyOmega-xxx.crx SwitchyOmega-xxx.zip</span><br><span class="line">unzip SwitchyOmega-xxx.zip -d ./SwitchyOmega</span><br></pre></td></tr></table></figure><p>然后在 chrome 的扩展界面打开开发者模式，导入这个文件夹。</p><p>SwitchyOmega 的配置也很简单，打开该插件的选项。</p><p>Profiles - proxy:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#   Protocol    Server      Port</span></span><br><span class="line">    SOCKS5      127.0.0.1   1080</span><br></pre></td></tr></table></figure><p>Profiles - auto switch:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#   Condition           Profile</span></span><br><span class="line">    Rule list rules     proxy</span><br><span class="line">    Default             Direct</span><br></pre></td></tr></table></figure><p>Rule list config:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rule List Format - AutoProxy</span><br><span class="line">Rule List URL - https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</span><br><span class="line">Download Profile Now</span><br></pre></td></tr></table></figure><p>最后别忘了保存选项哦。</p><p>好了，是能用浏览器连上股♂沟的 friend 了。</p><h2 id="Friend-还能用-yaourt-装其他各种各样的包哦"><a href="#Friend-还能用-yaourt-装其他各种各样的包哦" class="headerlink" title="Friend 还能用 yaourt 装其他各种各样的包哦"></a>Friend 还能用 yaourt 装其他各种各样的包哦</h2><p>好用得呀匹</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://wiki.archlinux.org/index.php/Installation_guide_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">ArchWiki</a>)</p><p><a href="https://www.viseator.com/2017/05/17/arch_install/" target="_blank" rel="noopener">以官方Wiki的方式安装ArchLinux</a></p><p><a href="https://coolrc.me/2015/12/04/04231804/" target="_blank" rel="noopener">Achlinux安装教程及美化教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近新买了 ThinkPad X1C，顺便又买了块 SSD （ 东芝 RC100 2242 规格，PCIe/NVMe）来装 ArchlLinux，尽管是咱第二次装 ArchLinux，还是遇到了不少坑，因此根据 ArchWiki 和网上的几篇博客整理了一篇可以让各位 friends 都能上手的安装教程。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://koushiro.me/categories/Linux/"/>
    
    
      <category term="tech" scheme="http://koushiro.me/tags/tech/"/>
    
      <category term="config" scheme="http://koushiro.me/tags/config/"/>
    
      <category term="Linux" scheme="http://koushiro.me/tags/Linux/"/>
    
      <category term="ArchLinux" scheme="http://koushiro.me/tags/ArchLinux/"/>
    
  </entry>
  
  <entry>
    <title>Customizing new and delete in C++</title>
    <link href="http://koushiro.me/2018/07/18/Customizing-new-and-delete-in-Cpp/"/>
    <id>http://koushiro.me/2018/07/18/Customizing-new-and-delete-in-Cpp/</id>
    <published>2018-07-18T06:00:07.000Z</published>
    <updated>2018-09-22T17:57:30.353Z</updated>
    
    <content type="html"><![CDATA[<p>这部分主要涉及 <code>new</code> 和 <code>delete</code> 这两个 keyword，它们的一些高级用法在课堂上或者一些 C++ 初学者书籍中很难见到，对于编码者也很少用到这部分内容，当然我对此也不是了解得特别透彻，文中如有错误，请在评论指出。</p><a id="more"></a><p>既然标题是 <code>Customizing new and delete</code>，那么定制 <code>new</code> 和 <code>delete</code>（或者说重载 <code>new</code> 和 <code>delete</code>）用在哪些时候呢？<br>某些应用程序对内存分配有特殊需求，因此无法将标准内存管理机制直接应用于此类程序，它们常常需要自定义内存分配的细节，比如使用关键字 <code>new</code> 将对象分配放置在特定的内存空间中。为此，应用程序需要重载 <code>new</code> 运算符和 <code>delete</code> 运算符以控制内存分配的过程。</p><p>实际上重载<code>new</code>运算符（<code>new operator</code>）和<code>delete</code>运算符（<code>delete operator</code>）这种说法并不严谨，因为重载这两个运算符与重载其他运算符的过程有着较大的不同。</p><p>为了讲清原因，需要在此之前了解 <code>new operator</code>/<code>operator new</code>和<code>delete operator</code> / <code>operator delete</code>的概念。这几个概念从名字上可能会有点绕，但是说明白了其实也是挺简单的。（函数 <code>new-handler</code> 也会被提到，这是当无法满足用户的内存需求时所调用的函数）</p><h1 id="new-operator-new-expression"><a href="#new-operator-new-expression" class="headerlink" title="new operator (new expression)"></a>new operator (new expression)</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *pStr = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Hello"</span>);</span><br></pre></td></tr></table></figure><p>此处使用的 <code>new</code> 即是 <code>new operator</code>，也就是常用的用法。<br>这个操作符是由C++语言内建的，就像 <code>sizeof</code> 那样，不能被改变意义，总是做相同的工作：</p><ol><li><p>调用名为 <code>operator new</code> 的标准库函数，分配一块足够大的、原始的、未命名的内存空间用来放置某类型的对象。</p></li><li><p>调用一个该对象类型的 <code>constructor</code>，为刚才分配的内存中的那个对象设定初始值。</p></li><li><p>对象被分配了空间并构造完成，返回一个指向该对象的指针，即如上述例子中的 <code>pStr</code>。</p></li></ol><p>编译器内部产生的代码可能就像下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配原始内存用来放置一个 string 对象</span></span><br><span class="line"><span class="keyword">void</span>* rawMemory = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(<span class="built_in">string</span>));</span><br><span class="line"><span class="comment">// 将内存中的对象初始化</span></span><br><span class="line">call <span class="built_in">string</span>::<span class="built_in">string</span>(<span class="string">"Hello"</span>) on *rawMemory;</span><br><span class="line"><span class="comment">// 让 pStr 指向新完成的对象</span></span><br><span class="line"><span class="built_in">string</span> *pStr = <span class="keyword">static_cast</span>&lt;<span class="built_in">string</span>*&gt;(rawMemory);</span><br></pre></td></tr></table></figure><h2 id="operator-new"><a href="#operator-new" class="headerlink" title="operator new"></a>operator new</h2><p>没错，如上所说，<code>operator new</code> 其实指的是一个标准库函数，它的默认版本定义（伪代码）如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="comment">// 处理 0-byte 申请，将它视为 1-byte 申请， </span></span><br><span class="line">    <span class="comment">// C++规定请求 0-byte operator new也得返回一个合法指针</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)  </span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        尝试分配 size bytes;</span><br><span class="line">        <span class="keyword">if</span> (分配成功)</span><br><span class="line">            <span class="keyword">return</span> (一个指针，指向分配得来的内存)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配失败：找出目前的 new-handling 函数</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * C++11标准以前之所以将 new-handling 函数指针设为 null 后又立刻恢复原样</span></span><br><span class="line"><span class="comment">         * 是因为没有任何办法可以直接获取 new-handling 函数指针，</span></span><br><span class="line"><span class="comment">         * 必须要调用 set_new_handler 找出它，set_new_handler</span></span><br><span class="line"><span class="comment">         * takes a replacement handler as the argument,</span></span><br><span class="line"><span class="comment">         * returns the previous handler.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 而 C++11 标准有 get_new_handler(),</span></span><br><span class="line"><span class="comment">         * it returns the currently installed new-handler,</span></span><br><span class="line"><span class="comment">         * which may be a null pointer.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">#<span class="keyword">if</span> __cplusplus &gt;= <span class="number">201103L</span></span><br><span class="line">        new_handler globalHandler = get_new_handler();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        new_handler globalHandler = set_new_handler(<span class="number">0</span>);</span><br><span class="line">        set_new_handler(globalHandler);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 new_handler 函数解决内存不足时的情况，</span></span><br><span class="line">        <span class="comment">// 只有当指向 new_handling 函数的指针是 null，operator new 才会抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (globalHandler) (*globalHandler)();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">std</span>::bad_alloc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数分配内存成功时返回一个 <code>void</code> 指针，指向一块原始的、未设定初值的内存，分配内存失败时抛出 <code>bad_alloc</code> 异常。函数中的 <code>size_t</code> 参数用于指定需要分配多少内存，可以将 <code>operator new</code> 函数重载，加上额外的参数，但第一参数的类型必须总是 <code>size_t</code>。<br>总而言之， <code>operator new</code> 函数和 <code>malloc</code> 函数一样，它的 <strong>唯一任务就是分配内存</strong>。</p><p>所以开头之所以说重载 <code>new operator</code> 并不严谨，是因为真正能重载的其实是 <code>operator new</code> 函数。也就是说可以修改定制 <code>new operator</code> 完成任务的方式（即 <code>opearotr new</code> 函数），但它的任务流程已经被语言固定死了，无法控制。</p><h2 id="placement-new-placement-operator-new"><a href="#placement-new-placement-operator-new" class="headerlink" title="placement new (placement operator new)"></a>placement new (placement operator new)</h2><p><code>placement new</code> 是特殊版本的 <code>operator new</code> 函数，如果 <code>operator new</code> 函数接受的参数除了一定得有的 <code>size_t</code> 外还有其他参数，这便是所谓的 <code>placement</code> 版本。<br>众多 <code>placement new</code> 版本中特别有用的一个是 “被用于在分配好的内存上构建对象”。具体代码定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">void</span> *ptr)</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> ptr; &#125;</span><br><span class="line"><span class="comment">// GNU 版本源码：</span></span><br><span class="line"><span class="comment">// inline void* operator new(std::size_t, void* __p)_GLIBCXX_USE_NOEXCEPT &#123; return __p; &#125;</span></span><br></pre></td></tr></table></figure><p>这个版本可能比你预想的要简单，因为毕竟 <code>operator new</code> 函数的目的就是为对象找到一块内存，然后返回一个指针指向这块内存。而这一版本 <code>placement new</code> 的调用者显然知道指向内存的指针，因此这一版本 <code>placement new</code> 唯一需要做得就是将它获得的指针再返回。</p><p>这个常用的版本已经被纳入C++标准库中（只需要 <code>#include&lt;new&gt;</code>)，它同时也是最早的 <code>placement new</code> 版本。</p><p>大多数时候人们谈到的 <code>placement new</code> 就是特指这一版本——即唯一额外参数是个 <code>void*</code>。但一般性术语 <code>placement new</code> 意味着带任意额外参数的 <code>operator new</code> 函数，而且它有相对应的另一个术语 <code>placement delete</code>（下面会提到）。</p><p>常用 <code>placement new</code> 版本示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Object(<span class="keyword">int</span> args) &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Object* <span class="title">constructObject</span><span class="params">(<span class="keyword">void</span> *buffer, <span class="keyword">int</span> args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> (buffer) Object(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// constructObject 函数在编译器内部产生的代码可能就像下面这样</span></span><br><span class="line"><span class="comment">// 调用 default placement version of operator new, rawMemory 的地址实际就是 buffer 的地址。</span></span><br><span class="line"><span class="keyword">void</span>* rawMemory = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(Object), buffer);</span><br><span class="line"><span class="comment">// 将内存中的对象初始化</span></span><br><span class="line">call Object::Object(args) on *rawMemory;</span><br><span class="line"><span class="comment">// 让 pObj 指向新完成的对象</span></span><br><span class="line">Object *pObj = <span class="keyword">static_cast</span>&lt;Object*&gt;(rawMemory);</span><br><span class="line"><span class="comment">// pObj 作为函数结果返回</span></span><br><span class="line"><span class="keyword">return</span> pObj;</span><br></pre></td></tr></table></figure><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ol><li><p>最常用的，即希望将对象产生于 <code>heap</code>，那么就使用 <code>new opeartor (new expression)</code> ，它不但分配内存而且为该对象调用一个 <code>constructor</code> 设定初值。</p></li><li><p>只是希望分配内存，则使用 <code>operator new</code> 函数，它不会调用任何 <code>constructor</code>。</p></li><li><p>若希望在 <code>heap objects</code> 产生时自己决定内存分配方式，则自己写一个 <code>operator new</code> 函数的重载版本，并使用 <code>new operator(new expression)</code>，它就会自动调用你所写的 <code>operator new</code> 函数。</p></li><li><p>若已经有分配的内存（并拥有指向该内存地址的指针），则直接使用 C++ 标准库中的默认 <code>placement new</code> 版本（即上述的最常用 <code>placement new</code> 版本）在该内存上构造对象。</p></li></ol><hr><h1 id="delete-operator-delete-expression"><a href="#delete-operator-delete-expression" class="headerlink" title="delete operator (delete expression)"></a>delete operator (delete expression)</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *pStr = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Hello"</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">delete</span> pStr;</span><br></pre></td></tr></table></figure><p><code>delete operator</code> 的实际工作如下：</p><ol><li><p>调用 <code>pStr</code> 所指对象类型的 <code>destructor</code>。</p></li><li><p>调用名为 <code>operator delete</code> 的标准库函数释放被 <code>pStr</code> 所指对象占用的内存空间。</p></li></ol><p>编译器内部产生的代码可能就像下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用对象类型的 `destructor`</span></span><br><span class="line">pStr-&gt;~<span class="built_in">string</span>();</span><br><span class="line"><span class="comment">// 释放对象所占的内存</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pStr)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="operator-delete"><a href="#operator-delete" class="headerlink" title="operator delete"></a>operator delete</h2><p>同理，<code>operator delete</code> 之于 <code>delete operator</code> 就相当于 <code>operator new</code> 之于 <code>new operator</code>。</p><p><code>operator delete</code> 函数其实相比之下更简单，伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *rawMemory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rawMemory == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// 删除的是 null 指针，什么都不做</span></span><br><span class="line">    现在归还 rawMemory 所指向的内存</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 <code>operator new</code> 函数功能相反，该函数的 <strong>唯一任务就是释放内存</strong>，但注意需要记住 C++ 的保证 —— “删除 null 指针永远安全”。</p><h2 id="placement-delete-placement-operator-delete"><a href="#placement-delete-placement-operator-delete" class="headerlink" title="placement delete (placement operator delete)"></a>placement delete (placement operator delete)</h2><p>类似于 <code>operator new</code> 函数的 <code>placement</code> 版本，<code>operator delete</code> 函数如果接受除 <code>void*</code> 参数之外的额外参数，便称为 <code>placement delete</code>。</p><p>如果在 <code>new operator</code> 的流程中，<code>operator new</code> 函数分配内存成功，但在该块内存上构造对象时抛出异常，则运行期系统有责任取消 <code>operator new</code> 函数的内存分配并恢复原样。<strong>运行期系统会寻找 “参数个数和类型都与 <code>operator new</code> 相同”的某个 <code>operator delete</code></strong>，如果找到那就是它的的调用对象。</p><p>即 <code>placement delete</code> 函数只有在 <code>placement new</code> 函数调用而触发的构造函数出现异常时才会被运行期系统调用，而对着一个指针施行 <code>delete</code> 绝不会调用 <code>placement delete</code>。</p><p>所以规则很简单：如果一个带额外参数的 <code>operator new</code> 函数没有带相同额外参数的对应版 <code>operator delete</code> 函数，那么当 <code>new operator</code> 的内存分配动作需要取消并恢复原样时就没有任何 <code>operator delete</code> 函数会被调用，这会造成内存泄漏，显然是不对的。</p><p>这也意味着如果要对所有与 <code>placement new</code> 相关的内存泄漏问题宣战，<strong>必须同时提供一个正常版本的 <code>operator delete</code> （用于构造期间无任何异常被抛出）和一个 <code>placement</code> 版本（用于构造期间有异常被抛出），后者的额外参数必须和 <code>operator new</code> 的 <code>placement</code> 版本一样</strong>。</p><p>示例（来自 <code>Effective C++ Item 52</code>）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// placement operator new，即带有额外参数 std::ostream&amp; 的 operator new</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> size, <span class="built_in">std</span>::ostream &amp;logStream)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常形式的 operator delete (class 专属)</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *pMemory)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="comment">// placement operator delete，即带有额外参数 std::ostream&amp; 的 operator delete</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *pMemory, <span class="built_in">std</span>::ostream &amp;logStream)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new operator 调用 placement new 函数，现在构造时抛出异常不再泄漏</span></span><br><span class="line">Widget *pw = <span class="keyword">new</span> (<span class="built_in">std</span>::<span class="built_in">cerr</span>) Widget;</span><br><span class="line"><span class="comment">// delete operator 调用正常的 operator delete 函数</span></span><br><span class="line"><span class="keyword">delete</span> pw;</span><br></pre></td></tr></table></figure><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><ol><li><p>当写一个 <code>placement operator new</code>，请确定也写出了对应的 <code>placement operator delete</code>。如果不这样做，程序可能会发生隐微而时断时续的内存泄漏。</p></li><li><p>当声明 <code>placement operator new</code> 和 <code>placement operator delete</code> 时，请确定不要无意识地遮掩它们的正常版本。</p></li></ol><hr><h1 id="Array-version"><a href="#Array-version" class="headerlink" title="Array version"></a>Array version</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *pStr = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span>[] pStr;</span><br></pre></td></tr></table></figure><p>上述使用的 <code>new</code> 仍然是那个 <code>new operator</code>，但由于诞生的是数组，所以 <code>new operator</code> 的行为与之前产生单一对象的版本不同，内存分配将是由 <code>operator new</code> 函数的兄弟版本 <code>operator new[]</code> 函数负责。和 <code>operator new</code> 函数一样，<code>operator new[]</code> 也可以被重载。</p><p><code>operator delete[]</code> 函数和 <code>operator delete</code> 函数同理。</p><p>要说 “数组版” 和 “单一对象版” 的 <code>new operator</code> 最大的不同是它所调用的 <code>constructor</code> 数量。数组版本 <code>new operator</code> 先调用 <code>operator new[]</code> 分配足够内存，再然后必须针对数组中的每一个对象调用一个 <code>constructor</code>。</p><p>同理，当 <code>delete operator</code> 被用于数组时，它会针对数组中的每一个元素调用其 <code>destructor</code>，然后再调用 <code>operator delete[]</code> 释放内存。</p><hr><p>好了，现在可以知道：如果希望自己控制应用程序中内存分配的过程，即需要定义自己的 <code>operator new</code> 函数和 <code>operator delete</code> 函数。它们 <strong>既可以定义在全局作用域，也可以定义为成员函数</strong>（定义为成员函数时，它们是隐式静态的，但我建议还是显式声明为 <code>static</code>，因为 <code>operator new</code> 函数用在对象构造之前而 <code>operator delete</code> 函数用在对象销毁之后）。<br>当编译器发现 <code>new</code> 或 <code>delete</code> 后，将在程序中查找可供调用的 <code>operator</code> 函数，其 <strong>匹配查找顺序为：类及其基类的作用域 -&gt; 全局作用域 -&gt; 标准库定义的版本</strong>。</p><p>最新的标准库定义了 <a href="http://en.cppreference.com/w/cpp/memory/new/operator_new" target="_blank" rel="noopener"><code>operator new</code> 函数</a> 和 <a href="http://en.cppreference.com/w/cpp/memory/new/operator_delete" target="_blank" rel="noopener"><code>operator delete</code> 函数</a> 的各种版本，以下给出 GNU 中的 <code>&lt;new&gt;</code> 头文件的部分源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  @brief  Exception possibly thrown by @c new.</span></span><br><span class="line"><span class="comment">   *  @ingroup exceptions</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *  @c bad_alloc (or classes derived from it) is used to report allocation</span></span><br><span class="line"><span class="comment">   *  errors from the throwing forms of @c new.  </span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">bad_alloc</span> :</span> <span class="keyword">public</span> exception</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    bad_alloc() <span class="keyword">throw</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This declaration is not useless:</span></span><br><span class="line">    <span class="comment">// http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118</span></span><br><span class="line">    <span class="keyword">virtual</span> ~bad_alloc() <span class="keyword">throw</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See comment in eh_exception.cc.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">bad_array_new_length</span> :</span> <span class="keyword">public</span> bad_alloc</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    bad_array_new_length() <span class="keyword">throw</span>() &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This declaration is not useless:</span></span><br><span class="line">    <span class="comment">// http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118</span></span><br><span class="line">    <span class="keyword">virtual</span> ~bad_array_new_length() <span class="keyword">throw</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See comment in eh_exception.cc.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cpp_aligned_new</span></span><br><span class="line">  <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">align_val_t</span>:</span> <span class="keyword">size_t</span> &#123;&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nothrow_t</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">nothrow_t</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">nothrow_t</span> nothrow;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** If you write your own error handler to be called by @c new, it must</span></span><br><span class="line"><span class="comment">   *  be of this type.  */</span></span><br><span class="line">  <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Takes a replacement handler as the argument, returns the</span></span><br><span class="line">  <span class="comment">/// previous handler.</span></span><br><span class="line">  <span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">  <span class="comment">/// Return the current new handler.</span></span><br><span class="line">  <span class="function">new_handler <span class="title">get_new_handler</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; <span class="comment">// namespace std</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** These are replaceable signatures:</span></span><br><span class="line"><span class="comment"> *  - normal single new and delete (no arguments, throw @c bad_alloc on error)</span></span><br><span class="line"><span class="comment"> *  - normal array new and delete (same)</span></span><br><span class="line"><span class="comment"> *  - @c nothrow single new and delete (take a @c nothrow argument, return</span></span><br><span class="line"><span class="comment"> *    @c NULL on error)</span></span><br><span class="line"><span class="comment"> *  - @c nothrow array new and delete (same)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Placement new and delete signatures (take a memory address argument,</span></span><br><span class="line"><span class="comment"> *  does nothing) may not be replaced by a user's program.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alloc)</span></span></span><br><span class="line">  __attribute__((__externally_visible__));</span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span>) <span class="keyword">throw</span>(<span class="built_in">std</span>::bad_alloc)</span><br><span class="line">  __attribute__((__externally_visible__));</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*)</span> <span class="keyword">noexcept</span></span></span><br><span class="line">  __attribute__((__externally_visible__));</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>*) <span class="keyword">noexcept</span></span><br><span class="line">  __attribute__((__externally_visible__));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cpp_sized_deallocation</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*, <span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line">  __attribute__((__externally_visible__));</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>*, <span class="built_in">std</span>::<span class="keyword">size_t</span>) <span class="keyword">noexcept</span></span><br><span class="line">  __attribute__((__externally_visible__));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span></span></span><br><span class="line">  __attribute__((__externally_visible__));</span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>&amp;) <span class="keyword">noexcept</span></span><br><span class="line">  __attribute__((__externally_visible__));</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span></span></span><br><span class="line">  __attribute__((__externally_visible__));</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>*, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>&amp;) <span class="keyword">noexcept</span></span><br><span class="line">  __attribute__((__externally_visible__));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cpp_aligned_new</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="built_in">std</span>::<span class="keyword">align_val_t</span>)</span></span></span><br><span class="line">  __attribute__((__externally_visible__));</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="built_in">std</span>::<span class="keyword">align_val_t</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span></span></span><br><span class="line">__attribute__((__externally_visible__));</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*, <span class="built_in">std</span>::<span class="keyword">align_val_t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line">   __attribute__((__externally_visible__));</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*, <span class="built_in">std</span>::<span class="keyword">align_val_t</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span></span></span><br><span class="line">__attribute__((__externally_visible__));</span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="built_in">std</span>::<span class="keyword">align_val_t</span>)</span><br><span class="line">  __attribute__((__externally_visible__));</span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="built_in">std</span>::<span class="keyword">align_val_t</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>&amp;) <span class="keyword">noexcept</span></span><br><span class="line">__attribute__((__externally_visible__));</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>*, <span class="built_in">std</span>::<span class="keyword">align_val_t</span>) <span class="keyword">noexcept</span></span><br><span class="line">__attribute__((__externally_visible__));</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>*, <span class="built_in">std</span>::<span class="keyword">align_val_t</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>&amp;) <span class="keyword">noexcept</span></span><br><span class="line">__attribute__((__externally_visible__));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cpp_sized_deallocation</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*, <span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="built_in">std</span>::<span class="keyword">align_val_t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line">__attribute__((__externally_visible__));</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>*, <span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="built_in">std</span>::<span class="keyword">align_val_t</span>) <span class="keyword">noexcept</span></span><br><span class="line">__attribute__((__externally_visible__));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// __cpp_sized_deallocation</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// __cpp_aligned_new</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Default placement versions of operator new.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="keyword">void</span>* __p)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> __p; &#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="keyword">void</span>* __p) <span class="keyword">noexcept</span></span><br><span class="line">&#123; <span class="keyword">return</span> __p; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Default placement versions of operator delete.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span>  <span class="params">(<span class="keyword">void</span>*, <span class="keyword">void</span>*)</span> <span class="keyword">noexcept</span> </span>&#123; &#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>*, <span class="keyword">void</span>*) <span class="keyword">noexcept</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>与析构函数类似，<code>operator delete</code> 函数也不允许抛出异常（<a href="http://koushiro.me/2017/02/03/Effective-Cpp-Note2/#more">Item8</a>），<strong>重载 <code>operator delete</code> 函数时必须使用 <code>noexcept</code> 异常说明符指定其不抛出异常</strong>。</p><p><a href="http://en.cppreference.com/w/cpp/memory/new/nothrow_t" target="_blank" rel="noopener"><code>nothrow_t</code></a> 是定义在 <code>&lt;new&gt;</code> 头文件中的一个 <code>struct</code>，<code>nothrow</code> 是一个类型为 <code>nothrow_t</code> 的 <code>const</code> 对象，用户可通过这个对象获取 <code>operator new</code> 函数的不抛出异常版本。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这部分主要涉及 &lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;delete&lt;/code&gt; 这两个 keyword，它们的一些高级用法在课堂上或者一些 C++ 初学者书籍中很难见到，对于编码者也很少用到这部分内容，当然我对此也不是了解得特别透彻，文中如有错误，请在评论指出。&lt;/p&gt;
    
    </summary>
    
      <category term="Cpp" scheme="http://koushiro.me/categories/Cpp/"/>
    
    
      <category term="tech" scheme="http://koushiro.me/tags/tech/"/>
    
      <category term="Cpp" scheme="http://koushiro.me/tags/Cpp/"/>
    
      <category term="note" scheme="http://koushiro.me/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>Network I/O Model</title>
    <link href="http://koushiro.me/2018/06/16/Network-IO-Model/"/>
    <id>http://koushiro.me/2018/06/16/Network-IO-Model/</id>
    <published>2018-06-16T15:41:29.000Z</published>
    <updated>2018-09-22T17:59:32.537Z</updated>
    
    <content type="html"><![CDATA[<center>学习一些开源的网络库源码时，需要了解的网络I/O模型。</center><a id="more"></a><p>从蚂蚁笔记的博客导入，还需重新排版</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;学习一些开源的网络库源码时，需要了解的网络I/O模型。&lt;/center&gt;
    
    </summary>
    
      <category term="Network" scheme="http://koushiro.me/categories/Network/"/>
    
    
      <category term="tech" scheme="http://koushiro.me/tags/tech/"/>
    
      <category term="network" scheme="http://koushiro.me/tags/network/"/>
    
      <category term="IO" scheme="http://koushiro.me/tags/IO/"/>
    
      <category term="Unix" scheme="http://koushiro.me/tags/Unix/"/>
    
      <category term="Windows" scheme="http://koushiro.me/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Optimize string in C++</title>
    <link href="http://koushiro.me/2018/06/05/Optimize-string-in-Cpp/"/>
    <id>http://koushiro.me/2018/06/05/Optimize-string-in-Cpp/</id>
    <published>2018-06-05T07:52:21.000Z</published>
    <updated>2018-09-22T17:58:38.044Z</updated>
    
    <content type="html"><![CDATA[<p>字符串是程序代码中使用最频繁的几种数据类型之一，在C++中基本是以std::string出现（当然还有C中的字符数组），尽管它被正确和频繁的使用，但多数coder仍然会忽略可以明显改善性能的地方。</p><a id="more"></a><hr><h1 id="字符串的重要特性"><a href="#字符串的重要特性" class="headerlink" title="字符串的重要特性"></a>字符串的重要特性</h1><h2 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h2><p>C++中字符串的内容是自动增长的，相比C中固定长度的字符数组（需要手动分配和释放内存），拥有更好的便捷灵活性，但为了实现内容的自动增长，字符串被设计为动态分配，而动态分配内存相比一些操作更耗费资源。</p><p>虽然C++中的字符串是动态分配的（字符串增长的情况），但实际上字符串内部的buffer的大小在一段时间内仍然是固定的。详细可以解释为字符串向内存管理器申请的buffer的大小并非与字符串所需存储的字符数完全一致，而是更大的空间（通常是现在所需的两倍大小）。这带来的好处就是随着字符串变得更长，在字符串后面再添加字符或是字符串的开销近似于一个常量（降低向内存管理器动态申请内存的次数），而代价则是字符串携带了一些未使用的内存空间。</p><h2 id="大量复制"><a href="#大量复制" class="headerlink" title="大量复制"></a>大量复制</h2><p>字符串的行为与普通的整型值类似，即修改一个字符串不能改变其他字符串的值，表现得就像拥有自己的私人副本。</p><p>实现这种行为的最简单的方式是当创建字符串、赋值或是将其作为参数传递给函数的时候就进行一次复制。如果字符串是以这种方式实现的，那么赋值和参数传递的开销将会变得很大，但是变值函数（mutating function）和非常量引用的开销却很小。</p><p>另一种方式就是“写时复制”（copy on write），它可以让对象与值具有同样的表现，尽管写时复制的字符串在赋值和参数传递的开销很小，但是写时复制是不符合 C++11 标准的实现方式，而且写时复制（也就是变值函数（mutating function）和非常量引用）的开销同样大。</p><p>针对字符串在程序中存在的大量复制问题，C++11及之后的版本推出了“右值引用”和“移动语义”的概念，可以而且特别是在一些赋值和参数传递情况下减轻复制字符串带来的负担，提高性能，但在这篇博客中并不重点叙述“右值引用”和“移动语义”的概念。</p><hr><h1 id="字符串的常用性能优化方法"><a href="#字符串的常用性能优化方法" class="headerlink" title="字符串的常用性能优化方法"></a>字符串的常用性能优化方法</h1><p>在介绍常用优化手段前，引入一个例子（之后的代码片段和性能数据都来自Optimized C++），这个函数的功能是从一个由 ASCII 字符组成的字符串中移除控制字符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">remove_ctrl</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &gt;= <span class="number">0x20</span>)</span><br><span class="line">            result = result + s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用复合赋值操作避免临时字符串"><a href="#使用复合赋值操作避免临时字符串" class="headerlink" title="使用复合赋值操作避免临时字符串"></a>使用复合赋值操作避免临时字符串</h2><p>字符串连接运算符的开销是很大的。因为它会调用内存管理器去构建一个新的临时字符串对象来保存连接后的字符串。</p><p>如果传递给 remove_ctrl() 的参数是一个由可打印的字符组成的字符串，那么 remove_ctrl() 几乎会为 s 中的每个字符都构建一个临时字符串对象，这显然是不可接受的。</p><p>而使用复合赋值操作来避免临时字符串，是针对字符串两种最重要特性（动态分配和大量复制）的优化。</p><p>小小的改动移除了所有为分配临时字符串对象来保存连接结果而对内存管理器的调用，以及相关的复制和释放临时字符串的操作。<br>赋值时的分配和复制操作也可以被移除，不过这取决于字符串的实现方式（C++11实现了右值引用和移动语义，连接表达式的结果由于是一个右值，编译器可以调用 result 的移动构造函数，而无需调用复制构造函数，程序将会执行一次高效的指针复制）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">remove_ctrl_mutating</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &gt;= <span class="number">0x20</span>)</span><br><span class="line">            result += s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过预留存储空间减少内存的重新分配"><a href="#通过预留存储空间减少内存的重新分配" class="headerlink" title="通过预留存储空间减少内存的重新分配"></a>通过预留存储空间减少内存的重新分配</h2><p>针对字符串的动态分配特性，通过使用 std::string() 的 reserve() 成员函数预先分配足够的内存空间来优化 remove_ctrl_mutating()。使用reserve() 不仅移除了字符串缓冲区的重新分配，还改善了函数所读取的数据的缓存局部性（cache locality）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">remove_ctrl_reserve</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> result;</span><br><span class="line">    result.reserve(s.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &gt;= <span class="number">0x20</span>)</span><br><span class="line">            result += s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-pass-by-ref-消除对参数字符串的复制"><a href="#使用-pass-by-ref-消除对参数字符串的复制" class="headerlink" title="使用 pass by ref 消除对参数字符串的复制"></a>使用 pass by ref 消除对参数字符串的复制</h2><p>通过值（即所谓的 pass-by-value）将一个字符串参数传递给一个不会修改该字符串的函数对一个严格的C++程序员来说是不可接受的。</p><p>如果该字符串实参是由表达式产生的（更准确地说它是右值），C++11编译器将会调用移动构造函数执行一次高效的指针复制，这还算好的情况；但如果实参是一个变量（更准确地说它是左值），那么将会调用字符串的拷贝构造函数，这会导致一次内存分配和复制。不要小看一次的内存分配和复制，随着传入字符串的长度增长，该函数的调用性能会越差。</p><p>在此处的例子中移除实参复制，使用 pass by reference 可以省去一次昂贵的内存分配和字符串内容的深拷贝。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">remove_ctrl_ref_args</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> result;</span><br><span class="line">    result.reserve(s.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &gt;= <span class="number">0x20</span>)</span><br><span class="line">            result += s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 s 从字符串修改为字符串引用后可能会因为其他因素（比如解引指针，C++中的引用变量实际是作为指针实现的，当程序中每次出现 s 时，都需要解引指针）抵消节省内存分配带来的性能提升，使得整体的性能较 remove_ctrl_reserve 还要差。</p><h2 id="使用迭代器消除指针解引"><a href="#使用迭代器消除指针解引" class="headerlink" title="使用迭代器消除指针解引"></a>使用迭代器消除指针解引</h2><p>字符串迭代器是指向字符缓冲区的简单指针。与不使用迭代器的代码 remove_ctrl_ref_args 相比，可以节省两次解引操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">remove_ctrl_ref_args_it</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> result;</span><br><span class="line">    result.reserve(s.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = s.begin(); it != s.end(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*it &gt;= <span class="number">0x20</span>)</span><br><span class="line">            result += *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了了解使用 pass by reference 的 remove_ctrl_ref_args 的性能是否有改善，需要控制变量实现 remove_ctrl_reserve 的迭代器版本 remove_ctrl_reserve_it，测试比较 remove_ctrl_reserve_it 和 remove_ctrl_ref_args_it ，结果说明将参数类型修改为字符串引用确实提高了程序性能。</p><p>同时编写上述所有代码的迭代器版本与非迭代器版本进行比较，就现有例子的结果，使用迭代器的都比非迭代器的要快，但这个优化手段 <strong>并不总是有效</strong>。</p><h2 id="消除对返回的字符串的复制"><a href="#消除对返回的字符串的复制" class="headerlink" title="消除对返回的字符串的复制"></a>消除对返回的字符串的复制</h2><p>remove_ctrl() 是通过值返回处理结果的。C++编译器会调用复制构造函数将结果设置到调用上下文中。实际上编译器自身有可能进行C++返回值优化，即RVO，省去拷贝构造，尽管在大多数情况下能提高性能，但是却难以受程序员控制。<br>（此处不具体讨论RVO，详情参考<a href="http://en.cppreference.com/w/cpp/language/copy_elision" target="_blank" rel="noopener">此链接</a>）</p><p>想要确保不会发生复制，有一种比较简单的方式是将字符串作为输出参数返回，这种方法适用于所有的 C++ 版本以及字符串的所有实现方式。虽然性能有些许提升，但是该函数的接口并不直观，很容易导致调用方误用这个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_ctrl_ref_result_it</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">string</span>&amp; result,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    result.clear();</span><br><span class="line">    result.reserve(s.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = s.begin(); it != s.end(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*it &gt;= <span class="number">0x20</span>)</span><br><span class="line">            result += *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="舍弃-C-特性，使用-C-风格字符数组"><a href="#舍弃-C-特性，使用-C-风格字符数组" class="headerlink" title="舍弃 C++ 特性，使用 C 风格字符数组"></a>舍弃 C++ 特性，使用 C 风格字符数组</h2><p>remove_ctrl_cstrings() 这种转换为C风格字符数组的优化方式成本较高（常用于一些高性能服务和严格的嵌入式环境），而且很不C++。但尽管如此，remove_ctrl_cstrings() 仍然说明：只要开发人员愿意用C风格字符数组完全重写关于字符串的函数和接口，就可以获得很大的性能提升。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_ctrl_cstrings</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">const</span> <span class="keyword">char</span>* src, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (src[i] &gt;= <span class="number">0x20</span>)</span><br><span class="line">            *dst++ = src[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *dst = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="字符串的其他性能优化方法"><a href="#字符串的其他性能优化方法" class="headerlink" title="字符串的其他性能优化方法"></a>字符串的其他性能优化方法</h1><h2 id="使用更好的算法"><a href="#使用更好的算法" class="headerlink" title="使用更好的算法"></a>使用更好的算法</h2><p>算法优化是各种优化手段中的第一选择。</p><p>在没有选择较优算法的情形下过早优化其实是吃力不讨好的。好的算法可能在第一次编写代码时就获得远比坏算法优化迭代多次的结果还要好的性能，而且上述的常用优化手段也能应用到好的新算法中，进一步提升性能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">remove_ctrl_block_append</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> result;</span><br><span class="line">    result.reserve(s.length());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> b = <span class="number">0</span>, i = b; b &lt; s.length(); b = i+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = b; i &lt; s.length(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &lt; <span class="number">0x20</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// substr() 仍然生成临时字符串。</span></span><br><span class="line">        <span class="comment">// 由于这个函数将字符添加到了 result 的末尾，</span></span><br><span class="line">        <span class="comment">// 开发人员可以通过重载 std::string 的 append() 成员函数</span></span><br><span class="line">        <span class="comment">// 来复制子字符串，且无需创建临时字符串。</span></span><br><span class="line">        <span class="comment">// result = result + s.substr(b, i-b);</span></span><br><span class="line">        result.append(s, b, i-b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用更好的编译器和字符串库"><a href="#使用更好的编译器和字符串库" class="headerlink" title="使用更好的编译器和字符串库"></a>使用更好的编译器和字符串库</h2><p>C++只规定了标准，各个编译器内部的具体实现各式各样。因此一个好的编译器能做到更多的自我优化。</p><p>std::string 的定义曾经非常模糊，这让开发人员在实现字符串时有更广泛的选择。后来，对性能和可预测性的需求最终迫使 C++ 标准明确了它的定义，导致很多新奇的实现方式不再适用。比如 C++ 标准要求迭代器能够随机访问，而且禁止写时复制语义，这样更容易定义 std::string，而且更容易推论出哪些操作会使 std::string 中正在使用的迭代器无效，这也推动 std::string 的实现趋于简单。</p><p>就我个人而言，标准 C++ 字符串库已经够用了（尽管缺少了一些字符集的转换函数）。标准 C++ 中共有几种字符串实现方式：</p><ul><li>模板化的、支持迭代器访问的、可变长度的std::string 字符串</li><li>简单的、基于迭代器的 std::vector<char></char></li><li>老式的、C 风格的以空字符结尾的、固定长度的字符数组</li><li>std::stringstream 。std::stringstream 类以一种不同的方式封装了一块动态大小的缓冲区（通常就是一个 std::string），数据可以被添加至这个实体中。由于被修改为了一个实体，很长的插入表达式不会创建任何临时字符串，因此不会发生内存分配和复制操作。如果 std::stringstream 是用 std::string 实现的，那么它在性能上永远不能胜过 std::string，但好在可以防止某些降低程序性能的编程实践。</li><li>通过移除一个或多个限制（迭代器、索引、C 风格访问、简单性），自定义的字符串类可以优化那些因使用了 std::string 而无法优化的代码。（尽量在设计初期就确定）</li><li>string_view 可以解决 std::string 的某些问题。它包含一个指向字符串数据的无主指针和一个表示字符串长度的值，所以它可以表示为 std::string 或字面字符串的子字符串。与 std::string 相比，它的 substring 和 trim 等操作更高效，但问题在于无主指针，程序员必须确保每个 string_view 的生命周期都不会比它所指向的 std::string 的生命周期长。</li></ul><h2 id="使用更好的内存分配器"><a href="#使用更好的内存分配器" class="headerlink" title="使用更好的内存分配器"></a>使用更好的内存分配器</h2><p>每个 std::string 的内部都是一个动态分配的字符数组。std::string 可以看成是如下通用模板的一种特化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">charT</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">traits</span> = <span class="title">char_traits</span>&lt;charT&gt;,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">allocator</span>&lt;charT&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">basic_string</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="keyword">char</span>&gt; <span class="built_in">string</span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第三个模板参数 Alloc 定义了一个分配器——一个访问 C++ 内存管理器的专用接口。默认情况下，Alloc 是 std::allocator，它会调用 operator new() 和operator delete()——两个全局的 C++ 内存分配器函数。</p><p>operator new() 和 operator delete() 实际很复杂，为了实现各种情形下良好的通用性，它们在设计上做出了一些妥协。因此在一些特定场景中自定义一种更加特化的分配器可能会更好地提升性能。但就我这个C++菜鸡而言，我肯定是使用默认的allocator，不会去编写自己的内存分配器。</p><h2 id="消除字符串无谓转换和不同字符集间的转换"><a href="#消除字符串无谓转换和不同字符集间的转换" class="headerlink" title="消除字符串无谓转换和不同字符集间的转换"></a>消除字符串无谓转换和不同字符集间的转换</h2><p>一些场景下 char<em> 转换为 std::string 是无谓的。std::string 有一个参数为 char</em> 的构造函数，因此当返回值被赋值给一个字符串或是作为参数传递给另外一个函数时，会自动进行转换。也就是说将返回值的转换推迟至它真正被使用的时候。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="keyword">const</span>* MyClass::Name() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"MyClass"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span>* p = myInstance-&gt;Name(); <span class="comment">// 没有转换</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s = myInstance-&gt;Name(); <span class="comment">// 转换为'std::string'</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; myInstance-&gt;Name();    <span class="comment">// 没有转换</span></span><br></pre></td></tr></table></figure><p>在多字符集的场景下，不同字符集间的频繁转换也是性能优化的一个热点，移除不同字符集间转换的最佳方法是为所有的字符串选择一种固定的格式，并将所有字符串都存储为这种格式。个人而言首推 UTF-8格式（windows万恶的GBK），因为它能够表示所有的 Unicode 码点，并可以直接与 C 风格的字符串进行比较（是否相同）。</p><blockquote><p>PS: 下一篇C++优化的主题内容应该是关于标准库算法的，特别是查找和排序的优化。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;字符串是程序代码中使用最频繁的几种数据类型之一，在C++中基本是以std::string出现（当然还有C中的字符数组），尽管它被正确和频繁的使用，但多数coder仍然会忽略可以明显改善性能的地方。&lt;/p&gt;
    
    </summary>
    
      <category term="Cpp" scheme="http://koushiro.me/categories/Cpp/"/>
    
    
      <category term="tech" scheme="http://koushiro.me/tags/tech/"/>
    
      <category term="Cpp" scheme="http://koushiro.me/tags/Cpp/"/>
    
      <category term="note" scheme="http://koushiro.me/tags/note/"/>
    
      <category term="optimize" scheme="http://koushiro.me/tags/optimize/"/>
    
  </entry>
  
  <entry>
    <title>Learn Git</title>
    <link href="http://koushiro.me/2018/03/15/Learn-Git/"/>
    <id>http://koushiro.me/2018/03/15/Learn-Git/</id>
    <published>2018-03-15T11:24:36.000Z</published>
    <updated>2018-10-08T10:22:55.394Z</updated>
    
    <content type="html"><![CDATA[<center>This blog records how Git is used and some of the problems I encountered while using Git.</center><a id="more"></a><h1 id="Learn-Git"><a href="#Learn-Git" class="headerlink" title="Learn Git"></a>Learn Git</h1><p>See the link below for the full usage of Git.</p><p><a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">Pro Git, English version</a></p><p><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Pro Git, Chinese version</a></p><h2 id="Git流程"><a href="#Git流程" class="headerlink" title="Git流程"></a>Git流程</h2><p>流程分为4个区域：</p><ul><li>工作区 (Workspace)</li><li>暂存去 (Staging Area)</li><li>本地仓库 (Local Repository)</li><li>远程仓库 (Remote Repository)</li></ul><p>4个区域划分了5种状态：</p><ul><li>初始 (Origin)</li><li>已修改/未跟踪 (Modified &amp; Untracked)</li><li>已暂存 (Staged)</li><li>已提交 (Committed)</li><li>已推送 (Pushed)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># How to get a git repository?</span></span><br><span class="line"><span class="built_in">cd</span> /path/to/your_project</span><br><span class="line">git init</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">git <span class="built_in">clone</span> &lt;git-repo-url&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Used to see current status of workspace and stage area.</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># Origin ==&gt; Modified &amp; Untracked</span></span><br><span class="line"><span class="comment"># Workspace</span></span><br><span class="line">Some coding work.</span><br><span class="line"></span><br><span class="line"><span class="comment"># Modified &amp; Untracked ==&gt; Staged</span></span><br><span class="line"><span class="comment"># Workspace ==&gt; Stage Area</span></span><br><span class="line">git add --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># Staged ==&gt; Committed</span></span><br><span class="line"><span class="comment"># Stage Area ==&gt; Local Repository</span></span><br><span class="line">git commit -m <span class="string">"some comment"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Committed ==&gt; Pushed</span></span><br><span class="line"><span class="comment"># Local Repository ==&gt; Remote Repository</span></span><br><span class="line">git push remote_name remote_branch_name</span><br></pre></td></tr></table></figure><hr><h2 id="常用的Git命令列表"><a href="#常用的Git命令列表" class="headerlink" title="常用的Git命令列表"></a>常用的Git命令列表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">add                -- add file contents to index</span><br><span class="line">blame              -- show what revision and author last modified each line</span><br><span class="line">branch             -- list, create, or delete branches</span><br><span class="line">checkout           -- checkout branch or paths to working tree</span><br><span class="line">cherry             -- find commits not merged upstream</span><br><span class="line">clean              -- remove untracked files from working tree</span><br><span class="line"><span class="built_in">clone</span>              -- <span class="built_in">clone</span> repository into new directory</span><br><span class="line">commit             -- record changes to repository</span><br><span class="line">config             -- get and <span class="built_in">set</span> repository or global options</span><br><span class="line">diff               -- show changes between commits, commit and working tree, etc.</span><br><span class="line">fetch              -- download objects and refs from another repository</span><br><span class="line">grep               -- <span class="built_in">print</span> lines matching a pattern</span><br><span class="line">gui                -- run portable graphical interface to git</span><br><span class="line"><span class="built_in">help</span>               -- display <span class="built_in">help</span> information about git</span><br><span class="line">init               -- create empty git repository or re-initialize an existing one</span><br><span class="line"><span class="built_in">log</span>                -- show commit logs</span><br><span class="line">merge              -- join two or more development histories together</span><br><span class="line">mv                 -- move or rename file, directory, or symlink</span><br><span class="line">pull               -- fetch from and merge with another repository or <span class="built_in">local</span> branch</span><br><span class="line">push               -- update remote refs along with associated objects</span><br><span class="line">rebase             -- forward-port <span class="built_in">local</span> commits to the updated upstream head</span><br><span class="line">remote             -- manage <span class="built_in">set</span> of tracked repositories</span><br><span class="line">reset              -- reset current HEAD to specified state</span><br><span class="line">revert             -- revert existing commits</span><br><span class="line">rm                 -- remove files from the working tree and from the index</span><br><span class="line">show               -- show various types of objects</span><br><span class="line">stash              -- stash away changes to dirty working directory</span><br><span class="line">status             -- show working-tree status</span><br><span class="line">submodule          -- initialize, update, or inspect submodules</span><br><span class="line">tag                -- create, list, delete or verify tag object signed with GPG</span><br></pre></td></tr></table></figure><hr><h2 id="远程仓库的关联和管理"><a href="#远程仓库的关联和管理" class="headerlink" title="远程仓库的关联和管理"></a>远程仓库的关联和管理</h2><p><code>git remote</code> 命令被用于关联和管理远程仓库，常用选项的名字一眼就能看出作用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add               -- add a new remote</span><br><span class="line">remove     rm     -- remove a remote and all associated tracking branches</span><br><span class="line">rename            -- rename a remote and update all associated tracking branches</span><br><span class="line">show              -- show information about a given remote</span><br><span class="line">--verbose  -v     -- show remote url after name</span><br></pre></td></tr></table></figure><p>举个栗子，给github上不属于自己的项目贡献代码时，需要先把该项目fork到自己账户中，然后将fork的仓库<code>clone</code>到本地，但可能在贡献过程中原有（上游）仓库有新的提交，你最好使自己的fork仓库与原有（上游）仓库保持一致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/your_name/project.git</span><br><span class="line"><span class="built_in">cd</span> project</span><br><span class="line">git remote rename origin myfork</span><br><span class="line">git remote add upstream https://github.com/project_owner/project.git</span><br><span class="line">git remote -v</span><br><span class="line"><span class="comment"># myforkhttps://github.com/your_name/project.git (fetch)</span></span><br><span class="line"><span class="comment"># myfork        https://github.com/your_name/project.git (push)</span></span><br><span class="line"><span class="comment"># upstreamhttps://github.com/project_owner/project.git (fetch)</span></span><br><span class="line"><span class="comment"># upstreamhttps://github.com/project_owner/project.git (push)</span></span><br><span class="line"></span><br><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者直接 git pull upstream master 一条命令，但我推荐分开命令执行</span></span><br><span class="line">git fetch upstream master</span><br><span class="line">git merge upstream/master</span><br><span class="line"><span class="comment"># 将更新的本地 fork 仓库推送到远程 fork 仓库</span></span><br><span class="line">git push myfork master</span><br></pre></td></tr></table></figure><hr><h2 id="撤销更改"><a href="#撤销更改" class="headerlink" title="撤销更改"></a>撤销更改</h2><p>已修改，未暂存 (即 <code>git add</code> 命令之前)，所有的修改文件都还在工作区，并没进入暂存区，此时撤销工作区修改:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查工作区和暂存区之间的差异，列出所有差异</span></span><br><span class="line">git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复暂存区文件到工作区</span></span><br><span class="line">git checkout &lt;file-name&gt; / git checkout .</span><br><span class="line"><span class="comment"># 撤销工作区修改的同时也撤销暂存区修改，都恢复到上一次commit的状态</span></span><br><span class="line">git reset --hard &lt;file-name&gt; / git reset --hard</span><br></pre></td></tr></table></figure><p>已暂存，未提交（即 <code>git add</code> 命令之后，<code>git commit</code> 命令之前），被 <code>add</code> 的文件都进入了暂存区，但并没进入本地仓库，此时撤销暂存区修改（可选择是否同时撤销工作区修改）:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查暂存区和本地仓库之间的差异，列出所有差异</span></span><br><span class="line">git diff --cached</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复暂存区的文件，退回到 git add 之前，即 '已修改未暂存' 状态</span></span><br><span class="line">git reset &lt;file-name&gt; / git reset</span><br><span class="line"><span class="comment"># 若还想恢复工作区修改，退回到 '未修改' 状态，还需</span></span><br><span class="line">git checkout &lt;file-name&gt; / git checkout .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者想同时一口气撤销暂存区和工作区修改</span></span><br><span class="line">git reset --hard &lt;file-name&gt; / git reset --hard</span><br></pre></td></tr></table></figure><p>已提交，未推送（即 <code>git commit</code> 命令之后，<code>git push</code> 命令之前），所有暂存区的文件都进入了本地仓库，但还没被推送到远程仓库，此时撤销本地仓库修改:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查本地仓库与远程仓库之间的差异，列出所有差异</span></span><br><span class="line"><span class="comment"># master为本地分支，origin/master为远程仓库分支</span></span><br><span class="line">git diff master origin/master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地仓库退回到某一个commit</span></span><br><span class="line">git reset --hard &lt;commit-hash&gt;</span><br><span class="line"><span class="comment"># 本地仓库快速退回到上个commit</span></span><br><span class="line">git reset --hard HEAD^</span><br><span class="line"><span class="comment"># 本地仓库快速退回到上上个commit</span></span><br><span class="line">git reset --hard HEAD^^</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者本地仓库直接去掉某个commit，</span></span><br><span class="line"><span class="comment"># 实质是新建了一个与原来完全相反的commit，抵消了原来commit的效果</span></span><br><span class="line">git revert &lt;commit-hash&gt;</span><br></pre></td></tr></table></figure><p>已推送（即 <code>git push</code> 命令之后），本地仓库文件已同步到远程仓库，你说你手速咋这么快？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地仓库退回到某一个commit</span></span><br><span class="line">git reset --hard &lt;commit-hash&gt;</span><br><span class="line"><span class="comment"># 用本地仓库强制覆盖远程仓库，origin为远程仓库，master为远程仓库分支</span></span><br><span class="line">git push --force origin master</span><br></pre></td></tr></table></figure><p>一些常见情况可以不用撤销更改就能解决:</p><ol><li><p><code>git commit</code> 后发现之前 <code>git add</code> 的文件少了:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接添加上次 `git commit` 缺少的文件到暂存区</span></span><br><span class="line">git add &lt;file-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此命令会将暂存区中的文件提交，</span></span><br><span class="line"><span class="comment"># 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），</span></span><br><span class="line"><span class="comment"># 那么快照会保持不变，而你所修改的只是提交信息</span></span><br><span class="line"><span class="comment"># 最终你只会有一个提交 - 第二次提交将代替第一次提交的结果。</span></span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure></li><li><p>刚刚 <code>git commit</code> 的信息写错了:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改commit信息，最终你只会有一个提交 - 第二次提交将代替第一次提交的结果。</span></span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="分支的管理"><a href="#分支的管理" class="headerlink" title="分支的管理"></a>分支的管理</h2><p>使用 <code>Git</code> 管理的项目通常都使用分支开发工作流。</p><p>新建仓库后，<code>Git</code> 默认生成的 <code>master</code> 分支常常被作为长期分支，只在 <code>master</code> 分支上保留完全稳定的代码，也有可能仅仅是已经发布或即将发布的代码。</p><p>除了 <code>master</code> 这样的长期分支外还有一些名为 <code>develop</code> 或者 <code>next</code> 的长期分支，被用来做后续开发或者测试稳定性，这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 master 分支。</p><p>还有一类特性分支，只是短期存在，被用来实现单一特性或者解决某一问题。在完成特定任务后合并入主干分支就可以删除掉它们了。</p><p>新建分支并切换:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最初始的时候工作区处在 master 分支</span></span><br><span class="line"><span class="comment"># 新建分支</span></span><br><span class="line">git branch &lt;branch_name&gt;</span><br><span class="line"><span class="comment"># 工作区切换到新分支</span></span><br><span class="line">git checkout &lt;branch_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者可以合并上述两条命令</span></span><br><span class="line">git checkout -b &lt;branch_name&gt;</span><br><span class="line"><span class="comment"># Switched to a new branch "branch_name"</span></span><br></pre></td></tr></table></figure><p>完成分支上的工作，测试通过并提交了，接下来打算将该分支合并到主干分支，但在这之前还有件事要考虑。</p><p>由于项目参与的人数过多，每个人都自己新建分支工作，那么分支数目也就多，可能完成自己分支的工作后，其他项目参与者已经往远程仓库的 <code>master</code> 提交了很多代码，这时需要先拉取最新的代码才能做之后的分支合并的工作:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抓取远程仓库 master 分支的改变</span></span><br><span class="line">git fetch &lt;remote-name&gt; master</span><br><span class="line"><span class="comment"># 合并远程仓库的 master 到本地仓库的 master</span></span><br><span class="line">git merge &lt;remote-name&gt;/master master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并 feature_test 分支的工作到本地仓库的 master 主分支中</span></span><br><span class="line">git merge feature_test master</span><br></pre></td></tr></table></figure><p>由于拉取的最新代码中可能有多人修改了自己分支中涉及到的文件，这可能会产生合并冲突，此时就需要人工干预修复冲突内容再合并。</p><p>最终完成工作的分支合并回本地的 <code>master</code> 分支后，就可以删除该新建分支，并推送本地仓库的 <code>master</code> 分支到远程仓库的 <code>master</code> 分支了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在删除分支前，我建议先看下当前已合并和未合并合并的分支</span></span><br><span class="line"><span class="comment"># 查看当前已经合并的分支，被合并的分支通常就可以直接删除了</span></span><br><span class="line">git branch --merged</span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">git branch -d &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前还未合并的分支，这类因为还未被合并，删除时需要考虑再三</span></span><br><span class="line">git branch --no-merged</span><br><span class="line"><span class="comment"># 未被合并的分支只能使用强制删除</span></span><br><span class="line">git branch -D &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送本地仓库 master 分支到远程仓库 master 分支</span></span><br><span class="line">git push &lt;remote-name&gt; master</span><br></pre></td></tr></table></figure><p>上面提及到的新建分支都是在本地仓库中操作的，但实际开发过程常常也需要将新建分支推送到远程仓库。</p><p>还是以上面 <code>远程仓库的关联和管理</code> 部分提到的给 <code>Github</code> 开源项目贡献代码的栗子来讨论。</p><p>咱个人通常都是新建分支，在该分支上完成编码任务，推送到 <code>fork</code> 仓库，然后提出 <code>PR</code> 的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line"><span class="comment"># myforkhttps://github.com/your_name/project.git (fetch)</span></span><br><span class="line"><span class="comment"># myfork        https://github.com/your_name/project.git (push)</span></span><br><span class="line"><span class="comment"># upstreamhttps://github.com/project_owner/project.git (fetch)</span></span><br><span class="line"><span class="comment"># upstreamhttps://github.com/project_owner/project.git (push)</span></span><br><span class="line"></span><br><span class="line">git branch fix_bugs</span><br><span class="line">git checkout fix_bugs</span><br><span class="line"><span class="comment"># Some commits...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送 fix_bugs 分支到 fork 仓库</span></span><br><span class="line">git push myfork fix_bugs</span><br><span class="line"><span class="comment"># 然后在 fork 仓库页面点击 Pull Request，</span></span><br><span class="line"><span class="comment"># 通常还需要根据 CONTRIBUTE 文档编写相关说明，</span></span><br><span class="line"><span class="comment"># 等待开源项目的负责人 review 代码并合并到上游仓库的主分支中。</span></span><br></pre></td></tr></table></figure><p>在提出 <code>PR</code> 和合并 <code>PR</code> 之间可能上游仓库有新代码的提交，你可以按照 <code>远程仓库的关联和管理</code> 部分提到的，将上游仓库的最新提交更新到 <code>fork</code> 仓库，或者直接在 <code>Github</code> 的该 <code>PR</code> 页面一键解决（个人推荐）。</p><p><strong>注意的坑</strong>: <code>PR</code> 的提出一般都会有 <code>CI/CD</code> 工具的帮助，若贡献的开源项目中使用到 <code>Jenkins</code> 时，新建分支的名字不要有 <code>#</code> 之类的特殊字符，这会导致 <code>Jenkins</code> 无法成功通过。</p><hr><h2 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h2><p>当配置Git时，加上<code>--global</code>选项是作用于当前用户，如果不加，那只针对当前的仓库起作用。</p><p>当前用户的Git配置文件位于 <code>/home/user/.gitconfig</code>.</p><p>当前仓库的Git配置文件位于 <code>/path/to/git-repo/.git/config</code>.</p><p>My <code>.gitconfig</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">name = koushiro</span><br><span class="line">email = koushiro.cqx@gmail.com</span><br><span class="line">[<span class="built_in">alias</span>]</span><br><span class="line">lg = <span class="built_in">log</span> --all --graph --pretty=format:<span class="string">'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'</span> --abbrev-commit --date=relative</span><br></pre></td></tr></table></figure><hr><h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><p>My custom log format:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.lg <span class="built_in">log</span> --all --graph --pretty=format:<span class="string">'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'</span> --abbrev-commit --date=relative</span><br></pre></td></tr></table></figure><p>Other helpful options:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git lg -2        <span class="comment"># shows only the last two entries.</span></span><br><span class="line">git lg -p        <span class="comment"># shows the difference (the patch output) introduced in each commit.</span></span><br><span class="line">git lg --<span class="built_in">stat</span>    <span class="comment"># shows some abbreviated stats for each commit.</span></span><br><span class="line">git lg --oneline <span class="comment"># shorthand for --pretty=oneline --abbrev-commit.</span></span><br></pre></td></tr></table></figure><hr><h2 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h2><p>标签一般用来标记发布节点（v1.0 等等）。</p><p>列出标签:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># v1.0.0</span></span><br><span class="line"><span class="comment"># v1.0.1</span></span><br><span class="line"><span class="comment"># v1.0.2</span></span><br><span class="line"><span class="comment"># v1.1.0</span></span><br><span class="line"><span class="comment"># v1.2.0</span></span><br><span class="line"><span class="comment"># v1.3.0</span></span><br></pre></td></tr></table></figure><p><code>Git</code> 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。</p><ul><li><p>附注标签（annotated）</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 -a 选项创建 附注标签</span></span><br><span class="line">git tag -a v1.4.0 -m <span class="string">'my version 1.4.0'</span></span><br><span class="line"></span><br><span class="line">git tag</span><br><span class="line"><span class="comment"># v1.0.0</span></span><br><span class="line"><span class="comment"># v1.0.1</span></span><br><span class="line"><span class="comment"># v1.0.2</span></span><br><span class="line"><span class="comment"># v1.1.0</span></span><br><span class="line"><span class="comment"># v1.2.0</span></span><br><span class="line"><span class="comment"># v1.3.0</span></span><br><span class="line"><span class="comment"># v1.4.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看到标签信息与对应的提交信息</span></span><br><span class="line">git show v1.4.0</span><br><span class="line"><span class="comment"># tag v1.4.0</span></span><br><span class="line"><span class="comment"># Tagger: koushiro &lt;koushiro.cqx@gmail.com&gt;</span></span><br><span class="line"><span class="comment"># Date:   Sun Sep 23 01:16:39 2018 +0800</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># my version 1.4.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># commit 34115da0eb65d4e267c59b1a783c09e2e621db93...</span></span><br></pre></td></tr></table></figure></li><li><p>轻量标签（lightweight）</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 轻量标签本质上是将提交校验和存储到一个文件中 - 没有保存任何其他信息。 </span></span><br><span class="line"><span class="comment"># 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字</span></span><br><span class="line">git tag v1.4.0-lw</span><br><span class="line"></span><br><span class="line">git tag</span><br><span class="line"><span class="comment"># v1.0.0</span></span><br><span class="line"><span class="comment"># v1.0.1</span></span><br><span class="line"><span class="comment"># v1.0.2</span></span><br><span class="line"><span class="comment"># v1.1.0</span></span><br><span class="line"><span class="comment"># v1.2.0</span></span><br><span class="line"><span class="comment"># v1.3.0</span></span><br><span class="line"><span class="comment"># v1.4.0</span></span><br><span class="line"><span class="comment"># v1.4.0-lw</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不会看到额外的标签信息，只会显示出提交信息</span></span><br><span class="line">git show v1.4.0-lw</span><br><span class="line"><span class="comment"># commit 34115da0eb65d4e267c59b1a783c09e2e621db93...</span></span><br></pre></td></tr></table></figure></li></ul><p>除了对当前最新的提交打上标签，也可以对过去的提交打标签。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.2.1 -m <span class="string">"my version 1.2.1"</span> &lt;<span class="built_in">hash</span>-code&gt;</span><br></pre></td></tr></table></figure><p>默认情况下，<code>git push</code> 命令并不会推送标签到远程仓库中， 因此在创建完标签后必须显式地推送标签到远程仓库中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;remote-name&gt; &lt;tag-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一次性推送很多标签，可以使用带有 --tags 选项，</span></span><br><span class="line"><span class="comment"># 这会把所有不在远程仓库里的标签全部传送到那里。</span></span><br><span class="line">git push &lt;remote-name&gt; --tags</span><br></pre></td></tr></table></figure><p>标签的检出和删除类似于分支:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检出 v1.3.0 标签指定的版本节点到工作区</span></span><br><span class="line">git checkout v1.3.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在特定的标签上创建一个新分支，</span></span><br><span class="line"><span class="comment"># 如果在这之后又进行了提交，新分支会因为改动向前移动，</span></span><br><span class="line"><span class="comment"># 那么新分支就会和 v1.3.0 标签稍微有些不同，这时就应该当心</span></span><br><span class="line">git checkout -b &lt;branch-name&gt; v1.3.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除特定标签</span></span><br><span class="line">git tag -d v1.4.0-lw</span><br></pre></td></tr></table></figure><hr><h2 id="合并多个commit"><a href="#合并多个commit" class="headerlink" title="合并多个commit"></a>合并多个commit</h2><p>在实际开发中，一般有 <code>master</code> (功能稳定的分支) 和 <code>develop</code> (正在开发的分支， 或者属于自己的fork仓库)。</p><p>在 <code>develop</code> 分支(或者fork仓库)中常常会有对某几个特定文件琐碎的 <code>commit</code> 记录，为了 <code>commit</code> 记录的整洁，往往需要将这些琐碎记录整合为一个 <code>commit</code>。</p><p>假设有 3 个 <code>commit</code> 记录:</p><p><img src="git-log-origin.png" alt=""></p><p>需要将 <code>913d903</code> 和 <code>eca4dfe</code> 记录合并为一个 <code>commit</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -i 参数是不需要合并的 commit 的 hash 值，这里指的是 `Add README` 那条 commit</span></span><br><span class="line"><span class="comment"># 然后进入编辑模式</span></span><br><span class="line">git rebase -i 07f4138</span><br></pre></td></tr></table></figure><p><img src="rebase-i-origin.png" alt=""></p><p>很明显，上方未注释的是要执行的命令，下方是命令的说明，要是看不懂这种程度的英文那我也没办法。</p><p>直接修改 <code>eca4dfe</code> 前的命令为 <code>squash</code>, 使其被合并到前一个 <code>commit</code>，然后输入<code>:wq</code> 保存并退出:</p><p><img src="rebase-i-modified.png" alt=""></p><p>进入 <code>commit message</code> 的编辑界面:</p><p><img src="commit-message-origin.png" alt=""></p><p>将这两次 <code>commit message</code> 修改为新的 <code>commit message</code>，然后输入 <code>:wq</code> 保存并退出:</p><p><img src="commit-message-modified.png" alt=""></p><p>再次输入 <code>git log</code> 查看，发现这两个 <code>commit</code> 记录已经合并未一个了:</p><p><img src="git-log-modified.png" alt=""></p><p>然后可以将其强制推送到远程仓库 <code>develop</code> 分支或者远程 <code>fork</code> 仓库的特定分支中:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin develop -f</span><br></pre></td></tr></table></figure><p>如果本次修改的代码达到稳定，就可以将 <code>develop</code> 分支的 <code>commit</code> 合并入 <code>master</code> 分支或者通过 <code>PR</code> 合并入 <code>fork</code> 仓库的上游仓库。</p><h1 id="Updating…"><a href="#Updating…" class="headerlink" title="Updating…"></a>Updating…</h1>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;This blog records how Git is used and some of the problems I encountered while using Git.&lt;/center&gt;
    
    </summary>
    
      <category term="Git" scheme="http://koushiro.me/categories/Git/"/>
    
    
      <category term="tech" scheme="http://koushiro.me/tags/tech/"/>
    
      <category term="Github" scheme="http://koushiro.me/tags/Github/"/>
    
      <category term="note" scheme="http://koushiro.me/tags/note/"/>
    
      <category term="Git" scheme="http://koushiro.me/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>The usage of googletest</title>
    <link href="http://koushiro.me/2018/02/10/The-usage-of-googletest/"/>
    <id>http://koushiro.me/2018/02/10/The-usage-of-googletest/</id>
    <published>2018-02-10T06:22:06.000Z</published>
    <updated>2018-09-24T10:49:15.882Z</updated>
    
    <content type="html"><![CDATA[<center>记录下 googletest 和 googlemock 框架的使用。</center><a id="more"></a><h1 id="The-usage-of-googletest"><a href="#The-usage-of-googletest" class="headerlink" title="The usage of googletest"></a>The usage of googletest</h1><p><a href="https://github.com/google/googletest/blob/master/googletest/docs/primer.md" target="_blank" rel="noopener">Googletest Primer</a></p><p><a href="https://github.com/google/googletest/blob/master/googletest/docs/advanced.md" target="_blank" rel="noopener">Advanced googletest Topics</a></p><p><a href="https://github.com/google/googletest/blob/master/googlemock/README.md" target="_blank" rel="noopener">Google Mock</a></p><p><a href="https://github.com/google/googletest/blob/master/googlemock/docs/ForDummies.md" target="_blank" rel="noopener">Google Mock for Dummies</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;记录下 googletest 和 googlemock 框架的使用。&lt;/center&gt;
    
    </summary>
    
      <category term="Cpp" scheme="http://koushiro.me/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="http://koushiro.me/tags/Cpp/"/>
    
      <category term="Google" scheme="http://koushiro.me/tags/Google/"/>
    
      <category term="test" scheme="http://koushiro.me/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm-Sort</title>
    <link href="http://koushiro.me/2018/01/11/Algorithm-Sort/"/>
    <id>http://koushiro.me/2018/01/11/Algorithm-Sort/</id>
    <published>2018-01-11T11:27:13.000Z</published>
    <updated>2018-09-22T05:32:14.381Z</updated>
    
    <content type="html"><![CDATA[<center> Implementation of common sorting algorithms. </center><a id="more"></a><h1 id="Algorithm-Sort"><a href="#Algorithm-Sort" class="headerlink" title="Algorithm-Sort"></a>Algorithm-Sort</h1><h2 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Selection-Sort"><a href="#Selection-Sort" class="headerlink" title="Selection Sort"></a>Selection Sort</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="Bubble-Sort"><a href="#Bubble-Sort" class="headerlink" title="Bubble Sort"></a>Bubble Sort</h2><ul><li>Time complexity:<ul><li>Worst-case:   O(n^2) comparions, O(n^2) swaps.</li><li>Best-case:    O(n)   comparions, O(1)   swaps.</li><li>Average-case: O(n^2) comparions, O(n^2) swaps.</li></ul></li><li>Space complexity:<ul><li>Worst-case: O(1) auxiliary.</li></ul></li></ul><h3 id="Version1"><a href="#Version1" class="headerlink" title="Version1"></a>Version1</h3><p>最原始的版本应该是个学CS都应该会写，这里就稍微优化一部分算法，<br>根据某轮排序过程中是否存在元素交换来判断数列是否有序，减少无谓的比较。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; <span class="built_in">array</span>, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    assert(<span class="built_in">array</span>.size() &gt;= len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">bool</span> sorted = <span class="literal">false</span>; sorted = !sorted; --len) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[i] &gt; <span class="built_in">array</span>[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(<span class="built_in">array</span>[i], <span class="built_in">array</span>[i+<span class="number">1</span>]);</span><br><span class="line">                sorted = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Version2"><a href="#Version2" class="headerlink" title="Version2"></a>Version2</h3><p>按照之前代码逻辑，冒泡排序中数列有序区长度与排序轮数是相等的（即都为 i）。<br>但实际上，数列真正有序区长度可能会大于排序轮数，所以可以通过在每轮排序的最后记录下最后一个元素交换的位置（即无序数列的边界，该位置之后就都是有序区），从而再减少无谓的比较。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; <span class="built_in">array</span>， <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    assert(<span class="built_in">array</span>.size() &gt;= len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lastExchangeIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> border = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">bool</span> sorted = <span class="literal">false</span>; sorted = !sorted; --len) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; border; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[i] &gt; <span class="built_in">array</span>[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(<span class="built_in">array</span>[i], <span class="built_in">array</span>[i+<span class="number">1</span>]);</span><br><span class="line">                sorted = <span class="literal">false</span>;</span><br><span class="line">                lastExchangeIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        border = lastExchangeIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Variants-CockTail-Sort"><a href="#Variants-CockTail-Sort" class="headerlink" title="Variants - CockTail Sort"></a>Variants - CockTail Sort</h3><p><code>BubbleSort</code> 在每次循环中都是从左到右比较元素，并进行单向的位置交换；</p><p>其变种 <code>CockTailSort</code> 则是在<strong>每次循环中双向</strong>地比较和交换元素, 提高每次循环的价值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CockTailSort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; <span class="built_in">array</span>, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    assert(<span class="built_in">array</span>.size() &gt;= len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lastRightExchangeIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rightBorder = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> lastLeftExchangeIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> leftBorder = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>（<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">bool</span> isSorted = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j = leftBorder; j &lt; rightBorder; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(<span class="built_in">array</span>[j], <span class="built_in">array</span>[j+<span class="number">1</span>]);</span><br><span class="line">                isSorted = <span class="literal">false</span>;</span><br><span class="line">                lastRightExchangeIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rightBorder = lastRightExchangeIndex;</span><br><span class="line">        <span class="keyword">if</span> (isSorted) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        isSorted = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j = rightBorder; j &gt; leftBorder; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(<span class="built_in">array</span>[j], <span class="built_in">array</span>[j<span class="number">-1</span>]);</span><br><span class="line">                isSorted = <span class="literal">false</span>;</span><br><span class="line">                lastLeftExchangeIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        leftBorder = lastLeftExchangeIndex;</span><br><span class="line">        <span class="keyword">if</span> (isSorted) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h2><ul><li>Time complexity:<ul><li>Worst-case:   O(n^2)</li><li>Best-case:    O(n logn)</li><li>Average-case: O(n logn)</li></ul></li><li>Space complexity:<ul><li>Worst-case: O(n) auxiliary (naive)</li><li>Worse-case: O(logn) auxiliary (Sedgewick 1978)</li></ul></li></ul><h3 id="Recursive-version"><a href="#Recursive-version" class="headerlink" title="Recursive version"></a>Recursive version</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; <span class="built_in">array</span>, <span class="keyword">size_t</span> start, <span class="keyword">size_t</span> end)</span> </span>&#123;</span><br><span class="line">    assert(start &lt;= end);</span><br><span class="line">    <span class="keyword">size_t</span> pivotIndex = Partition(<span class="built_in">array</span>, start, end);</span><br><span class="line">    QuickSort(<span class="built_in">array</span>, start, pivotIndex - <span class="number">1</span>);</span><br><span class="line">    QuickSort(<span class="built_in">array</span>, pivotIndex + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Partition</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; <span class="built_in">array</span>, <span class="keyword">size_t</span> start, <span class="keyword">size_t</span> end)</span> </span>&#123;</span><br><span class="line">    T pivot = <span class="built_in">array</span>[start];</span><br><span class="line">    <span class="keyword">size_t</span> left = start;</span><br><span class="line">    <span class="keyword">size_t</span> right = end;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; <span class="built_in">array</span>[right] &gt; pivot) &#123;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; <span class="built_in">array</span>[left] &lt;= pivot) &#123;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="built_in">std</span>::swap(<span class="built_in">array</span>[left], <span class="built_in">array</span>[right]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::swap(pivot, <span class="built_in">array</span>[left]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Iterative-version"><a href="#Iterative-version" class="headerlink" title="Iterative version"></a>Iterative version</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="Heap-Sort"><a href="#Heap-Sort" class="headerlink" title="Heap Sort"></a>Heap Sort</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt; Implementation of common sorting algorithms. &lt;/center&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://koushiro.me/categories/Algorithm/"/>
    
    
      <category term="tech" scheme="http://koushiro.me/tags/tech/"/>
    
      <category term="algorithm" scheme="http://koushiro.me/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>The goals of 2018</title>
    <link href="http://koushiro.me/2018/01/01/The-goals-of-2018/"/>
    <id>http://koushiro.me/2018/01/01/The-goals-of-2018/</id>
    <published>2018-01-01T14:20:33.000Z</published>
    <updated>2018-09-18T15:25:33.242Z</updated>
    
    <content type="html"><![CDATA[<p>前天在小姨家，小姨提议让我给自己制定一些2018年的目标，正好博客重开并且坚持写下去就是我的新一年的一个小目标，那索性就直接把2018年的目标写到博客里，等到这年结束时，再回头看看这一年的完成情况。</p><a id="more"></a><h1 id="The-goals"><a href="#The-goals" class="headerlink" title="The goals"></a>The goals</h1><p>既然写都要写了，那就分类写得稍微整洁点。</p><h2 id="Learning"><a href="#Learning" class="headerlink" title="Learning"></a>Learning</h2><ol><li><p>通过找一些有趣的idea来巩固自己对C++11之后的标准的理解。<br>ps: 顺便在之后的博客中把先前欠下的《Modern Effective C++》的笔记给补上。具体的项目可以先从一些简单的轮子上手，比如一些 parser 和 CG demo，还能加深些编译原理和图形学的知识。</p></li><li><p>博客有关技术的内容要保持至少一周一更的更新频率。</p></li><li><p>完成初阶 Rust 的学习，并进行 Rust 官方文档里高阶部分的学习。</p></li><li><p>CG的学习，通读 Real-time Rendering 和 PBRT，分别对实时渲染和离线渲染的基础算法有一定的了解。</p></li><li><p>IT 技术书籍和金融理财相关书籍的阅读，一年的预计总数为 20 份（包含中英文和一些系统性的技术文档）。</p></li><li><p>英文听说和写能力的提高，因为我单词量还不错，所以今年内希望达到至少 English native speaker 简单日常使用的水平，具体的计划还需按阶段详细制定，比如阶段性的考核。</p></li></ol><h2 id="Life"><a href="#Life" class="headerlink" title="Life"></a>Life</h2><ol><li><p>健身的频率要从一周2-3次提高到3-4次，并且对每周每次的健身内容做好计划。脑子里现在暂时有一些想法，但具体的计划需要等我先进行一两周的试练再做调整。ps: 短期的目标是在过春节前减重5斤，也就是一个半月内。</p></li><li><p>再结交同学和同事之外的几位好友，可以是技术相关的，也可以是爱好相关的，当然两者都相关是最好不过的，不过我知道这很难。彼女的话我想在换工作环境前是没有任何可能（笑。</p></li><li><p>希望今年能用上一次我前年办的护照23333，顺便坐一下因为恐高而没尝试的飞机（其实是没机会。</p></li><li><p>Deposit 能达到 100K，换工作前和没搞副业前估计是没办法了（笑。</p></li></ol><h2 id="Work"><a href="#Work" class="headerlink" title="Work"></a>Work</h2><ol><li><p>为今年暑假的 leave 和 interview 做好准备，算法题是肯定要刷起来的，还要想好下一份工作的方向，不要盲目选择，对下一家公司也需要做详细的分析。</p></li><li><p>希望下一份工作能找到城西西溪附近的好公司和好岗位，因为还能省下一笔房租2333。</p></li></ol><h1 id="Fighting-后续若有详细计划会继续更新"><a href="#Fighting-后续若有详细计划会继续更新" class="headerlink" title="Fighting~ 后续若有详细计划会继续更新"></a>Fighting~ 后续若有详细计划会继续更新</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前天在小姨家，小姨提议让我给自己制定一些2018年的目标，正好博客重开并且坚持写下去就是我的新一年的一个小目标，那索性就直接把2018年的目标写到博客里，等到这年结束时，再回头看看这一年的完成情况。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://koushiro.me/categories/Life/"/>
    
    
      <category term="life" scheme="http://koushiro.me/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Deploy gogs step by step</title>
    <link href="http://koushiro.me/2018/01/01/Deploy-gogs-step-by-step/"/>
    <id>http://koushiro.me/2018/01/01/Deploy-gogs-step-by-step/</id>
    <published>2018-01-01T14:08:27.000Z</published>
    <updated>2018-09-18T15:45:33.017Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/01/01/Deploy-gogs-step-by-step/gogs-large-resize.png"><a id="more"></a><h2 id="Gogs"><a href="#Gogs" class="headerlink" title="Gogs"></a>Gogs</h2><p>就像 Gogs 项目的<a href="https://github.com/gogits/gogs/blob/master/README_ZH.md" target="_blank" rel="noopener">README</a>里所说，Gogs是一个简单的私人自助Git服务，由Golang编写，理论上来说支持所有Golang所支持的平台。</p><p>你可能要问不是有 Github 可以用么？Github 好是好，但毕竟私人仓库是要收费的，而且有些垃圾代码实在不适合放到 Github 上污染民那桑的眼睛，所以就用自己的服务器搭建一个私人 Git 托管服务。</p><h2 id="Step1-Download-Gogs-from-Github"><a href="#Step1-Download-Gogs-from-Github" class="headerlink" title="Step1. Download Gogs from Github"></a>Step1. Download Gogs from Github</h2><p>根据<a href="https://gogs.io/docs/installation/install_from_binary" target="_blank" rel="noopener">官方文档</a>，下载分为二进制/源码/包管理，服务器我这里使用的是 Vultr 的 Cloud Instance，系统是 Ubuntu16.04。由于包管理只支持 Ubuntu12.04/14.04，而且包管理均为第三方提供，所以我就跳过源码编译直接用二进制安装（当然用 Archlinux 的也可以直接用 AUR 源进行安装），总之分系统类型进行，我个人比较推荐新手直接用部署更为方便的二进制，若之后想更新Gogs二进制，官方文档也提供了如何升级二进制的教程：</p><ol><li>下载最新版的压缩包</li><li>删除当前的 templates 目录。</li><li>解压压缩包并将所有内容复制粘贴到相应（当前）的位置。</li></ol><p>废话不多说，直接 wget 下载链接， 然后解压：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.gogs.io/0.11.34/linux_amd64.zip</span><br><span class="line">unzip linux_amd64.zip</span><br></pre></td></tr></table></figure><p>目录如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@Ubuntu16:~/gogs# ls -l</span><br><span class="line">total 31384</span><br><span class="line">drwxr-xr-x  3 root root     4096 Dec 23 15:30 custom</span><br><span class="line">drwx------  4 root root     4096 Dec 23 15:59 data</span><br><span class="line">-rwxr-xr-x  1 root root 32091291 Nov 22 20:01 gogs</span><br><span class="line">-rw-r--r--  1 root root     1054 Feb 11  2017 LICENSE</span><br><span class="line">drwxr-xr-x  2 root root     4096 Jan  1 00:07 log</span><br><span class="line">drwxr-xr-x  8 root root     4096 Nov 22 20:01 public</span><br><span class="line">-rw-r--r--  1 root root     8032 Nov 22 20:01 README.md</span><br><span class="line">-rw-r--r--  1 root root     5329 Nov 19 18:54 README_ZH.md</span><br><span class="line">drwxr-xr-x  7 root root     4096 Nov 22 20:01 scripts</span><br><span class="line">drwxr-xr-x 11 root root     4096 Nov 22 20:01 templates</span><br></pre></td></tr></table></figure><h2 id="Step2-Deploy-Gogs"><a href="#Step2-Deploy-Gogs" class="headerlink" title="Step2. Deploy Gogs"></a>Step2. Deploy Gogs</h2><p>直接后台运行gogs二进制：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gogs web &amp;&amp;</span><br></pre></td></tr></table></figure><p>运行成功后，浏览器首次进入 <code>localhost:3000/</code> 会跳转到 <code>/install</code>，进行首次部署基本配置，比如数据库的选择，账号注册等等，由于我是一个人用，数据库使用 sqlite 绰绰有余。</p><h2 id="Step3-Configuration"><a href="#Step3-Configuration" class="headerlink" title="Step3. Configuration"></a>Step3. Configuration</h2><p>默认配置文件从v0.6.0开始就被嵌入了二进制中，若要进行自定义配置，只需要修改 <code>custom/conf/app.ini</code>，比如 Git仓库根目录、数据库配置或者是否支持注册等。</p><p>像我，则是在安装部署和注册账号完成后，禁止了其他人的注册，因为毕竟这只是我个人的 Git 托管服务。若是一个团队协同使用，就不需要关闭注册功能。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">root@Ubuntu16:~/gogs/custom/conf# cat app.ini</span><br><span class="line">APP_NAME = Gogs</span><br><span class="line">RUN_USER = root</span><br><span class="line">RUN_MODE = prod</span><br><span class="line"></span><br><span class="line">[database]</span><br><span class="line">DB_TYPE  = sqlite3</span><br><span class="line"><span class="meta">#</span>...</span><br><span class="line"></span><br><span class="line">[repository]</span><br><span class="line">ROOT = /root/gogs-repositories</span><br><span class="line"></span><br><span class="line">[server]</span><br><span class="line">DOMAIN           = localhost</span><br><span class="line">HTTP_PORT        = 3000</span><br><span class="line">ROOT_URL         = http://localhost:3000/</span><br><span class="line">DISABLE_SSH      = false</span><br><span class="line">SSH_PORT         = 22</span><br><span class="line">START_SSH_SERVER = false</span><br><span class="line">OFFLINE_MODE     = false</span><br><span class="line"></span><br><span class="line">[mailer]</span><br><span class="line">ENABLED = false</span><br><span class="line"></span><br><span class="line">[service]</span><br><span class="line">REGISTER_EMAIL_CONFIRM = false</span><br><span class="line">ENABLE_NOTIFY_MAIL     = false</span><br><span class="line">DISABLE_REGISTRATION   = true</span><br><span class="line">ENABLE_CAPTCHA         = true</span><br><span class="line">REQUIRE_SIGNIN_VIEW    = false</span><br><span class="line"></span><br><span class="line">[picture]</span><br><span class="line">DISABLE_GRAVATAR        = false</span><br><span class="line">ENABLE_FEDERATED_AVATAR = true</span><br><span class="line"></span><br><span class="line">[session]</span><br><span class="line">PROVIDER = file</span><br><span class="line"></span><br><span class="line">[log]</span><br><span class="line">MODE      = file</span><br><span class="line">LEVEL     = Info</span><br><span class="line">ROOT_PATH = /root/gogs/log</span><br></pre></td></tr></table></figure><h2 id="Step4-Forward-port"><a href="#Step4-Forward-port" class="headerlink" title="Step4. Forward port"></a>Step4. Forward port</h2><p>在部署和配置完成后，其实就已经可以很好的使用Gogs的自助Git服务了，但是在浏览器敲ip地址和端口号太麻烦了，所以我就利用我现有的域名，在DNSPOD上再加了一条二级域名解析，直接取个好记的域名 <a href="http://git.koushiro.me" target="_blank" rel="noopener">git.koushiro.me</a>。当然如果你是在狗爹上买的域名并且用得狗爹自己的域名解析，那添加二级域名就更简单了，而且也不需要自己配置端口转发，狗爹的域名解析和跳转支持二级域名直接转发到某个ip地址的端口，但如果你也是和我一样使用DNSPOD来进行域名解析的，那还得多做一步，就是用 nginx 进行 3000 端口的转发。</p><p>这一步实际也很简单：</p><p>通过包管理安装 Nginx：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install nginx  # Debian / Ubuntu</span><br><span class="line">pacman -S nginx    # Archlinux</span><br></pre></td></tr></table></figure><p>安装完成后，nginx 的默认配置在 <code>/etc/nginx/nginx.conf</code> 里</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">        ##</span><br><span class="line">        # Basic Settings</span><br><span class="line">        ##</span><br><span class="line"></span><br><span class="line">        sendfile on;</span><br><span class="line">        tcp_nopush on;</span><br><span class="line">        tcp_nodelay on;</span><br><span class="line">        keepalive_timeout 65;</span><br><span class="line">        types_hash_max_size 2048;</span><br><span class="line">        # server_tokens off;</span><br><span class="line"></span><br><span class="line">        # server_names_hash_bucket_size 64;</span><br><span class="line">        # server_name_in_redirect off;</span><br><span class="line"></span><br><span class="line">        include /etc/nginx/mime.types;</span><br><span class="line">        default_type application/octet-stream;</span><br><span class="line"></span><br><span class="line">        ##</span><br><span class="line">        # SSL Settings</span><br><span class="line">        ##</span><br><span class="line"></span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">        ##</span><br><span class="line">        # Logging Settings</span><br><span class="line">        ##</span><br><span class="line"></span><br><span class="line">        access_log /var/log/nginx/access.log;</span><br><span class="line">        error_log /var/log/nginx/error.log;</span><br><span class="line"></span><br><span class="line">        ##</span><br><span class="line">        # Gzip Settings</span><br><span class="line">        ##</span><br><span class="line"></span><br><span class="line">        gzip on;</span><br><span class="line">        gzip_disable "msie6";</span><br><span class="line"></span><br><span class="line">        # gzip_vary on;</span><br><span class="line">        # gzip_proxied any;</span><br><span class="line">        # gzip_comp_level 6;</span><br><span class="line">        # gzip_buffers 16 8k;</span><br><span class="line">        # gzip_http_version 1.1;</span><br><span class="line">        # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;</span><br><span class="line"></span><br><span class="line">        ##</span><br><span class="line">        # Virtual Host Configs</span><br><span class="line">        ##</span><br><span class="line"></span><br><span class="line">        include /etc/nginx/conf.d/*.conf;</span><br><span class="line">        include /etc/nginx/sites-enabled/*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到最后的 <code>Virtual Host Configs</code> 里的 include， 显而易见，我们只需要在 <code>/etc/nginx/conf.d</code> 新建一个配置文件，然后 reload nginx 服务，就能完成端口转发。 这里我根据我的域名新建一个配置文件 <code>git.koushiro.me.conf</code>，内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name git.koushiro.me</span><br><span class="line">    listen 80;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:3000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我将 git.koushiro.me 的 80 端口请求转发到服务器本地的 3000 端口，也就是 Gogs 服务的默认端口。</p><p>OK~ DONE~</p><blockquote><p>PS: 快一年多没写博客了，也正好趁 2018 年的到来，重拾博客，记录些学习和生活，本想继续写篇博客记录下自己一些 2018 年的目标，但时间也不早了，明天还得上班糊代码，那2018目标的那篇博客就放到明天写好了，顺便给自己多一天时间仔细想想，也希望新的一年我能好好完成自己将要定下的目标。 </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/01/01/Deploy-gogs-step-by-step/gogs-large-resize.png&quot;&gt;
    
    </summary>
    
      <category term="Configuration" scheme="http://koushiro.me/categories/Configuration/"/>
    
    
      <category term="tech" scheme="http://koushiro.me/tags/tech/"/>
    
      <category term="config" scheme="http://koushiro.me/tags/config/"/>
    
      <category term="Gogs" scheme="http://koushiro.me/tags/Gogs/"/>
    
  </entry>
  
  <entry>
    <title>The Note3 of Effective C++</title>
    <link href="http://koushiro.me/2017/02/11/Effective-Cpp-Note3/"/>
    <id>http://koushiro.me/2017/02/11/Effective-Cpp-Note3/</id>
    <published>2017-02-11T06:27:39.000Z</published>
    <updated>2018-09-22T17:58:14.033Z</updated>
    
    <content type="html"><![CDATA[<p>书中第三部分是讲资源管理（Resource Management），只有不足20页，尽管不是专门讲动态内存（dynamical memory）和智能指针（smart pointer），但还是占较大篇幅的，我会结合 C++11 新标准对其进行一些扩充。今日も顽张りましょう。</p><a id="more"></a><blockquote><p>Tips : 我会在 C++11/14 标准的基础上作笔记 (Effective C++, 3rd Edition 中的内容并不是按照 C++11/14 标准）</p></blockquote><h1 id="Resourse-Management"><a href="#Resourse-Management" class="headerlink" title="Resourse Management"></a>Resourse Management</h1><h2 id="Item-13-以对象管理资源"><a href="#Item-13-以对象管理资源" class="headerlink" title="Item 13 : 以对象管理资源"></a>Item 13 : 以对象管理资源</h2><blockquote><p>Use objects to manage resourses</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object* <span class="title">factory</span><span class="params">(T arg)</span>      <span class="comment">// factory 返回指针，指向动态分配的对象</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Object(arg); <span class="comment">// 调用者负责释放此内存</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_factory</span><span class="params">(T arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 由内置指针（非智能指针）管理的动态内存在被显式释放前一直都会存在</span></span><br><span class="line">    Object* p = factory(arg);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在某些情况下，<code>use_factory</code> 可能无法删除从 <code>factory</code> 得到的资源对象【这是在实际中很容易放的错】——或许因为 “…” 区域内过早的一个 <code>return</code>；有或者 “…” 区域内的语句抛出异常。无论 <code>delete</code> 如何被忽略过去，泄露的不仅仅是内含 <code>Object</code> 对象的那块内存，还包括对象所保存的任何资源。</p><p>使用 <code>new</code> 和 <code>delete</code> 管理动态内存资源的三个常见问题：</p><ol><li>忘记 <code>delete</code> 内存。（例子中可能存在的问题）</li><li>使用已经释放掉的对象。</li><li>同一块内存释放两次。</li></ol><p>因此<strong>为确保内存等资源总是被释放，需要将资源放进对象</strong>。实际上这正是本条款背后的半边想法：把资源放进对象内，依赖 C++ 的 “析构函数自动调用机制” 确保资源被释放。（另半边想法之后讨论）</p><p>许多资源被动态分配于 <code>heap</code> 内而后被使用于某个作用域（除了静态内存和栈内存，每个程序还有一个内存池，被称为 <code>free store</code> 或 <code>heap</code>，程序用其来存储动态分配的对象，即运行时分配的对象），它们应该在离开该作用域时被释放。C++ 标准库提供了一类智能指针 <code>unique_ptr</code>，智能指针是个“类指针（pointer-like）”对象，其析构函数自动对其所指对象调用 <code>delete</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Object&gt; pObject(factory());     <span class="comment">// 为简洁，factory 中不加实参</span></span><br><span class="line">    ...</span><br><span class="line">&#125;   <span class="comment">// 经由 unique_ptr 的析构函数自动删除 pObject</span></span><br></pre></td></tr></table></figure><p>这个例子展示了 “以对象管理资源” 的两个关键想法：</p><ul><li><p><strong>获得资源后立即放进管理对象（managing object）内</strong>。实际上 “以对象管理资源” 的观念常被称为 <strong>“资源取得时便是初始化时机（Resource Acquisition Is Initialization，RAII）”</strong>，因为实际中几乎总是在获得一笔资源后于同一语句内以该资源初始化某个管理对象。</p></li><li><p><strong>管理对象（managing object）运用析构函数确保资源被释放</strong>。一旦对象被销毁（例如对象离开当前作用域），其析构函数会被自动调用以释放资源。如果使用内置指针管理内存，资源释放前（<code>delete</code>前）抛出异常且未被 <code>catch</code>，这种情况可能会有点麻烦，直接管理的内存是不会自动释放的，但使用智能指针就不存在这样的问题。</p></li></ul><h3 id="unique-ptr-类"><a href="#unique-ptr-类" class="headerlink" title="unique_ptr 类"></a>unique_ptr 类</h3><p><strong>注意事项</strong>：</p><ol><li>一个 <code>unique_ptr</code> “拥有” 它所指的对象，也就是说，<strong>某个时刻只能有一个 <code>unique_ptr</code> 指向一个给定对象</strong>【不然怎么叫 <code>unique</code> →_→. </li><li><strong>定义一个 <code>unique_ptr</code> 时，需要将其绑定到一个 <code>new</code> 返回的指针上</strong>【不像 <code>shared_ptr</code>，它没有类似 <code>make_shared</code> 的标准库函数返回一个 <code>unique_ptr</code>，后面会提】；而<strong>初始化 <code>unique_ptr</code> 必须采用直接初始化形式</strong>。</li><li>由于 <code>unique_ptr</code> 拥有它所指对象，因此 <strong><code>unique_ptr</code> 不支持普通拷贝和赋值操作</strong>。<strong>但可通过调用 <code>release</code> 或 <code>reset</code> 将指针的所有权从一个（非<code>const</code>）<code>unique_ptr</code> 转移给另一个 <code>unique</code></strong>。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p1(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Hello"</span>));     <span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p2(p1);                      <span class="comment">// 错误：unique_ptr 不支持 拷贝</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p3;</span><br><span class="line">p3 = p2;                                        <span class="comment">// 错误：unique_ptr 不支持 赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ==========================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将所有权从 p1 转移到 p2</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p1(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Hello"</span>));</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p2(p1.release());            <span class="comment">// release 将 p1 置为空</span></span><br><span class="line"><span class="comment">// 将所有权从 p3 转移到 p2</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p3(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"World"</span>));</span><br><span class="line">p2.reset(p3.release());                         <span class="comment">// reset 释放了 p2 原来指向的内存</span></span><br></pre></td></tr></table></figure></li></ol><p>由于 <code>unique_ptr</code> 不支持普通的拷贝和赋值操作，也就意味着 <code>unique_ptr</code> 并非动态分配资源的利器。举个例子，STL 容器要求其元素发挥“正常的” 拷贝行为，因此这些容器不能使用 <code>unique_ptr</code>。</p><h3 id="shared-ptr-类"><a href="#shared-ptr-类" class="headerlink" title="shared_ptr 类"></a>shared_ptr 类</h3><p><code>unique_ptr</code> 的替换方案是 <strong>“引用计数型智能指针” （reference-counting smart pointer，RCSP）</strong>。<code>RCSP</code> 提供的行为类似 垃圾回收（garbage collection），它持续追踪记录指向某笔资源的对象个数，并在无人指向它时自动删除该资源，不同的是 <code>RCSP</code> 无法打破 “环状引用”（cycles of reference，例如两个其实已经没被使用的对象彼此互指，因此好像还处在“被使用”的状态）。</p><p>标准库中的 <code>shared_ptr</code> 就是个 <code>RCSP</code>，由于其拷贝行为相比 <code>unique_ptr</code> 显得更”正常”，可被用于 STL 容器以及其他 <code>unique_ptr</code> 不适用的地方。</p><p><strong>注意事项</strong>：</p><ol><li><p><strong>最安全的分配和使用动态内存的方法是调用名为 <code>make_shared</code> 的标准库函数</strong>。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的 <code>shared_ptr</code>。之所以推荐 <code>make_shared</code> 而不是 <code>new</code> 是因为能在分配对象的同时就将 <code>shared_ptr</code> 与之绑定，从而避免无意中将同一块内存绑定到多个独立创建的 <code>shared_ptr</code> 上。【该函数也被定义在头文件 <code>memory</code> 中】</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指向值为 666 的 int 的 shared_ptr</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; pInt = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">666</span>);</span><br><span class="line"><span class="comment">// 指向值为 “666” 的 string</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; pString = make_shared&lt;<span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">'6'</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>shared_ptr</code> 通过析构函数完成对象销毁和和内存释放的自动化，<strong>其析构函数会递减它所指的对象的引用计数，如果引用计数变为 0，<code>shared_ptr</code> 的析构函数就会销毁对象，并释放它所占的内存</strong>。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">123</span>); <span class="comment">// p 指向的对象只有 p 一个引用者</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; q(p);                      <span class="comment">// p 和 q 指向相同对象，此对象有两个引用者</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; r = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">666</span>); <span class="comment">// r 指向的 int 只有一个引用者</span></span><br><span class="line">r = q;                                    <span class="comment">// 给 r 赋值，令它指向另一个地址</span></span><br><span class="line">                                          <span class="comment">// 递增 q 指向对象的引用计数，递减 r 原来指向对象的引用计数</span></span><br><span class="line">                                          <span class="comment">// r 原来指向的对象已没有引用者，会自动释放</span></span><br></pre></td></tr></table></figure></li></ol><p>虽说写了这么多关于 <code>unique_ptr</code> 和 <code>shared_ptr</code> 的东西，但本条款真正强调的是 “以对象管理资源” 的重要性，<code>unique_ptr</code> 和 <code>shared_ptr</code> 只是实际例子。</p><h3 id="扩展（智能指针支持的操作）"><a href="#扩展（智能指针支持的操作）" class="headerlink" title="扩展（智能指针支持的操作）"></a>扩展（智能指针支持的操作）</h3><table><thead><tr><th style="text-align:left"><code>shared_ptr</code> 和 <code>unique_ptr</code> 都支持的操作</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">shared_ptr<code>&lt;T&gt;</code> sp</td><td style="text-align:left">空智能指针，可以指向类型为 T 的对象</td></tr><tr><td style="text-align:left">unique_ptr<code>&lt;T&gt;</code> up</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">将 p 用作一个条件判断，若 p 指向一个对象，则为 true</td></tr><tr><td style="text-align:left">*p</td><td style="text-align:left">解引用 p，获得它指向的对象</td></tr><tr><td style="text-align:left">p-&gt;mem</td><td style="text-align:left">等价于 (*p).mem</td></tr><tr><td style="text-align:left">p.get()</td><td style="text-align:left">返回 p 中保存的指针。若智能指针释放了其对象，<code>get()</code> 返回的指针所指向的对象也就消失，因此不要 <code>delete get()</code> 返回的指针，这会导致同个资源被多次释放</td></tr><tr><td style="text-align:left">swap(p,q)</td><td style="text-align:left">交换 p 和 q 中的指针</td></tr><tr><td style="text-align:left">p.swap(q)</td></tr></tbody></table><table><thead><tr><th style="text-align:left"><code>shared_ptr</code> 独有的操作</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">make_shared<code>&lt;T&gt;</code>(args)</td><td style="text-align:left">返回一个 shared_ptr，指向一个动态分配的类型为 T 的对象，使用 args 初始化此对象</td></tr><tr><td style="text-align:left">shared_ptr<code>&lt;T&gt;</code> p(q)</td><td style="text-align:left">p 是 shared_ptr q 的拷贝；此操作会递增 q 中的计数器，q 中的指针必须能转换为 T*</td></tr><tr><td style="text-align:left">p = q</td><td style="text-align:left">p 和 q 都是 shared_ptr，所保存的指针必须能相互转换；此操作会递减 p 的引用计数，递增 q 的引用计数，若 p 的引用计数为 0，则将其管理的原内存释放</td></tr><tr><td style="text-align:left">p.unique()</td><td style="text-align:left">若 p.use_count() 为 1，返回 true；否则返回 false</td></tr><tr><td style="text-align:left">p.use_count()</td><td style="text-align:left">返回与 p 共享对象的智能指针数量；可能很慢，主要用于调试</td></tr></tbody></table><table><thead><tr><th style="text-align:left"><code>unique_ptr</code> 独有的操作</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">unique_ptr<code>&lt;T&gt;</code> u1</td><td style="text-align:left">空 unique_ptr，可以指向类型为 T 的对象，u1 会用 delete 来释放它的指针；</td></tr><tr><td style="text-align:left">unique_ptr<code>&lt;T, U&gt;</code> u2</td><td style="text-align:left">u2 会使用一个类型为 D 的可调用对象（即删除器）来释放它的指针</td></tr><tr><td style="text-align:left">unique_ptr<code>&lt;T, U&gt;</code> u(d)</td><td style="text-align:left">空 unique_ptr，指向类型为 T 的对象，用类型为 D 的对象 d 代替 delete</td></tr><tr><td style="text-align:left">u = nullptr</td><td style="text-align:left">释放 u 指向的对象，将 u 置为空</td></tr><tr><td style="text-align:left">u.release()</td><td style="text-align:left">u 放弃对指针的控制权，返回指针，并将 u 置为空</td></tr><tr><td style="text-align:left">u.reset()</td><td style="text-align:left">释放 u 指向的对象</td></tr><tr><td style="text-align:left">u.reset(q)</td><td style="text-align:left">如果提供了内置指针 q，令 u 指向这个对象；否则将 u 置为空</td></tr><tr><td style="text-align:left">u.reset(nullptr)</td></tr></tbody></table><table><thead><tr><th style="text-align:left">定义和改变 <code>shared_ptr</code> 的其他方法</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">shared_ptr<code>&lt;T&gt;</code> p(q)</td><td style="text-align:left">p 管理内置指针 q 所指向的对象；q 必须指向 new 分配的内存，且能转换为 T* 类型</td></tr><tr><td style="text-align:left">shared_ptr<code>&lt;T&gt;</code> p(u)</td><td style="text-align:left">p 从 unique_ptr u 那里接管了对象的所有权；将 u 置为空</td></tr><tr><td style="text-align:left">shared_ptr<code>&lt;T&gt;</code> p(q, d)</td><td style="text-align:left">p 接管了内置指针 q 所指对象的所有权。q 必须能转换为 T* 类型。p 将使用可调用对象 d 来代替 delete</td></tr><tr><td style="text-align:left">shared_ptr<code>&lt;T&gt;</code> p(p2, d)</td><td style="text-align:left">p 是 shared_ptr p2 的拷贝；唯一的区别是 p 将用可调用对象 d 来代替 delete</td></tr><tr><td style="text-align:left">p.reset()</td><td style="text-align:left">若 p 是唯一指向其对象的 shared_ptr，reset 会释放此对象。</td></tr><tr><td style="text-align:left">p.reset(q)</td><td style="text-align:left">若传递了可选参数内置指针 q ，会令 p 指向 q，否则会将 p 置为空</td></tr><tr><td style="text-align:left">p.reset(q, d)</td><td style="text-align:left">若还传递了参数 d，将会调用 d 而不是 delete 来释放 q</td></tr></tbody></table><p><strong>请记住</strong></p><blockquote><ul><li><strong>为防止资源泄露，请使用 <code>RAII（Resource Acquisition Is Initialization）</code> 对象，这些对象在构造函数获得资源并在析构函数释放资源</strong>。</li><li><strong>常被使用的 <code>RAII class</code> 分别是 <code>shared_ptr</code> 和 <code>unique_ptr</code></strong> （标准库较早版本包含<code>auto_ptr</code>，它有 <code>unique_ptr</code> 的部分特性，虽然它还是标准库的一部分，但不建议使用，编写程序时应该使用 <code>unique_ptr</code>）。此外，标准库还定义了 <code>weak_ptr</code> 的伴随类，它是种弱引用，指向 <code>shared_ptr</code> 管理的对象。这三种类型都定义在 <code>memory</code> 头文件中。</li></ul></blockquote><hr><h2 id="Item-14-在资源管理类中小心-copying-行为"><a href="#Item-14-在资源管理类中小心-copying-行为" class="headerlink" title="Item 14 : 在资源管理类中小心 copying 行为"></a>Item 14 : 在资源管理类中小心 copying 行为</h2><blockquote><p>Think carefully about copying behavior in resourse-managing classes</p></blockquote><p>之前谈论到了 <code>RAII</code> 的概念，也描述了 <code>unique_ptr</code> 和 <code>shared_ptr</code> 如何将这个观念表现在 <code>heap-based</code> 资源上。然而并非所有资源都是 <code>heap-based</code>，对此类资源，像 <code>unique_ptr</code> 和 <code>shared_ptr</code> 这样的智能指针往往不适合作为资源掌控者（resource handler），可能<strong>需要建立自己的资源管理类</strong>。</p><p>既然要建立自己的资源管理类，那肯定要考虑到当一个 <strong><code>RAII</code> 对象被复制时会发生些什么</strong>？这是需要面对的问题，大多数时候会有以下两种选择：</p><ul><li><p><strong>禁止复制</strong>。如果复制动作对 <code>RAII</code> 对象并不合理，便应该禁止之。在 <code>Item 6</code> 中我已经提及过了：可以将 <code>copying</code> 操作声明为 <code>private</code> 但不定义它；或者使用 C++11 引入的 <code>deleted function</code>。 </p></li><li><p><strong>对底层资源用出 “引用计数法（reference-count）”</strong>。有时希望保有资源，直到它最后一个使用者被销毁。这种情况下复制 <code>RAII</code> 对象时，应该将资源的 “被引用数” 递增，<code>shared_ptr</code> 便是如此。但 <code>shared_ptr</code> 的缺省行为是 “当引用次数为0时删除其所指物”，这很有可能不是我们所要的行为，例如使用智能指针管理的资源不是 <code>new</code> 分配的内存。还好 <strong><code>shared_ptr</code> 允许指定 “删除器（deleter）” ——一个函数或函数对象，当引用次数为0时便被调用</strong>。【<code>unique_ptr</code> 也允许指定 “删除器”，但管理 “删除器” 的方式与 <code>shared_ptr</code> 不同】</p><ul><li><strong>复制底部资源</strong>。 需要 “资源管理类” 的唯一理由是：当不再需要某个复件时确保它被释放。在此情况下复制资源管理对象，应该同时也复制其所包含的资源。也就是说，复制资源管理对象时，进行的是 “深度拷贝”。</li><li><strong>转移底部资源的所有权</strong>。某些场合可能会希望永远只有一个 <code>RAII</code> 对象指向一个未加工资源（raw resource），即使 <code>RAII</code> 对象被复制也如此。此时，资源的拥有权会从被复制物转移到目标物。例如 <code>unique_ptr</code> 中的 <code>release</code> 和 <code>reset</code> 操作。</li></ul></li></ul><h3 id="扩展（shared-ptr-和-unique-ptr-的删除器）"><a href="#扩展（shared-ptr-和-unique-ptr-的删除器）" class="headerlink" title="扩展（shared_ptr 和 unique_ptr 的删除器）"></a>扩展（<code>shared_ptr</code> 和 <code>unique_ptr</code> 的删除器）</h3><p><code>shared_ptr</code> 和 <code>unique_ptr</code> 之间明显的不同已经在 <code>Item13</code> 中谈到过了，是它们<strong>管理所保存的指针的策略</strong> —— 前者给予共享指针所有权的能力，后者则独占指针。<br>另一个差异是它们<strong>允许指定用户重载默认删除器的方式</strong>。</p><ul><li><p>重载 <code>shared_ptr</code> 的删除器很容易，<strong>只要创建或 <code>reset</code> 指针时传递给它一个可调用对象即可</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">end_connection</span><span class="params">(connection *p)</span> </span>&#123; disconnect(*p); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(destination &amp;d <span class="comment">/* 其他参数 */</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    connection c = connect(&amp;d); <span class="comment">// 打开连接</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;connection&gt; p(&amp;c, end_connection);</span><br><span class="line">    <span class="comment">// 使用连接</span></span><br><span class="line">    <span class="comment">// 当 f 退出时（即使由于异常而退出），connection 会被正确关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>与之相反，删除器的类型是一个 <code>unique_ptr</code> 对象类型的一部分，<strong>用户必须在定义 <code>unique_ptr</code> 时以显式模板实参的形式提供删除器的类型</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(destination &amp;d <span class="comment">/* 其他参数 */</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    connection c = connect(&amp;d); <span class="comment">// 打开连接</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;connection, <span class="keyword">decltype</span>(end_connection)*&gt; p(&amp;c, end_connection);</span><br><span class="line">    <span class="comment">// 使用连接</span></span><br><span class="line">    <span class="comment">// 当 f 退出时（即使由于异常而退出），connection 会被正确关闭</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// decltype(end_connection) 返回函数类型，</span></span><br><span class="line"><span class="comment">// 必须添加一个 * 来指出我们正在使用该类型的一个指针</span></span><br></pre></td></tr></table></figure></li></ul><p>尽管不知道标准库类型是如何实现的，但可以推断出 <code>shared_ptr</code> 必须能直接访问其删除器，即删除器必须保存为一个指针或一个封装了指针的类。</p><p>可以确定 <code>shared_ptr</code> 不是将删除器直接保存为一个成员的原因，是因为 <code>shared_ptr</code> 重载的删除器类型是直到运行时才会知道的【实际上，在一个 <code>shared_ptr</code> 的生存期内，可以随时改变其删除器的类型】，而通常类成员在运行时是不能改变的，因此，不能将删除器直接保存为一个成员。</p><p>而在 <code>unique_ptr</code> 类中，由于删除器的类型是 <code>unique_ptr</code> 类型的一部分，因此删除器成员的类型在编译时是知道的，从而删除器可以直接保存在 <code>unique_ptr</code> 对象中。</p><p>通过在<strong>编译时绑定删除器</strong>，<strong><code>unique_ptr</code> 避免了间接调用删除器的运行时开销</strong>；通过在<strong>运行时绑定删除器</strong>，<strong><code>shared_ptr</code> 使用户重载删除器更为方便</strong>。</p><p><strong>请记住</strong></p><blockquote><ul><li><strong>复制 <code>RAII</code> 对象必须一并复制它所管理的资源，所以资源的 <code>copying</code> 行为决定 <code>RAII</code> 对象的 <code>copying</code> 行为</strong>。</li><li>普遍而常见的 <code>RAII class copying</code> 行为是：<strong>抑制 <code>copying</code> 行为</strong>、<strong>施行引用计数法（reference counting）</strong>。 </li></ul></blockquote><hr><h2 id="Item-15-在资源管理类中提供对原始资源的访问"><a href="#Item-15-在资源管理类中提供对原始资源的访问" class="headerlink" title="Item 15 : 在资源管理类中提供对原始资源的访问"></a>Item 15 : 在资源管理类中提供对原始资源的访问</h2><blockquote><p>Provide access to raw resourse in resourse-managing classes</p></blockquote><p>实际中许多 API 直接涉及资源，所以除非承诺永不使用这样的 API，否则只得绕过资源管理对象（resource-managing object）直接访问原始资源（raw resource）。</p><p>举个例子，再次使用 <code>Item 13</code> 中的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object* <span class="title">factory</span><span class="params">(T arg)</span>      <span class="comment">// factory 返回指针，指向动态分配的对象</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Object(arg); <span class="comment">// 调用者负责释放此内存</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =====================================================</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Object&gt; pObject(factory());</span><br><span class="line"><span class="comment">// 假如有某个 function 希望处理 Object 对象，如下</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(<span class="keyword">const</span> Object* o)</span></span>;</span><br></pre></td></tr></table></figure></p><p>若想要像下面这么调用 <code>function</code>，是通不过编译的。因为 <code>function</code> 需要的是 <code>Object*</code> 指针，而不是你传给它的类型为 <code>unique_ptr&lt;Object&gt;</code> 的对象。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret = function(pObject);            <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure></p><p>这时候你需要一个函数<strong>可将 <code>RAII class</code> 对象转换为其所内含的原始资源</strong>（本例为 <code>Object*</code>），有两种做法可以做到：</p><ul><li><p><strong>显式转换</strong>：<code>unique_ptr</code> 和 <code>shared_ptr</code> 都提供了一个 <strong><code>get</code> 成员函数</strong>，用来执行显式转换，也就是它会<strong>返回智能指针内部的原始指针（的复件）</strong>：  </p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret = function(pObject.get());</span><br></pre></td></tr></table></figure></li><li><p><strong>隐式转换</strong>：<strong><code>unique_ptr</code> 和 <code>shared_ptr</code> 重载了指针取值（pointer dereference）操作符（<code>operator-&gt;</code> 和 <code>operator*</code>）</strong>，它们允许隐式转换至底部原始指针：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsReal</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Object* <span class="title">factory</span><span class="params">()</span></span>;              <span class="comment">// 为代码简洁，此处省略实参</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;Object&gt; p1(factory());</span><br><span class="line"><span class="keyword">bool</span> ret1 = p1-&gt;IsReal();       <span class="comment">// 经由 operator-&gt; 访问资源</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;Object&gt; p2(factory());</span><br><span class="line"><span class="keyword">bool</span> ret2 = (*p2).IsReal();     <span class="comment">// 经由 operator * 访问资源</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h3 id="扩展（智能指针的一些使用注意事项）"><a href="#扩展（智能指针的一些使用注意事项）" class="headerlink" title="扩展（智能指针的一些使用注意事项）"></a>扩展（智能指针的一些使用注意事项）</h3><p><strong>接受指针参数的智能指针的构造函数是 <code>explicit</code> 的</strong>，因此必须使用直接初始化形式来初始化一个智能指针【当然更推荐使用 <code>make_shared</code> 来初始化 <code>shared_ptr</code>，前面有提及过原因】：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>); <span class="comment">// 错误，必须使用直接初始化形式</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p2(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>));  <span class="comment">// 正确 </span></span><br><span class="line"><span class="comment">// shared_ptr 更推荐用 make_shared 初始化</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p3 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure></p><p>出于相同的原因，一个返回 <code>shared_ptr</code> 的函数不能在其返回语句中隐式转换一个普通指针：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; clone(<span class="keyword">int</span> p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 错误，不能隐式转换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>(p);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; clone(<span class="keyword">int</span> p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 正确，显式地用 int* 创建 shared_ptr&lt;int&gt;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>不要混合使用普通指针和智能指针</strong>，因为当一个 <code>shared_ptr</code> 绑定到一个普通指针时，内存的管理责任就交给了这个 <code>shared_ptr</code>。而继续使用该普通指针很可能会指向（已经释放的）内存【毕竟复杂情况下很难知道对象何时会被销毁】，导致该指针的值是未定义的，这是很危险的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr)</span></span>; <span class="comment">// pass-by-value</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>)); <span class="comment">// 引用计数为 1</span></span><br><span class="line">process(p); <span class="comment">// 拷贝 p 会递增它的引用计数，引用计数为 2</span></span><br><span class="line"><span class="keyword">int</span> i = *p; <span class="comment">// 正确，引用计数为 1</span></span><br><span class="line"></span><br><span class="line">int *x(new int(1024));  // 危险：x 是普通指针</span><br><span class="line"><span class="comment">// process(x); // 错误，不能将int* 转换为shared_ptr&lt;int&gt;</span></span><br><span class="line"><span class="comment">/*  下面是合法的，但内存会被释放!</span></span><br><span class="line"><span class="comment">**  因为是一个临时 shared_ptr传递给 process，当调用表达式结束时，该临时对象就会被销毁。</span></span><br><span class="line"><span class="comment">**  销毁这个临时变量会递减引用计数，此时引用计数就变为0，该临时变量所指向的内存会被释放。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">process(<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;(x)); </span><br><span class="line"><span class="keyword">int</span> j = *x;                  <span class="comment">// 未定义的：x 是个空悬指针</span></span><br></pre></td></tr></table></figure></p><p><strong>也不要使用 <code>get</code> 初始化另一个智能指针 或 为智能指针赋值</strong>，因为设计 <code>get</code> 函数的目的是 “为了向不能使用智能指针的代码传递一个内置指针（或者说是如下一部分内容中 必须要取得<code>RAII class</code>对象内原始资源的情况）”。</p><p><strong>【注意：只有在代码不会 <code>delete</code> 指针的情况下才能使用 <code>get</code>，特别是，永远不要用 <code>get</code> 初始化另一个智能指针 或 为另一个智能指针赋值，尽管编译器不会给出错误信息】</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>));  <span class="comment">// 引用计数为 1</span></span><br><span class="line"><span class="keyword">int</span> *q = p.get();   <span class="comment">// 正确：但使用 q 时要注意，不要让它管理的指针被释放</span></span><br><span class="line">&#123;<span class="comment">// 新程序块</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; (q); <span class="comment">// q 和 p 指向相同的内存，q 的引用计数为 1</span></span><br><span class="line">&#125;<span class="comment">// 程序块结束，q 被销毁，并且 q 所指向的内存被释放</span></span><br><span class="line"><span class="keyword">int</span> foo = *p;   <span class="comment">// 未定义：p 指向的内存已经被释放了</span></span><br></pre></td></tr></table></figure></p><h3 id="必须要取得-RAII-class-对象内原始资源的情况"><a href="#必须要取得-RAII-class-对象内原始资源的情况" class="headerlink" title="必须要取得 RAII class 对象内原始资源的情况"></a>必须要取得 <code>RAII class</code> 对象内原始资源的情况</h3><p>套用书中的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FontHandle <span class="title">getFont</span><span class="params">()</span></span>;           <span class="comment">// 这是个 C API，为简化暂略参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">releaseFont</span><span class="params">(FontHandle fh)</span></span>;<span class="comment">// 来自同一组 C API</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Font</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 采用 pass-by-value，因为 C API 这么做</span></span><br><span class="line">    explicit Font(FontHandle fh) : f(fh) &#123;  &#125;</span><br><span class="line">    ~Font() &#123; releaseFont(f); &#125; <span class="comment">// 释放资源</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FontHandle f;               <span class="comment">// 原始字体资源</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果有大量的 C API，它们处理的是 <code>FontHandle</code>，那么 “将 <code>Font</code> 对象转换为 <code>FontHandle</code>” 会是一种频繁的需求。<code>Font class</code> 可为此<strong>提供一个如下的显式转换函数</strong>，但这使得用户每当要使用 API 时就必须调用 <code>get</code>，这不免会让某些人觉得厌烦。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式转换函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Font</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">FontHandle <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> f; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另一个办法是令 <code>Font</code> <strong>提供如下的隐式转换函数</strong>，转型为 <code>FontHandle</code>，这会使得用户调用 C API 时更为轻松自然。但这份隐式转换会增加错误发生机会。例如用户可能会在需要 <code>Font</code> 时意外创建一个 <code>FontHandle</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 隐式转换函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Font</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">FontHandle</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> f; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要 Font 时意外创建一个 FontHandle</span></span><br><span class="line">Font f1(getFont());</span><br><span class="line">...</span><br><span class="line">FontHandle f2 = f1;</span><br><span class="line"><span class="comment">// 原意是要拷贝一个 Font 对象，</span></span><br><span class="line"><span class="comment">// 却反而将 f1 隐式转换为其底部的 FontHandle，然后才复制它。</span></span><br><span class="line"><span class="comment">// 当 f1 被销毁时，字体被释放，而 f2 会因此成为 “虚吊的（dangle）”。</span></span><br></pre></td></tr></table></figure><p>是否该提供一个显式转换函数（例如 <code>get</code> 成员函数）将 <code>RAII class</code> 转换为其底部资源，或是应该提供隐式转换，答案主要<strong>取决于 <code>RAII class</code> 被设计者执行的特点工作，以及它被使用的情况</strong>。通常显式转换函数如 <code>get</code> 是比较受欢迎的，因为它将“非故意之类型转换” 的可能性最小化，然而有时候隐式转换所带来的“自然用法”的好处更大。</p><p><strong>请记住</strong></p><blockquote><ul><li>API 往往要求访问原始资源（raw resource），所以<strong>每一个 <code>RAII class</code> 应该提供一个 “取得其所管理资源” 的办法</strong>。</li><li>对原始资源的访问可能经由显式转换或隐式转换。一般而言，<strong>显式转换比较安全，但隐式转换对客户比较自然</strong>。</li></ul></blockquote><hr><h2 id="Item-16-成对使用-new-和-delete-时要采取相同形式"><a href="#Item-16-成对使用-new-和-delete-时要采取相同形式" class="headerlink" title="Item 16 : 成对使用 new 和 delete 时要采取相同形式"></a>Item 16 : 成对使用 new 和 delete 时要采取相同形式</h2><blockquote><p>Use the same form in corresponding uses of new and delete</p></blockquote><p>该条款，我想稍微会使用动态内存分配的C++编码者应该都了解，所以此处写的比较随便，看看就好。</p><p>当你使用 <code>new</code>（也就是通过 <code>new</code> 动态生成一个对象），有两件事发生：</p><ul><li>第一，内存被分配出来（通过名为 <code>operator new</code> 的函数，之后会讲）</li><li>第二，针对此内存会有一个（或更多）构造函数被调用</li></ul><p>当你使用 <code>delete</code> 也有两件事发生：</p><ul><li>第一，针对此内存会有一个（或更多）析构函数被调用</li><li>第二，然后内存才被释放（通过名为 <code>operator delete</code> 的函数）</li></ul><p><code>delete</code> 最大的问题在于：即将被删除的内存内究竟有多少对象，这也意味着究竟有多少个析构函数必须被调用。或者更通俗点来说，即将被删除的指针，其所指的是单一对象还是对象数组。</p><p>数组所用的内存通常还包括“数组大小”的记录，以便 <code>delete</code> 知道需要调用多少次析构函数，而单一对象的内存则没有这个记录。</p><p>唯一能够让 <code>delete</code> 知道内存中是否存在一个 “数组大小记录” 的办法就是：由编码者告诉编译器，<strong>如果使用 <code>delete[]</code>，<code>delete</code> 便认定指针指向一个数组，否则便认定指针指向单一对象</strong>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>* pStr1 = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>* pStr2 = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> pStr1;           <span class="comment">// 删除单一对象</span></span><br><span class="line"><span class="keyword">delete</span>[] pStr2;         <span class="comment">// 删除一个对象数组</span></span><br><span class="line"><span class="comment">// =======================================</span></span><br><span class="line"><span class="keyword">delete</span>[] pStr1;         <span class="comment">// 结果未定义</span></span><br><span class="line"><span class="keyword">delete</span> pStr2;           <span class="comment">// 结果未定义</span></span><br></pre></td></tr></table></figure></p><p>上述的规则对喜欢使用 <code>typedef</code> 的编码者也很重要，因为它意味着 <code>typedef</code> 的作者必须说清楚，当以 <code>new</code> 创建该种 <code>typedef</code> 类型对象时，该以哪一种 <code>delete</code> 形式删除它。比如下面这种问题：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span> AddressLines[<span class="number">4</span>];</span><br><span class="line"><span class="comment">// 注意，"new AddressLines" 返回一个 string*，就像"new string[4]" 一样</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>* pAL = <span class="keyword">new</span> AddressLines;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须匹配 “数组形式” 的 delete </span></span><br><span class="line"><span class="keyword">delete</span> pAL;         <span class="comment">// 行为未定义</span></span><br><span class="line"><span class="keyword">delete</span>[] pAL;       <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></p><p>为了避免这样的问题，**最好尽量不要对数组形式做 <code>typedef</code> 动作，而且C++标准库中有许多容器（如<code>vector</code>,<code>string</code>等 <code>templates</code>）可以实现类似数组的需求。</p><p><strong>请记住</strong></p><blockquote><ul><li><strong>如果在 <code>new</code> 表达式中使用 <code>[]</code>，必须在相应的 <code>delete</code> 表达式中也使用 <code>[]</code></strong>；如果一个不用，另一个也一定不要使用。</li></ul></blockquote><hr><h2 id="Item-17-以独立语句将-newed-对象置入智能指针"><a href="#Item-17-以独立语句将-newed-对象置入智能指针" class="headerlink" title="Item 17 : 以独立语句将 newed 对象置入智能指针"></a>Item 17 : 以独立语句将 newed 对象置入智能指针</h2><blockquote><p>Store newed objects in smart pointers in standalone statements</p></blockquote><p>假设有一个函数用来揭示处理程序的优先权，另一个函数用来在某动态分配所得的 <code>Object</code> 上进行某些带有优先权的处理：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">priority</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processObject</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Object&gt; pObj, <span class="keyword">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// processObject(new Object, priority());  // 错误，编译不通过</span></span><br><span class="line"><span class="comment">// 由于 shared_ptr 的构造函数是个 explicit 构造函数，无法进行隐式转换</span></span><br><span class="line"><span class="comment">// 只有写成下面这样才能通过编译</span></span><br><span class="line">processObject(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Object&gt;(<span class="keyword">new</span> Object), priority());</span><br></pre></td></tr></table></figure><p>尽管在此使用了 “对象管理式资源”（object-managing resources），但上述调用却仍可能泄露资源。</p><p>究其原因，要从 <strong>C++ 完成函数参数的核算次序</strong>说起。不像 Java 和 C# 语言一样以特定次序完成函数参数的核算，C++编译器对以什么次序来完成这些事情<strong>弹性很大</strong>。</p><p>拿上面的代码举例，C++ 编译器<strong>产出一个 <code>processObject</code> 调用码之前，必须首先核算即将被传递的各个实参</strong>。此处第二个实参只是单纯地对 <code>priority</code> 函数的调用，但第一个实参 <code>std::shared_ptr&lt;Object&gt;(new Object)</code> 由两部分组成：</p><ul><li>执行 <code>&quot;new Object&quot;</code> 表达式</li><li>调用 <code>std::shared_ptr</code> 的构造函数</li></ul><p>于是在调用 <code>processObject</code> 之前，编译器必须创建代码做以下三件事：</p><ul><li>调用 <code>priority()</code> </li><li>执行 <code>&quot;new Object&quot;</code></li><li>调用 <code>std::shared_ptr</code> 的构造函数</li></ul><p>由于 <strong>C++ 核算函数参数的次序不确定</strong>，对 <code>priority()</code> 的调用可以排在第一或第二或第三行。【可以确定的是 <code>&quot;new Object&quot;</code> 一定执行于 <code>std::shared_ptr</code> 构造函数被调用之前】</p><p>因此如果编译器选择以第二顺位执行 <code>priority</code> 函数【说不定编译器可以生成更高效的代码，谁知道呢!】，最终获得这样的操作序列：</p><ul><li>执行 <code>&quot;new Object&quot;</code></li><li>调用 <code>priority()</code></li><li>调用 <code>std::shared_ptr</code> 的构造函数</li></ul><p>此时，万一对 <code>priority()</code> 的调用抛出异常，<code>&quot;new Object&quot;</code> 返回的指针将会遗失，因为它尚未被置入我们期盼用来防止资源泄露的 <code>std::shared_ptr</code> 内。</p><p>避免这类问题的办法很简单：<strong>使用分离语句</strong>，分别写出</p><ol><li>创建 <code>Object</code> ，将它置入一个智能指针内</li><li>然后再把那个智能指针传给 <code>processObject</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Object&gt; pObj(<span class="keyword">new</span> Object);</span><br><span class="line"></span><br><span class="line">processObject(pObj, priority());</span><br></pre></td></tr></table></figure></li></ol><p>上面的代码之所以能行得通，是因为<strong>编译器对于 “跨越语句的各项操作” 没有重新排列的自由（只有在语句内它才拥有那个自由度）</strong>。</p><p><strong>请记住</strong></p><blockquote><ul><li><strong>以独立语句将 <code>newd</code> 对象存储于智能指针内</strong>。如果不这么做，一旦异常被抛出，有可能导致难以察觉的资源泄露。</li></ul></blockquote><hr><p>【备注】：还有一类智能指针 <code>weak_ptr</code> 在此并没有被讲到，但值得了解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;书中第三部分是讲资源管理（Resource Management），只有不足20页，尽管不是专门讲动态内存（dynamical memory）和智能指针（smart pointer），但还是占较大篇幅的，我会结合 C++11 新标准对其进行一些扩充。今日も顽张りましょう。&lt;/p&gt;
    
    </summary>
    
      <category term="Cpp" scheme="http://koushiro.me/categories/Cpp/"/>
    
    
      <category term="tech" scheme="http://koushiro.me/tags/tech/"/>
    
      <category term="Cpp" scheme="http://koushiro.me/tags/Cpp/"/>
    
      <category term="note" scheme="http://koushiro.me/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>The Note2 of Effective C++</title>
    <link href="http://koushiro.me/2017/02/03/Effective-Cpp-Note2/"/>
    <id>http://koushiro.me/2017/02/03/Effective-Cpp-Note2/</id>
    <published>2017-02-03T04:40:57.000Z</published>
    <updated>2018-09-22T17:58:02.620Z</updated>
    
    <content type="html"><![CDATA[<p>过年好像并没有想象的这么闲，无聊又麻烦的事情比较多【这也是我过年期间中的daikirai】，所以第二部分的整理来的有些迟，这一部分的 Items 相比第一部分要短小简洁，而且这部分 Items 中对我来说绝大多数都是较熟悉的【毕竟构造和析构这种东西写的太多了】，除了 Item 8 ，可能是实际中异常我用的比较少。总之，Let’s do it !</p><a id="more"></a><blockquote><p>Tips : 我会在 C++11/14 标准的基础上作笔记 (Effective C++, 3rd Edition 中的内容并不是按照 C++11/14 标准）</p></blockquote><h1 id="Constructor-Destructor-and-Assignment-Operator"><a href="#Constructor-Destructor-and-Assignment-Operator" class="headerlink" title="Constructor, Destructor, and Assignment Operator"></a>Constructor, Destructor, and Assignment Operator</h1><h2 id="Item-5-了解C-默默编写并调用哪些函数"><a href="#Item-5-了解C-默默编写并调用哪些函数" class="headerlink" title="Item 5 : 了解C++默默编写并调用哪些函数"></a>Item 5 : 了解C++默默编写并调用哪些函数</h2><blockquote><p>Know what functions C++ silently writes and calls</p></blockquote><p>在一个空类中，若没有自定义 <strong>类内特殊成员函数（ <code>default constructor</code>、<code>copy constructor</code>、<code>copy assignment operator</code>、<code>destructor</code>）</strong> 的声明，则编译器就会为其对应地声明（编译器版本）一个，所有这些编译器自动生成的函数都是 <code>public</code> 且 <code>inline</code>。<br>例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span>  &#125;;</span><br></pre></td></tr></table></figure></p><p>就像写下了这样的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Empty()  &#123;...&#125;                              <span class="comment">// default constructor </span></span><br><span class="line">    Empty(<span class="keyword">const</span> Empty&amp; rhs) &#123; ... &#125;             <span class="comment">// copy constructor</span></span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Empty&amp; rhs) &#123; ... &#125;  <span class="comment">// copy assignment operator</span></span><br><span class="line">    ~Empty() &#123; ... &#125;                            <span class="comment">// destructor</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ==============================================</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Empty e1;       <span class="comment">// call default constructor</span></span><br><span class="line">    <span class="function">Empty <span class="title">e2</span><span class="params">(e1)</span></span>;   <span class="comment">// call copy constructor</span></span><br><span class="line">    e2 = e1;        <span class="comment">// call copy assignment operator</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;       <span class="comment">// call destructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong></p><ol><li>只有当这些函数被需要（即被调用）时，才会被编译器创建出来。</li><li>编译器产出的 <code>destructor</code> 是个 <code>non-virtual</code>，除非该 <code>class</code> 的 <code>base class</code> 自身声明有 <code>virtual destructor</code>。</li><li>至于编译器创建的 <code>copy constructor</code> 和 <code>copy assignment operator</code> 只是单纯地将来源对象的每一个 <code>non-static</code> 成员变量拷贝到目标对象。</li><li>编译器拒绝为 class 生出 <code>operator=</code> 的情况：<ul><li>打算在一个 “内含 <code>reference</code> 成员” 的 class 内支持赋值操作（assignment），必须自定义 <code>copy assignment operator</code></li><li>面对 “内含 <code>const</code> 成员” 的 class，编译器反应一样</li><li>若某个 <code>base class</code> 将 <code>copy assignment operator</code> 声明为 <code>private</code>，则编译器拒绝为其 <code>derived class</code> 生成一个 <code>copy assignment operator</code></li></ul></li></ol><p>在此，我给出自己的建议，那就是：<strong>不论是要使用编译器默认生成的,还是自定义的，一律都显式地写出</strong>。一致的规则难道不是更好记么？【当然非必要的情况不要提供 <code>default constructor</code>（具体见 <em>More Effective C++,Item 4</em>），具体来说 凡是可以“从无到有生成对象”的 <code>classes</code> 都应该内含 <code>default constructor</code>，而“必须有某些外来信息才能生成对象”的 <code>classes</code> 则不必拥有 <code>default constructor</code>，因为这类 <code>classes</code> 没有获得外来信息产生的对象显然毫无意义】</p><p>此外，C++11 标准还引进了 <strong><code>defaulted function</code></strong> ，<code>defaulted function</code> 特性 <strong>仅适用于类的特殊成员函数</strong>，即 <strong>可以显式地写出编译器自动生成的版本</strong>，而且 <code>defaulted function</code> 既可以在类体内定义，也可以在类体外定义。<br>比如上述代码可改为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Empty() = <span class="keyword">default</span>;                       </span><br><span class="line">    Empty(<span class="keyword">const</span> Empty&amp; rhs) = <span class="keyword">default</span>;</span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Empty&amp; rhs) = <span class="keyword">default</span>;</span><br><span class="line">    ~Empty() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>请记住</strong></p><blockquote><ul><li><strong>编译器可以自己为 <code>class</code> 创建 <code>default constructor</code>、<code>copy constructor</code>、<code>copy assignment operator</code>，以及 <code>destructor</code></strong>。</li></ul></blockquote><hr><h2 id="Item-6-若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#Item-6-若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="Item 6 : 若不想使用编译器自动生成的函数，就该明确拒绝"></a>Item 6 : 若不想使用编译器自动生成的函数，就该明确拒绝</h2><blockquote><p>Explicitly disallow the use of compiler-generated functions you do not want</p></blockquote><p>有些东西是先天独一无二的，而能对这些对象进行拷贝显然是我们不乐意看到的。</p><p>通常不希望 class 支持某一特定功能，只要不声明对应函数就行。但这个策略对 <code>copy constructor</code> 和 <code>copy assignment operator</code> 却不起作用，因为尽管不声明它们，编译器也会暗自为我们声明。</p><p>那怎么办呢，在 C++11 标准以前，阻止拷贝较受欢迎的做法便是：<strong>将这类独一无二的对象的 <code>copy constructor</code> 和 <code>copy assignment operator</code> 声明为 <code>private</code> 但不定义它们</strong> 。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UniqueObject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    UniqueObject(<span class="keyword">const</span> UniqueObject&amp;);      <span class="comment">// 只有声明</span></span><br><span class="line">    UniqueObject&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> UniqueObject&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为通过明确声明成员函数可以阻止编译器暗自创建其专属版本，而令这些函数为 <code>private</code> 可以阻止开发人员调用它，但只做到此显然并不绝对安全，因为 成员函数 和 友元函数 还能调用同一个类中的 <code>private</code> 函数。在此之上，还必须要不定义它们，以便有人不慎调用任何一个，链接器能返回一个链接错误（linkage error）。</p><p>而在 C++11 标准引入了 <code>deleted function</code> 之后，解决方法就显得简单多了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UniqueObject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    UniqueObject(<span class="keyword">const</span> UniqueObject&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    UniqueObject&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> UniqueObject&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="deleted-function-的注意事项"><a href="#deleted-function-的注意事项" class="headerlink" title="deleted function 的注意事项"></a><code>deleted function</code> 的注意事项</h3><ol><li><code>=delete</code> 和 <code>=default</code> 不同，必须出现在函数第一次声明时。</li><li>可以对任何函数指定 <code>=delete</code>，但主要用途还是禁止拷贝控制成员。</li><li>不能将 <code>destructor</code> 指定为 <code>=delete</code>。 </li><li>编译器合成的拷贝控制成员也可能是 <code>deleted</code>。</li></ol><p><strong>请记住</strong></p><blockquote><ul><li>C++11标准前：为驳回编译器自动提供的功能（更具体说是为了阻止拷贝），可将相应的成员函数（即 <code>copy constructor</code> 和 <code>copy assignment operator</code>）声明为 <code>private</code> 并且不予实现。</li><li>C++11标准后：通过将 <code>copy constructor</code> 和 <code>copy assignment operator</code> 指定 <code>=delete</code> 即可禁止拷贝。 </li></ul></blockquote><hr><h2 id="Item-7-为多态基类声明virtual析构函数"><a href="#Item-7-为多态基类声明virtual析构函数" class="headerlink" title="Item 7 : 为多态基类声明virtual析构函数"></a>Item 7 : 为多态基类声明virtual析构函数</h2><blockquote><p>Declare destructors virtual in polymorphic base classes</p></blockquote><p>C++ 明白指出：当 <code>derived class</code> 对象经由一个 <code>base class</code> 指针被删除，而该 <code>base class</code> 带着一个 <code>non-virtual</code> 析构函数，其结果是<strong>未定义的</strong>——实际执行时通常发生的是 <strong>对象的 <code>base class</code> 成分被销毁</strong>，然而其 <strong><code>derived</code> 成分没被销毁</strong>，造成一个 “局部销毁” 对象。</p><p>举个例子【我知道这例子很做作，也请先不要理会手工delete这件事，看看就好→_→】：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Animal();</span><br><span class="line">    ~Animal();      <span class="comment">// 解决办法：virtual ~Animal();</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rat</span> :</span> <span class="keyword">public</span> Animal &#123; ... &#125;;</span><br><span class="line"><span class="comment">// ================================</span></span><br><span class="line">Cat tom;</span><br><span class="line">Animal* pA = &amp;tom;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> pA;</span><br></pre></td></tr></table></figure></p><p>解决办法很简单：给 <code>base class</code> 一个 <code>virtual</code> 析构函数，<strong>因为 <code>virtual</code> 函数的目的就是允许 <code>derived class</code> 的实现得以客制化</strong>。</p><p><strong>注意</strong>：</p><p>“给 <code>base class</code> 一个 <code>virtual</code> 析构函数” 这个规则 只适用于 <code>polymorphic</code>（带多态性质的）<code>base class</code> 身上，目的是为了用来 “通过 <code>base class</code> 接口处理 <code>derived class</code> 对象”，而并非所有 <code>base class</code> 的设计目的都是为了多态用途。</p><p>例如标准string 和 STL容器，如果你企图继承一个STL容器 或 任何其他“带有 <code>non-virtual</code> 析构函数”的 class，就可能会导致刚开始就讲到的未定义错误【很可惜C++中没有提供类似 C#中的 sealed class 那样的“禁止派生”机制】。</p><p>这里要提及一下 <code>pure virtual</code> 函数，它也涉及到 <code>virtual destructor</code>【可能会带来些许便利】。<br><code>pure virtual</code> 函数导致 <code>abstract class</code>——即不能被实例化的 <code>class</code>，也就是不能创建这类型的对象。</p><p>有时候会希望拥有一个 <code>abstract class</code>，该怎么做呢？<br>由于 <code>abstract class</code> 总是被当做一个 <code>base class</code> 来用，而又由于 <code>base class</code> 应该有一个 <code>virtual</code> 析构函数，因此做法很简单：<strong>为期望成为抽象的 <code>class</code> 声明一个 <code>pure virtual destructor</code></strong>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AbstractClass() = <span class="number">0</span>;       <span class="comment">// 声明 pure virtual 析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>还有个小窍门：<strong>必须为 <code>pure virtual destructor</code> 提供一份定义</strong>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbstractClass::~AbstractClass() &#123;  &#125;    <span class="comment">// pure virtual 析构函数的定义</span></span><br></pre></td></tr></table></figure></p><p>这样做的原因是：对象的析构是会调用 <code>derived class</code> 的析构函数，然后接着调用 <code>base class</code> 的析构函数。也就是说编译器会在 <code>AbstractClass</code> 的 <code>derived class</code> 的析构函数中创建一个对 <code>~AbstractClass</code> 的调用动作，所以必须提供定义，不然链接器会拿小拳拳捶你胸口的→_→</p><h3 id="扩展（关于vptr和vtbl）"><a href="#扩展（关于vptr和vtbl）" class="headerlink" title="扩展（关于vptr和vtbl）"></a>扩展（关于<code>vptr</code>和<code>vtbl</code>）</h3><p>关于 virtual 关键字，我想稍微有点C++编码经验的应该大致了解其语法，这里并不想多说，而是把<strong>重点放在 “不论class是否为base class，都令其析构函数为virtual” 这种做法不好在哪里</strong>。</p><p>要实现人们期望的 <code>virtual</code> 函数的功能，对象必须携带某些信息——主要用于在运行期决定哪一个 <code>virtual</code> 函数该被调用。这份信息通常由一个所谓 <code>虚表指针（vptr）</code>指出，<code>虚表指针（vptr）</code>指向一个<strong>由函数指针构成的数组</strong>——称为<code>虚表（vtbl）</code>。每一个带有 <code>virtual</code> 函数的 <code>class</code> 都有一个相应的 <code>vtbl</code>，当对象调用某一 <code>virtual</code> 函数，实际调用的函数取决于该对象的 <code>vptr</code> 所指的那个 <code>vtbl</code> ——编译器在其中寻找适当的函数指针。</p><p>讲了这么多，其实重点是想说明<strong>某个内含 <code>virtual</code> 函数的 <code>class</code>，其对象的体积会增加一个 <code>vptr</code> 指针的大小</strong>【具体大小要看计算机体系结构】。还有像书中所说，更有甚者将这样一个对象传给其他语言【比如C】编写的函数，这也将不再可能（因为其他语言的对应物并没有 <code>virtual</code>），除非你自己明确地补偿 <code>vptr</code>，这不是给自己找罪受吗(⊙_⊙)？</p><p><strong>请记住</strong></p><blockquote><ul><li><strong><code>polymorphic</code>（带有多态性质的）<code>base classes</code> 应该声明一个 <code>virtual</code> 析构函数</strong>。<br><strong>如果 <code>class</code> 带有任何 <code>virtual</code> 函数，它也就应该拥有一个 <code>virtual</code> 析构函数</strong>。</li><li>某 <code>class</code> 的设计目的若<strong>不是作为 <code>base class</code></strong> 使用，或<strong>不是为了具备多态性（<code>polymorphically</code>）</strong>，就<strong>不该声明 <code>virtual</code> 析构函数</strong>。</li></ul></blockquote><hr><h2 id="Item-8-别让异常逃离析构函数"><a href="#Item-8-别让异常逃离析构函数" class="headerlink" title="Item 8 : 别让异常逃离析构函数"></a>Item 8 : 别让异常逃离析构函数</h2><blockquote><p>Prevent exceptions from leaving destructors</p></blockquote><p>C++ 并不禁止析构函数抛出异常，但不鼓励这么做。比如下面的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    ~Object() &#123; ... &#125;       <span class="comment">// 假设抛出一个异常</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Object&gt; v;</span><br><span class="line">    ...</span><br><span class="line">&#125;           <span class="comment">// 此处 v 被销毁</span></span><br></pre></td></tr></table></figure></p><p>假设【就是有这么多假设】v 中含有10个 <code>Object</code>，析构第一个时抛出一个异常，但其他9个还是应该被销毁，此时若有第二个 <code>Object</code> 抛出异常，那么<strong>在两个异常同时存在的情况下，C++程序不是过早结束执行就是导致不明确行为</strong>【本例会导致不明确行为】。说实话，其实我之前根本不知道这个，谁让我异常写得少【逃。</p><h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><p>若析构函数必须要执行某个动作，但该动作可能会在失败时抛出异常，你就说这尴不尴尬…</p><p>说实话，我觉得书中负责数据库连接的例子并不是非常简单明了【这估计也是因为我很少写异常→_→</p><p>所以…<br>我就不打算放上来了，感觉自己一时半会也想不出来一个好例子，先不写实例代码了【如果有人能给出的话，不甚感激</p><p>避免问题的两个办法：</p><ul><li><p><strong>抛出异常就结束程序</strong>，通常通过调用 <code>std::abort()</code> 完成。</p></li><li><p><strong>吞下抛出的异常</strong>，一般而言，这是个坏主意，它压制了某些动作失败的重要信息，但有时候吞下异常也比负担 “草率结束程序”或“发生不明确行为”的风险要好。</p></li></ul><p>这两个办法都没有什么吸引力，都无法对“导致抛出异常”的情况作出反应。</p><p>那要怎么做呢？一个<strong>较佳策略</strong>是：重新设计可能会抛出异常的接口，使客户（即使用者）有机会对可能出现的问题作出反应。有人可能会觉得把析构函数的部分工作转移给客户对客户是一种负担，其实不然，这只是给他们一个处理错误的机会，否则他们没机会响应，如果他们认为这个机会没用，ok，直接可以忽略它。如果之后他们再抱怨异常的发生，让他们滚蛋，已经给过他们机会了。【没毛病，很有道理…</p><p>回到特殊情况上来，<strong>如果某个操作可能在失败时抛出异常，但又因为某种需要必须处理该异常，那么这个异常必须来自析构函数以外的某个函数</strong>。因为析构函数抛出异常就是危险，总会带来“过早结束程序”或“发生不明确行为”的风险。</p><p><strong>请记住</strong></p><blockquote><ul><li><strong>析构函数绝对不要抛出异常</strong>。如果某个被析构函数调用的函数可能会抛出异常，析构函数应该能catch所有异常，并将它们吞下（不传播）或结束程序。 </li><li><strong>若需要对某个操作函数运行期间抛出的异常做出反应</strong>，<code>class</code> 应该<strong>提供一个普通函数（而非析构函数）执行该操作</strong>。</li></ul></blockquote><hr><h2 id="Item-9-绝不在构造和析构过程中调用virtual函数"><a href="#Item-9-绝不在构造和析构过程中调用virtual函数" class="headerlink" title="Item 9 : 绝不在构造和析构过程中调用virtual函数"></a>Item 9 : 绝不在构造和析构过程中调用virtual函数</h2><blockquote><p>Never call virtual function during construction or destruction</p></blockquote><p>既然标题已经这么明显了，那么肯定会有人问为什么这么做【至少我会想一想</p><p>套用书中一个明显看出违反本条款的例子【懒得自己想了<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Transaction();</span><br><span class="line">    <span class="comment">// 记录交易日志</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;    <span class="comment">// pure virtual function</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Transaction::Transaction()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    logTransaction();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTransaction</span> :</span> <span class="keyword">public</span> Transaction</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SellTransaction</span> :</span> <span class="keyword">public</span> Transaction</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>若执行 <code>BuyTransaction b</code>，显然会调用 <code>BuyTransaction</code> 构造函数，而调用 <code>BuyTransaction</code> 构造函数之前一定要调用基类 <code>Transaction</code> 的构造函数——使得 <code>derived class</code> 对象内的 <code>base class</code> 成分先构造完。</p><p>问题在于：例子中的 <code>Transaction</code> 构造函数却在最后调用了 <code>virtual</code> 函数 <code>logTransaction</code>。</p><p><strong>注意</strong>：</p><p>这时候被调用的 <code>logTransaction</code> 是 <code>Transaction</code> 内的版本，不是 <code>BuyTransaction</code> 内的版本——即使当前要建立的对象类型是 <code>BuyTransaction</code>，也就是说 <code>base class</code> 构造期间，<code>virtual</code> 函数绝不会下降到 <code>derived class</code> 层面。或者换一种更哲♂学的说法：<strong>在 <code>derived class</code> 对象的 <code>base class</code> 构造期间，对象类型是 <code>base class</code> 而不是 <code>derived class</code></strong>。</p><p>想想看，当 <code>base class</code> 构造函数在执行时，<code>derived class</code> 的成员变量<strong>尚未初始化</strong>，若此时 <code>virtual</code> 函数下降到 <code>derived class</code> 层面，<code>derived class</code> 中的函数一般会取用 <code>local</code> 成员变量，而这些变量又没初始化，那肯定会导致未定义行为。</p><p>相同道理也适用于 析构函数。一旦 <code>derived class</code> 析构函数开始执行，目标对象内的 <code>derived class</code> 成员变量所占的资源即将归还系统，此时这些成员变量便呈现未定义值【这么说不知道恰不恰当】，C++ 也仿佛视它们不存在，进入 <code>base class</code> 析构函数后，对象就成为了一个 <code>base class</code> 对象，C++ 的任何部分包括 <code>virtual</code> 函数等也都这么看待它。</p><h3 id="不易察觉的情况及避免方法"><a href="#不易察觉的情况及避免方法" class="headerlink" title="不易察觉的情况及避免方法"></a>不易察觉的情况及避免方法</h3><p>上述示例中，应该很容易就能看出不符合标题，但很多情况并不会被轻易察觉。</p><p>比如，<code>Transaction</code> 有多个构造函数，而且都要执行某些相同工作，显然代码复用是个很好的主意。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Transaction(.) &#123; init(); ... &#125;</span><br><span class="line">    Transaction(..) &#123; init(); ... &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span>         <span class="comment">// 复用的代码</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        logTransaction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>此时由于 <code>logTransaction</code> 是个 <code>pure virtual</code> 函数【调用<code>pure virtual</code>函数，一般程序会被系统直接中止】，若 <code>logTransaction</code> 是个 <code>impure virtual</code> 函数，那么这样的代码通常不会引发编译器和链接器的组合小拳拳，但显然也会发生上面提及的问题。因此，唯一能够避免此问题的做法就是：<strong>确定构造函数和析构函数都没有（在对象被创建和被销毁期间）调用 <code>virtual</code> 函数，而它们调用的所有函数也都服从同一约束</strong>。</p><p>可能有人发现了，讲了一大堆，若真的想 在对象被创建时 调用适当的 <code>logTransaction</code>，那该怎么办？<br>书中给出了一种做法：将 <code>logTransaction</code> 改为 <code>non-virtual</code>，然后<strong>要求 <code>derived class</code>构造函数传递必要信息给 <code>Transaction</code> 构造函数</strong>，而后便可安全调用 <code>non-virtual</code> 的 <code>logTransaction</code>。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Transaction</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; logInfo)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; logInfo)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Transaction::Transaction(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; logInfo)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    logTransaction(logInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTransaction</span> :</span> <span class="keyword">public</span> Transaction</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BuyTransaction( parameters )</span><br><span class="line">        : Transaction(createLogString( parameters ))</span><br><span class="line">    &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 此函数为 static，也就不可能意外指向 BuyTransaction 对象内初期尚未初始化的变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">createLogString</span><span class="params">( parameters )</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>怎么感觉这个 <code>Item</code> 这么长啊… 果然我好垃圾啊… 但是垃圾的我还是要牢牢记住这个 <code>Item</code> 的标题和下面的”请记住”条目…</p><p><strong>请记住</strong></p><blockquote><ul><li><strong>在构造和析构期间不要调用 <code>virtual</code> 函数，而它们调用的所有函数也都服从同一约束</strong>，因为这类调用从不下降到 <code>derived class</code> （比起当前执行构造函数和析构函数的那层）。 </li></ul></blockquote><hr><h2 id="Item-10-令-operator-返回一个-reference-to-this"><a href="#Item-10-令-operator-返回一个-reference-to-this" class="headerlink" title="Item 10 : 令 operator= 返回一个 reference to *this"></a>Item 10 : 令 operator= 返回一个 reference to *this</h2><blockquote><p>Have assignment operators return a reference to *this</p></blockquote><p>赋值采用右结合律，连锁赋值形式 <code>x = y = z = 1</code> 被解析为 <code>x = (y = (z = 1))</code>。</p><p>为了实现自定义 <code>class</code> 的 “连锁赋值” 操作， <code>class</code> 应该遵循协议：<strong>赋值操作符必须返回一个 <code>reference</code> 指向操作符的左侧实参</strong>。</p><p>该协议不仅适用于标准赋值形式，也适用于所有赋值相关运算，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 返回类型为 reference，指向当前对象</span></span><br><span class="line">    Object&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Object&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 也适用于 +=，-=，*= 等运算操作</span></span><br><span class="line">    Object&amp; <span class="keyword">operator</span> += (<span class="keyword">const</span> Object&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此函数也适用，即使此操作符的参数类型不符协定</span></span><br><span class="line">    Object&amp; <span class="keyword">operator</span> = (<span class="keyword">int</span> rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这只是个协议，并无强制性，若不遵守该协议，代码仍然能编译通过。但是 <strong>这份协议被所有内置类型和标准程序库提供的类型共同遵守</strong>，所以没有什么特别的理由，还是遵守它比较好。</p><p><strong>请记住</strong></p><blockquote><ul><li>令赋值（assignment）操作符返回一个 <code>reference to *this</code>。</li></ul></blockquote><hr><h2 id="Item-11-在-operator-中处理“自我赋值”"><a href="#Item-11-在-operator-中处理“自我赋值”" class="headerlink" title="Item 11 : 在 operator= 中处理“自我赋值”"></a>Item 11 : 在 operator= 中处理“自我赋值”</h2><blockquote><p>Handle assignment to self in Operator =</p></blockquote><p>自我赋值，顾名思义，发生在对象被赋值给自己时，有些自我赋值一眼就能看出，而另一些则很难看出来，这类很难看出来的自我赋值可能会导致一些意料之外的错误，这里套用书中的例子，<strong>建立一个 <code>class</code> 用来保存一个指针指向一块动态分配的位图（bitmap）</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap* pb;        <span class="comment">// 指向一个从 heap 分配得到的对象</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 一份不安全的 operator = 实现版本</span></span><br><span class="line">Object&amp; Object::<span class="keyword">operator</span> = (<span class="keyword">const</span> Object&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处可能存在的自我赋值问题是：<code>operator =</code> 函数内的 <code>*this</code> 和 <code>rhs</code> 有可能是同个对象。<br>若是同个对象的话，当前对象 <code>delete pb</code> 的时候顺便也销毁了 <code>rhs</code> 的 <code>bitmap</code>，最后函数返回的是一个指针指向一个已被删除的对象，这显然不行。</p><p>传统的解决办法：通过 <strong>“证同测试（identity test）” 检验自我赋值</strong>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Object&amp; Object::<span class="keyword">operator</span> = (<span class="keyword">const</span> Object&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 若是自我赋值，不做任何事</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但该版本仍然会导致异常，比如 “new Bitmap” 时抛出异常。由于 让 <code>operator =</code> 具备“异常安全性”往往自动获得“自我赋值安全”的回报，因此许多人把重心放在实现“异常安全性”上。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object&amp; Object::<span class="keyword">operator</span> = (<span class="keyword">const</span> Object&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Bitmap* pOrigin = pb;       <span class="comment">// 存储原先的 pb</span></span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">    <span class="keyword">delete</span> pOrigin;             <span class="comment">// 删除原先的 pb</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此处函数内对原 <code>bitmap</code> 做了一个复件、删除原 <code>bitmap</code>、然后指向新创建的那个复件，即使 <code>new Bitmap</code> 抛出异常，<code>pb</code> 仍保持原状。虽说这种做法不高效，但行得通。</p><p>另一种替换方案，即 <code>copy and swap</code>技术 可以确保代码不但“异常安全”，而且“自我赋值安全”，并且比起上面在 <code>operator=</code> 函数内手工排列语句显得更简洁【说实话这个部分的 <code>swap</code> 我都还没弄清楚，所以先将就看看，之后弄懂了再来补充，希望想的起来→_→】。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Object&amp; rhs)</span></span>;     <span class="comment">// 交换 *this 和 rhs 的数据，具体实现【未完】</span></span><br><span class="line">...    </span><br><span class="line">&#125;;</span><br><span class="line">Object&amp; Object::<span class="keyword">operator</span> = (<span class="keyword">const</span> Object&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Object temp(rhs);</span><br><span class="line">    swap(temp);         <span class="comment">// 将 *this 数据 和 复件数据 交换</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 这种做法尽管聪明，但感觉会让代码不够清晰</span></span><br><span class="line"><span class="comment">Object&amp; Object::operator = (Object rhs)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    swap(rhs);</span></span><br><span class="line"><span class="comment">    return *this;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p><strong>请记住</strong></p><blockquote><ul><li>确保当前对象自我赋值时，<code>operator =</code> 有着良好的行为，其中涉及的技术包括：<strong>比较“来源对象”和“目标对象”的地址</strong>、<strong>精心周到的语句顺序</strong>、以及 <strong><code>copy-and-swap</code> 技术</strong>。</li></ul></blockquote><hr><h2 id="Item-12-复制对象时勿忘其每一个成分"><a href="#Item-12-复制对象时勿忘其每一个成分" class="headerlink" title="Item 12 : 复制对象时勿忘其每一个成分"></a>Item 12 : 复制对象时勿忘其每一个成分</h2><blockquote><p>Copy all parts of an object</p></blockquote><p><code>copying</code> 函数 包括 <code>copy constructor</code> 和 <code>copy assignment operator</code>，这两个函数负责对象拷贝。</p><p>我在最开始部分（即 <code>Item 5</code>）说过，就我个人而言，我更推荐声明自己的 <code>default constructor</code>、<code>destructor</code>、<code>copying</code> 函数（<code>copy constructor</code>、<code>copy assignment operator</code>），此时编译器就仿佛自己的权威受到了挑战，在代码显然出错的地方也不会告诉你。<br>套用书中的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logCall</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; funcName)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Customer() = <span class="keyword">default</span>;</span><br><span class="line">    ~Customer() = <span class="keyword">default</span>;</span><br><span class="line">    Customer(<span class="keyword">const</span> Customer&amp; rhs);</span><br><span class="line">    Customer&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Customer&amp; rhs);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Customer::Customer(<span class="keyword">const</span> Customer&amp; rhs)</span><br><span class="line">    : name(rhs.name)</span><br><span class="line">&#123;</span><br><span class="line">    logCall(<span class="string">"Customer copy constructor"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Customer&amp; Customer::<span class="keyword">operator</span> = (<span class="keyword">const</span> Customer&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    logCall(<span class="string">"Customer copy assignment operator"</span>);</span><br><span class="line">    name = rhs.name;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>若此时再加入另一个成员变量–顾客的最近交易日期【如下】，问题就出现了，当前既有的 <code>copying</code> 函数执行的是 <strong>局部拷贝（partial copy）</strong>：的确复制了顾客的 <code>name</code>，但没有复制新添加的 <code>lastTransaction</code>。大多数编译器【包括VC++】对此不出任何怨言–即使在最高警告级别中，但是这也不能说是编译器的责任，谁让你不把新加入的变量写进 <code>copying</code> 函数里【说到底还是编码者的责任→_→<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span> &#123;</span> ... &#125;;     <span class="comment">// 具体内容随便写</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    Date lastTransaction;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>还有<strong>注意在继承中，<code>derived class</code> 容易在 <code>copying</code> 函数中遗漏 <code>base class</code> 的成分</strong>，忘记的话就是你自己的锅了→_→，比如正确的情况如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityCustomer</span> :</span> <span class="keyword">public</span> Customer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    PriorityCustomer(<span class="keyword">const</span> PriorityCustomer&amp; rhs);</span><br><span class="line">    PriorityCustomer&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> PriorityCustomer&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> priority;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PriorityCustomer::PriorityCustomer(<span class="keyword">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">    : Customer(rhs),                <span class="comment">// 调用 base class 的 copy constructor</span></span><br><span class="line">     priority(rhs.priority)</span><br><span class="line">&#123;</span><br><span class="line">    logCall(<span class="string">"PriorityCustomer copy constructor"</span>);</span><br><span class="line">&#125;</span><br><span class="line">PriorityCustomer&amp; PriorityCustomer::<span class="keyword">operator</span> = (<span class="keyword">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    logCall(<span class="string">"PriorityCustomer copy assignment operator"</span>);</span><br><span class="line">    Customer::<span class="keyword">operator</span>=(rhs);       <span class="comment">// 对 base class 成分进行赋值动作</span></span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">    reference *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可能有人觉得两个 <code>copying</code> 函数有相似的实现内容，可以像之前说过的在 <code>const</code> 和 <code>non-const</code> 成员函数中避免代码重复一样，用某个调用另一个。但其实只要认真思考一下：<code>copy constructor</code> 用来初始化新对象，而 <code>copy assignment operator</code> 只能作用在已初始化的对象身上，不管是构造一个已经存在的对象，还是对一个尚未构造好的对象赋值 显然都是荒谬的，无意义的。</p><p><strong>请记住</strong></p><blockquote><ul><li><strong><code>copying</code> 函数应确保复制 “对象内的所有成员变量” 以及 “所有 <code>base class</code> 成分”</strong>。</li><li><strong>不要尝试以某个 <code>copying</code> 函数实现另一个 <code>copying</code> 函数</strong>，应将共同功能放进另一个函数，供这两个 <code>copying</code> 函数调用。</li></ul></blockquote><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;过年好像并没有想象的这么闲，无聊又麻烦的事情比较多【这也是我过年期间中的daikirai】，所以第二部分的整理来的有些迟，这一部分的 Items 相比第一部分要短小简洁，而且这部分 Items 中对我来说绝大多数都是较熟悉的【毕竟构造和析构这种东西写的太多了】，除了 Item 8 ，可能是实际中异常我用的比较少。总之，Let’s do it !&lt;/p&gt;
    
    </summary>
    
      <category term="Cpp" scheme="http://koushiro.me/categories/Cpp/"/>
    
    
      <category term="tech" scheme="http://koushiro.me/tags/tech/"/>
    
      <category term="Cpp" scheme="http://koushiro.me/tags/Cpp/"/>
    
      <category term="note" scheme="http://koushiro.me/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>The Note1 of Effective C++</title>
    <link href="http://koushiro.me/2017/01/26/Effective-Cpp-Note1/"/>
    <id>http://koushiro.me/2017/01/26/Effective-Cpp-Note1/</id>
    <published>2017-01-26T07:24:56.000Z</published>
    <updated>2018-09-22T17:57:47.923Z</updated>
    
    <content type="html"><![CDATA[<p>之前买了这本书后只是草草翻过，这半个多月以来，断断续续把这本书从头到尾看了一遍，虽然其中的一些条款内容早就熟记于心，但难免还有晦涩之处，所以打算在过年空闲期间把整本书的每个条款的重点进行系统的整理。<br>不得不说 C++ 是门不好学的语言，自认为也没那么聪明，整理总结对我来说不失为一个深入学习的好方法。</p><a id="more"></a><blockquote><p>Tips : 我会在 C++11/14 标准的基础上作笔记 (Effective C++, 3rd Edition 中的内容并不是按照 C++11/14 标准）</p></blockquote><h1 id="Accustoming-Yourself-to-C"><a href="#Accustoming-Yourself-to-C" class="headerlink" title="Accustoming Yourself to C++"></a>Accustoming Yourself to C++</h1><h2 id="Item-1-视C-为一个语言联邦"><a href="#Item-1-视C-为一个语言联邦" class="headerlink" title="Item 1 : 视C++为一个语言联邦"></a>Item 1 : 视C++为一个语言联邦</h2><blockquote><p>View C++ as a federation of languages</p></blockquote><p>C++ 是个多重范式编程语言，同时支持：</p><ul><li>过程形式（procedural）</li><li>面向对象形式（objecr-oriented）</li><li>函数形式（functional）</li><li>泛型形式（generic）</li><li>元编程形式（metaprogramming）</li></ul><p>将 C++ 视为一个语言联邦而非单一语言，可以更易理解。在其某个次语言中（sublanguage）中，各守则与通例都倾向简单、直观易懂，并且容易记住。</p><p>C++ 主要的次语言，有四个：</p><ul><li><p><strong>C</strong>：C++ 以 C 为基础，这没什么好说的。</p></li><li><p><strong>Object-Oriented C++</strong>：无非就是 classes（包括构造函数和析构函数）、封装（encapsulation）、<br>继承（inheritance）、多态（polymorphic）、virtual函数（动态绑定）… 这一部分应该是所有面向对象语言的基础。</p></li><li><p><strong>Template C++</strong>：C++ 的泛型编程部分，template 威力强大，<br>也带来了崭新的编程范式，也就是所谓的 template metaprogramming （TMP，模板元编程），TMP相关规则很少与 C++ 主流编程互相影响。<br>最基本的 TMP 应该就是求阶乘，这会在后面的专题中讲到。</p></li><li><p><strong>STL</strong>：顾名思义，C++ 的标准模板库，对 容器（container）、迭代器（iterator）、算法（algorithm）以及函数对象（function object）<br>的规约有极佳的紧密配合与协调。</p></li></ul><p><strong>请记住</strong></p><blockquote><ul><li><strong>C++ 高效编程守则视状况而变换，取决于使用 C++ 的哪一部分。</strong></li></ul></blockquote><hr><h2 id="Item-2-尽量以-const-enum-inline-替换-define"><a href="#Item-2-尽量以-const-enum-inline-替换-define" class="headerlink" title="Item 2 : 尽量以 const, enum, inline 替换 #define"></a>Item 2 : 尽量以 const, enum, inline 替换 #define</h2><blockquote><p>Prefer const, enum, and inline to #define</p></blockquote><h3 id="以-const-替换-define"><a href="#以-const-替换-define" class="headerlink" title="以 const 替换 #define"></a>以 const 替换 #define</h3><p><code>#define</code> 不被视为需要编译语言的一部分，它是被交给预处理器处理的。如果某个宏比如 <code>#define MAGIC_NUM 123</code> 被定义在非自己所写的头文件中，那么很可能在编译出错获得编译错误信息时，对出现的 <code>123</code> 而不是 <code>MAGIC_NUM</code> 这么一个数据的出现感到莫名其妙。</p><p>但如果将其声明为一个 <code>const</code> 常量 <code>const int magic_num = 123</code> 或者 此处也可声明为一个常量表达式 <code>constexpr int magic_num  = 123</code> （注：<code>constexpr</code> 是 C++11 标准中引入的，指值不会改变并且在编译过程就能得到计算结果的表达式，显然字面值属于常量表达式），作为一个语言常量，就肯定会被编译器看到。</p><p><del>至于对浮点常量而言，使用常量可能比使用 <code>#define</code> 导致较小量的码 这种情况我觉得作用不大，就不用记住了。（所谓的较小量的码指的是预处理器盲目地将宏名称 <code>MAGIC_NUM</code> 替换为 <code>123</code> 可能导致目标码出现多份 <code>123</code>，而改用常量则不会出现这种情况）</del></p><p>这里还要说下以常量 <code>const</code> 替换 <code>#define</code> 的两种特殊情况：</p><ul><li><p>定义常量指针（constant pointers），由于常量定义式通常被放在头文件内，因此有必要将指针声明为 <code>const</code>。</p></li><li><p>定义 class 专属常量，为将常量作用域限制在 class 内，必须让其成为 class 的一个成员（member），而为确保此常量至多只有一份实体，必须让其成为一个 <code>static</code> 成员， 例如 <code>static  const int value  = 1;</code>。<br>此处是 <code>value</code> 的声明式而非定义式，通常 C++ 要求对使用的任何东西提供一个定义式，但如果它是个 class 专属常量（<code>const</code>）又是 <code>static</code> 且为整数类型（例如 <code>int</code>， <code>char</code>，<code>bool</code>），则需<strong>特别处理：只要不取其地址，可以只声明并使用它而无需提供定义式</strong>。</p><blockquote><p>而 <code>#define</code> 并不重视作用域，也就无法创建一个 class 专属常量，也不能提供任何封装性，而 <code>const</code> 成员变量可以被封装。</p></blockquote></li></ul><h3 id="以-enum-替换-define"><a href="#以-enum-替换-define" class="headerlink" title="以 enum 替换 #define"></a>以 enum 替换 #define</h3><p>这一部分是接着上面的 <strong>class 专属常量</strong> 展开叙述的。</p><p>所谓的 <strong><code>in-class</code> 初值设定只允许对整数常量（例如int、char、bool）进行</strong>。即下面的代码是<strong>无法通过编译</strong>的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> value = <span class="number">0.5</span>;    <span class="comment">// 无法通过编译</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不过有些旧式编译器（我电脑上的都能编译通过）（错误地）不允许 “<code>static</code> 整数型 class 常量” 完成 “<code>in-class</code> 初值设定”，可改用所谓的 “<strong><code>the enum hack</code></strong>” 补偿做法。原因是：<strong>一个属于枚举类型（enumerated type）的数值可权充 <code>int</code> 被使用</strong>，即如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 可权充 static const int value = 1;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; value =  <span class="number">1</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除了编译器层面上的理由外，认识 <code>enum hack</code> 还有两个理由：</p><ol><li><p>这个理由看看就行，平常也用不太到。<code>enum hack</code> 的行为某方面说比较像 <code>#define</code> 而不像 <code>const</code>，但有时这也是我们想要的。例如不想让别人获得一个 pointer 或 reference 指向某个整数常量，<code>enum</code> 可以帮助实现这个约束，因为取一个 <code>enum</code> 的地址是不合法的，而取一个 <code>#define</code> 的地址通常也不合法，但取一个 <code>const</code> 的地址是合法的。此外，不够优秀的编译器可能会为 “整数型 <code>const</code> 对象” 设定另外的存储空间，但 <code>enum</code> 和 <code>#define</code> 一样绝不会导致非必要的内存分配。</p></li><li><p>纯粹是为了实用主义，因为许多代码中用到了它，所以也就必须要了解其含义。事实上，<code>enum hack</code> 是 <code>TMP</code>（模板元编程）的基础技术，但我自己本身更喜欢直接用 <code>static const int</code> 之类的 <code>in-class</code> 初值设定（谁会用连这个都编译不通过的编译器啊）。</p></li></ol><p>例如，下面的代码是最简单的 <code>TMP</code> 代码之一（实现阶乘），不理解 <code>TMP</code> 的看看就好</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Factorial</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; value = n * Factorial&lt;n<span class="number">-1</span>&gt;::value &#125;;</span><br><span class="line">    <span class="comment">// static const int value = n * Factorial&lt;n-1&gt;::value;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Factorial</span>&lt;0&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; value = <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="comment">// static const int value = 1;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="以-inline-替换-define"><a href="#以-inline-替换-define" class="headerlink" title="以 inline 替换 #define"></a>以 inline 替换 #define</h3><p>用 <code>#define</code> 实现宏（macros）是一种常见的做法，宏看起来像函数，但不会有函数调用（function call）带来的额外开销。<br>例如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以 a 和 b 的较大值调用 f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_MAX(a,b) f( (a) &gt; (b) ? (a) : (b) )</span></span><br></pre></td></tr></table></figure></p><p>书中说以 <code>#define</code> 实现宏是误用情况，我不这么认为，至少现在绝大多数的单元测试代码中都包含大量 <code>#define</code> 实现的宏，前提是正确的使用。<br>如上述 <code>CALL_WITH_MAX</code> 这般长相的宏的确存在的太多缺点：</p><ul><li>写出这种宏时记住必须要为 宏中所有实参 加上小括号，否则在某些表达式调用这个宏时会得不到想要的结果。（这部分学过C++的应该都知道，就不细说了）</li><li><p>但纵使为所有实参加上小括号，也会出现意料之外的事，比如</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// (++a) &gt; (b) ? (++a) : (b) </span></span><br><span class="line">CALL_WITH_MAX(++a, b);      <span class="comment">// a 被累加二次</span></span><br><span class="line"><span class="comment">// (++a) &gt; (b+10) ? (++a) : (b+10)</span></span><br><span class="line">CALL_WITH_MAX(++a, b+<span class="number">10</span>);   <span class="comment">// a 被累加一次</span></span><br></pre></td></tr></table></figure><p>  此处调用 <code>f</code> 之前，<code>a</code> 的递增次数竟然取决于 “它被拿来和谁比较”，你说这种情况还不令人恶心么？</p></li></ul><p>因此 C++ 引入了 <code>inline</code> ，不仅获得了宏带来的效率，还有一般函数的所有可预料行为和类型安全性（type safety）。</p><p>上面的宏就可改写为一个 <code>template inline</code> 函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">call_with_max</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此外，由于 <code>call_with_max</code> 是个真正的函数，它遵守作用域和访问规则。</p><p><strong>请记住</strong></p><blockquote><ul><li><strong>对于单纯常量，最好以 const 对象或 enum 替换 #define</strong></li><li><strong>对于形似函数的宏（macros），最好改用 inline 函数替换 #define</strong></li><li>有了 const、enum、inline，对预编译器（特别是#define）的需求降低了，但并非完全消除。</li></ul></blockquote><hr><h2 id="Item-3-尽可能使用-const"><a href="#Item-3-尽可能使用-const" class="headerlink" title="Item 3 : 尽可能使用 const"></a>Item 3 : 尽可能使用 const</h2><blockquote><p>Use const whenever possible</p></blockquote><h3 id="C-对常量性的定义"><a href="#C-对常量性的定义" class="headerlink" title="C++ 对常量性的定义"></a>C++ 对常量性的定义</h3><p>只要某个值不变，就该明确定义为 <code>const</code>，因为说出来可以获得编译器的帮助，确保约束不被违反。</p><p>可以用它在 <code>classes</code> 外部修饰 <code>global</code> 或 <code>namespace</code> 作用域的常量，或修饰文件、函数、或区块作用域中被声明为 <code>static</code> 的对象。<br>也可以用它修饰 <code>classes</code> 内部的 <code>static</code> 和 <code>non-static</code> 成员变量。<br>面对指针时，也可以指出指针本身、指针所有物、或两者都（或都不）是 <code>const</code>，如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">array</span>[] = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">char</span>* p = <span class="built_in">array</span>;                <span class="comment">// non-const pointer, non-const data</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p = <span class="built_in">array</span>;          <span class="comment">// non-const pointer, const data</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p = <span class="built_in">array</span>;          <span class="comment">// const pointer, non-const data</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p = <span class="built_in">array</span>;    <span class="comment">// const pointer, const data</span></span><br></pre></td></tr></table></figure></p><p>虽说绝大部分 C++ 开发者肯定都应该知道这一点， 但我还是决定在此写一遍：<code>const</code> 出现在 <code>*</code> 号左边，表示被指物是常量；出现在 <code>*</code> 号右边，表示指针本身是常量；出现在 <code>*</code> 号两边，表示被指物和指针都是常量。</p><p>此外，还要提及两种 被指物是常量的 编写习惯：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我相信大多数人都应该会跟我一样，更习惯第一种的编写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">const</span> T* p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(T <span class="keyword">const</span> * p)</span></span>;</span><br></pre></td></tr></table></figure></p><p><code>STL</code> 迭代器类似于指针，因为其本身就是为了模仿指针的作用，但要注意的一点是：若希望迭代器所指的东西不可改动，应该需要的是 <code>const_iterator</code> （即模仿一个 <code>const T*</code> 指针）。</p><h3 id="const-成员函数"><a href="#const-成员函数" class="headerlink" title="const 成员函数"></a>const 成员函数</h3><p>成员函数是 <code>const</code> 意味着什么（怎么听起来这么哲♂学呢）？</p><p><code>const</code> 实施于成员函数是为了确认该成员函数可作用于 <code>const</code> 对象，使得“操作 <code>const</code> 对象”成为可能。 </p><p>书中提及的两个概念 <code>bitwise constness</code> 和 <code>logical constness</code>（这两个名词是我之前没有听说过的，不知道其他人的情况，但有关内容我是了解的，姑且在此整理一番）</p><ul><li><p><strong><code>bitwise constness</code></strong></p><p>  此阵营认为：成员函数只有在不更改对象的任何成员变量（<code>static</code> 除外）时才可说是 <code>const</code>。这正是 C++ 对常量性（constness）的定义，因此 <code>const</code> 成员函数不可以更改对象内任何 <code>non-static</code> 成员变量。</p><p>  不幸的是许多成员函数虽不完全具备 <code>const</code> 性质却能通过 <code>bitwise</code> 测试，更具体地说，一个更改了 “指针所有物” 的成员函数虽然不能算是 <code>const</code>，但如果只有指针（而非其所指物）隶属于对象，那么称此函数为 <code>bitwise constness</code> 不会引发编译器异议。套用书中例子：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// bitwise const 声明，但不恰当</span></span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span> [] (<span class="built_in">std</span>::<span class="keyword">size_t</span> pos) <span class="keyword">const</span></span><br><span class="line">    &#123; <span class="keyword">return</span> pText[pos]; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===================================</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> CTextBlock <span class="title">cctb</span><span class="params">(<span class="string">"Hello"</span>)</span></span>;     <span class="comment">// 声明常量对象</span></span><br><span class="line"><span class="keyword">char</span>* pc = &amp;cctb[<span class="number">0</span>];                <span class="comment">// 调用 const operator[] 取得一个指针</span></span><br><span class="line">*pc = <span class="string">'J'</span>;</span><br></pre></td></tr></table></figure><p>  上述代码尽管创建了一个常量对象并设以某值，而且只对它调用 <code>const</code> 成员函数，但终究还是改变了它的值。</p></li><li><p><strong><code>logical constness</code></strong></p><p>  此阵营认为：一个 <code>const</code> 成员函数可以修改其所处理对象内的某些 <code>bit</code> ，但只有在客户端侦测不出的情况下才得如此。</p><p>  若数据被修改对 <code>const</code> 对象而言虽可接受，而编译器不同意，但却想要坚持 <code>bitwise constness</code>，可以通过关键字 <code>mutable</code> 释放掉 <code>non-static</code> 成员变量的 <code>bitwise constness</code> 约束。更通俗点说，在一个成员函数内不能改变 <code>non-static</code> 数据成员的值，而将数据成员加上 <code>mutable</code>，就能做到改变。</p></li></ul><h3 id="在-const-和-non-const-成员函数中避免重复"><a href="#在-const-和-non-const-成员函数中避免重复" class="headerlink" title="在 const 和 non-const 成员函数中避免重复"></a>在 const 和 non-const 成员函数中避免重复</h3><p>套用书中的 重载下标运算符 <code>[]</code> 的例子。</p><p>若一个类包含下标运算符，通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并返回常量引用。当该下标运算符作用于常量对象时，会对应调用返回常量引用的那个重载运算符函数以确保不会给返回的对象赋值。</p><p>但一般来说重载下标运算符函数内的代码不多，我平常也就直接 <code>Ctrl-C</code> 和 <code>Ctrl-V</code> 一下，但如果像书中的例子，重载运算符 <code>[]</code> 的函数内还存在许多其他操作，那么适量地复用代码就显然可以缩短编译时间，减少代码膨胀等带来的维护难问题。</p><p>复用代码前：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处为了代码紧凑，直接将函数内容写在了类内，请忽略此处可能形成的 超长隐式的 `inline` 函数问题</span></span><br><span class="line"><span class="comment">// 虽说好的编译器会帮助你优化这点（逃</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span> [] (<span class="built_in">std</span>::<span class="keyword">size_t</span> pos) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...                 <span class="comment">// 边界检查（bound checking）</span></span><br><span class="line">        ...                 <span class="comment">// 记录数据访问（log access data）</span></span><br><span class="line">        ...                 <span class="comment">// 检验数据完整性（verify data integrity）</span></span><br><span class="line">        <span class="keyword">return</span> text[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span> [] (<span class="built_in">std</span>::<span class="keyword">size_t</span> pos)</span><br><span class="line">    &#123;</span><br><span class="line">        ...                 <span class="comment">// 边界检查（bound checking）</span></span><br><span class="line">        ...                 <span class="comment">// 记录数据访问（log access data）</span></span><br><span class="line">        ...                 <span class="comment">// 检验数据完整性（verify data integrity）</span></span><br><span class="line">        <span class="keyword">return</span> text[pos];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>复用代码后：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span> [] (<span class="built_in">std</span>::<span class="keyword">size_t</span> pos) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...                 <span class="comment">// 边界检查（bound checking）</span></span><br><span class="line">        ...                 <span class="comment">// 记录数据访问（log access data）</span></span><br><span class="line">        ...                 <span class="comment">// 检验数据完整性（verify data integrity）</span></span><br><span class="line">        <span class="keyword">return</span> text[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span> [] (<span class="built_in">std</span>::<span class="keyword">size_t</span> pos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;(                   <span class="comment">// 将operator[]返回值的const转除</span></span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)    <span class="comment">// 为 *this 加上 const</span></span><br><span class="line">                [pos]                               <span class="comment">// 调用 const operator[]</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>一般而言，转型（casting）的确不是个好选择，但显然代码重复也不是什么好鸟【那些为了可读性的代码重复除外】。</p><p>上述例子中，<code>const</code> 版本已经完全做掉了 <code>non-const</code> 版本的任务，唯一不同是其返回类型多了 <code>const</code> 修饰，在这种情况下将返回值的 <code>const</code> 转除并以此实现 <code>non-const</code> 版本是安全的，因为不论谁调用 <code>non-const operator []</code> 都一定要先有个 <code>non-const</code> 对象，否则显然不能调用 <code>non-const</code> 函数。【可以反过来思考下令 <code>const</code> 版本调用 <code>non-const</code> 版本的可能性，下面会进行解释说明】</p><p><code>non-const operator []</code> 内部若直接单纯调用 <code>operator []</code>，会递归调用自己，所以显然必须明确指出调用的是 <code>const operator []</code>。</p><p>这里用了两次转型：</p><ul><li>第一次：用来为 <code>*this</code> 添加 <code>const</code> （使接下来调用 <code>operator []</code> 时得以调用 <code>const</code>），将 <code>*this</code> 从其原始类型 <code>TextBlock&amp;</code> 强制转型为 <code>const TextBlock&amp;</code>，将 <code>non-const</code> 对象强制转型为 <code>const</code> 对象，使用 <code>static_cast</code>。</li><li>第二次：是从 <code>const operator []</code> 的返回值中移除 <code>const</code>，移除 <code>const</code> 的转型动作在 C++ 中只能通过 <code>const_cast</code> 完成。</li></ul><p>虽然这样的语法形式会比较难看，但是这种技术还是值得了解的。而更应该值得了解的是 <strong>不应该去做其反向做法（令 <code>const</code> 版本调用 <code>non-const</code> 版本）</strong>，因为 <code>const</code> 成员函数承诺绝不改变其对象的逻辑状态（改成 <code>non-const</code> 属于改变逻辑状态），而 <code>non-const</code> 成员函数则没有这般承诺，它本来就可以对其对象做任何动作，所以在其中调用一个 <code>const</code> 成员函数并不会带来风险。</p><p><strong>请记住</strong></p><blockquote><ul><li>将某些东西声明为 <code>const</code> 可帮助编译器侦测出错误用法。<code>const</code> 可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</li><li>【这条感觉特别玄学…】编译器强制实施 bitwise constness，但<strong>编写程序时应该使用 “概念上的常量性” （conceptual constness）</strong>。</li><li>当 <code>const</code> 和 <code>non-const</code> 成员函数有着实质等价的实现时，<strong>令 <code>non-const</code> 版本调用 <code>const</code> 版本可避免代码重复</strong>。</li></ul></blockquote><hr><h2 id="Item-4-确定对象被使用前已先初始化"><a href="#Item-4-确定对象被使用前已先初始化" class="headerlink" title="Item 4 : 确定对象被使用前已先初始化"></a>Item 4 : 确定对象被使用前已先初始化</h2><blockquote><p>Make sure that objects are initialized before they’re used</p></blockquote><p>显然读取未初始化的值会导致不明确的行为，而 C++ 中关于对象初始化何时发生的规则很复杂，所以最佳的处理办法便是：<strong>永远在使用对象之前先将它初始化</strong>。</p><h3 id="初始化的常见部分"><a href="#初始化的常见部分" class="headerlink" title="初始化的常见部分"></a>初始化的常见部分</h3><ul><li>对于<strong>无任何成员的内置类型</strong>，必须手工完成此事。例如 <code>int x = 0;</code></li><li>对于<strong>内置类型外</strong>的任何其他东西，初始化的责任在于构造函数，即确保每一个构造函数都将对象的每一个成员初始化。<blockquote><p><code>注意：</code> 不要混淆赋值（assignment）和初始化（initialization），C++ 规定对象的成员变量的初始化动作发生在进入构造函数本体之前，较佳做法便是 <strong>使用成员初始化列表（member initialization list）</strong>，其实成员初始化列表的本质是做 <code>copy</code> 构造。<br>  对大多数类型而言，比起先调用 <code>default</code> 构造函数再调用 <code>copy assignment</code> 操作符，单只调用一次 <code>copy</code> 构造函数显然是更高效的。而对于内置型对象来说，其初始化和赋值成本相同，但为了强迫症的一致性（还有一些内置型对象必须被初始化的缘故，例如对象是 <code>const</code> 或 <code>reference</code>），所以最好也是最简单的做法就是：<strong>总是使用成员初始化列表来初始化</strong>。</p></blockquote></li></ul><p>相比 C++ 对象初始化何时发生的情况，C++ 的<strong>成员初始化次序</strong>就显得十分固定而简单了：<strong><code>base classes</code> 更早于其 <code>derived classes</code> 被初始化，而 <code>class</code> 的成员变量总是以其声明的次序被初始化</strong>，所以<strong>当在成员初始化列表中列出各个成员时，最好总是以其在 <code>class</code> 中的声明次序为次序</strong>。【虽说不按次序也是合法的，但有可能会发生一些稀奇古怪的错误，你自己决定吧→_→】</p><h3 id="初始化的特殊部分"><a href="#初始化的特殊部分" class="headerlink" title="初始化的特殊部分"></a>初始化的特殊部分</h3><p>好，现在初始化部分就只剩最后一件事需要关心了，这样看条理是不是比较清晰…【也可能不清晰？</p><p>不同编译单元内定义的 <code>non-local static</code> 对象的初始化，说实话，我之前根本没有想过这部分与一般初始化的区别，所以整理的不好别见怪。【还好这里书中用到的解决办法是大多数人熟悉的一种设计模式–单例模式（<code>Singleton</code> 模式）</p><p>函数内的 <code>static</code> 对象称为 <code>local static</code> 对象，其他 <code>static</code> 对象称为 <code>non-local static</code> 对象，而编译单元（translation unit）是指产出单一目标文件的那些源码。</p><p>这里的问题是涉及至少两个源码文件，每一个内含至少一个 <code>non-local static</code> 对象。因为 C++ 对 <strong>“定义在不同编译单元内的 <code>non-local static</code> 对象” 的初始化次序并无明确定义</strong>， 所以可能出现一种情况：<strong>某个编译单元内的某个 <code>non-local static</code> 对象的初始化使用了另一个编译单元内的某个 <code>non-local static</code> 对象，而被使用到的这个对象可能尚未被初始化</strong>。</p><blockquote><p>可能你会要问 C++ 对此没有明确定义的原因，书中给出了：那就是决定其初始化次序相当困难，甚至根本无解。最常见的形式：多个编译单元的 <code>non-local static</code> 对象经由“模板隐式实例化（implicit template instantiation）” 形成，而后者自己可能也是经由“模板隐式实例化”形成的，不但不可能决定正确的初始化次序，甚至往往不值得去做。</p></blockquote><p>套用书中的实例<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span>    // 你的程序库</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> numDisks() <span class="keyword">const</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span>     // 由程序库客户建立</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Directory( params );</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Directory::Directory( params )</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> disks = tfs.numDisks();  <span class="comment">// 用到了tfs对象</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设客户决定创建一个 <code>Directory</code> 目录对象用来放置临时文件，即<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Directory <span class="title">tempDir</span><span class="params">( params )</span></span>;</span><br></pre></td></tr></table></figure></p><p>显然，除非 <code>tfs</code> 在 <code>tempDir</code> 之前被初始化，否则 <code>tempDir</code> 的构造函数会用到尚未初始化的 <code>tfs</code>，而 <code>tfs</code> 和 <code>tempDir</code> 是不同人建立在不同的源码文件上的，即定义于不同编译单元内的 <code>non-local static</code> 对象。</p><p><strong>解决办法</strong>就像先前提到的，即实现 <code>Singleton</code> 模式：将每个 <code>non-local static</code> 对象搬到自己的专属函数内（该对象在此函数内被声明为 <code>static</code>），这些函数返回一个 <code>reference</code> 指向它所含的对象。也就是使用函数返回的 “指向 <code>static</code> 对象” 的 <code>reference</code>，而不再使用 <code>static</code> 对象本身。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span>       <span class="comment">// 这个函数用来替换 tfs 对象</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> FileSystem fs;</span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span> &#123;</span> ... &#125;;</span><br><span class="line">Directory::Directory( params )</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> disks = tfs().numDisks();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Directory&amp; <span class="title">tempDir</span><span class="params">()</span>    <span class="comment">// 这个函数用来替换 tempDir 对象</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Directory td;</span><br><span class="line">    <span class="keyword">return</span> td;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为 <strong>C++ 保证函数内的 <code>local static</code> 对象会在“该函数被调用期间”“首次遇上该对象的定义式”时被初始化</strong>，所以如果用函数调用（返回一个 <code>reference</code> 指向 <code>local static</code> 对象）替换“直接访问 <code>non-local static</code> 对象”，就能保证获得的那个 <code>reference</code> 将指向一个历经初始化的对象。<br>更棒的是，如果未调用 <code>non-local static</code> 对象的“仿真函数”，就绝不会引发构造和析构的成本。</p><blockquote><p> 【这部分仅作了解，毕竟此处重点并不是多线程问题】但从另一个角度说，内含 <code>static</code> 对象的函数在多线程系统中带有不确定性，更具体地说，任何一种 <code>non-const static</code> 对象，不论是 <code>local</code> 或 <code>non-local</code>，在多线程环境下都会有麻烦。解决此麻烦的一种做法是：在程序的单线程启动阶段手工调用所有 <code>reference-returning</code> 函数，消除与初始化有关的“竞速形势（race conditions）”。</p></blockquote><p><strong>请记住</strong></p><blockquote><ul><li><strong>为内置型对象进行手工初始化，因为C++不保证初始化它们。</strong></li><li><strong>构造函数最好使用成员初始化列表（member initialization list）</strong>，而不要在构造函数本体内使用赋值操作（assignment）。<strong>初始化列表的成员变量，其排列次序应该和它们在 class 中的声明次序相同。</strong></li><li>为免除<strong>“跨编译单元之初始化次序”</strong>问题，请<strong>以 local static 对象替换 non-local static 对象</strong>。</li></ul></blockquote><hr><!-- # Resourse Management## Item 13 : 以对象管理资源> Use objects to manage resourses## Item 14 : 在资源管理类中小心 copying 行为> Think carefully about copying behavior in resourse-managing classes## Item 15 : 在资源管理类中提供对原始资源的访问> Provide access to raw resourse in resourse-managing classes## Item 16 : 成对使用 new 和 delete 时要采取相同形式> Use the same form in corresponding uses of new and delete## Item 17 : 以独立语句将 newed 对象置入智能指针> Store newed objects in smart pointers in standalone statements---# Designs and Declarations## Item 18 : 让接口容易被正确使用，不易被误用> Make interfaces easy to use correctly and hard to use incorrectly## Item 19 : 设计 class 犹如设计 type> Treat class design as type design ## Item 20 : 宁以 pass-by-reference-to-const 替换 pass-by-value> Prefer pass-by-reference-to-const to pass-by-value## Item 21 : 必须返回对象时，别妄想返回其 reference> Don't try to return a reference when you must return an object## Item 22 : 将成员变量声明为 private> Declare data members private## Item 23 : 宁以 non-member、non-friend 替换 member 函数> Prefer non-member non-friend functions to member functions ## Item 24 : 若所有参数皆需类型转换，请为此采用 non-member 函数> Declare non-member functions when type conversions should apply to all parameter## Item 25 : 考虑写一个不抛出异常的 swap 函数> Consider support for a non-throwing swap---# Implementations## Item 26 : 尽可能延后变量定义式的出现时间> Postpone variable definitions as long as possible## Item 27 : 尽量少做转型动作> Minimize casting ## Item 28 : 避免返回 handler 指向对象内部成分> Avoid returning "handles" to object internals## Item 29 : 为“异常安全”而努力是值得的> Strive for exception-safe code## Item 30 : 透彻了解 inlining 的里里外外> Understand the ins and outs of inlining## Item 31 : 将文件间的编译依存关系降至最低> Minimize compilation dependencies between files---# Inheritance and Object-Oriented Designs## Item 32 : 确定 public 继承构造出 **is-a** 关系> Make sure public inheritance models "is-a"## Item 33 : 避免遮掩继承而来的名称> Avoid hiding inherited names## Item 34 : 区分接口继承和实现继承> Differentiate between inheritance of interface and inheritance of Implementation## Item 35 : 考虑 virtual 函数以外的其他选择> Consider alternatives to virtual function## Item 36 : 绝不重新定义继承而来的 non-virtual 函数> Never redefine an inherited non-virtual function## Item 37 : 绝不重新定义继承而来的缺省参数值> Never redefine a function's inherited default parameter value## Item 38 : 通过复合构造出 **has-a** 或 “根据某物实现出”> Model "has-a" or "is-implemented-in-terms-of" through composition## Item 39 : 明智而审慎地使用 private 继承> Use private inheritance judiciously## Item 40 : 明智而审慎地使用多重继承> Use multiple inheritance judiciously---# Templates and Generic Progamming ## Item 41 : 了解隐式接口和编译期多态> Understand implicit interfaces and compile-time polymorphism## Item 42 : 了解 typename 的双重意义> Understand the two meanings of typename## Item 43 : 学习处理模板化基类内的名称> Know how to access names in templatized base classes## Item 44 : 将与参数无关的代码抽离 templates> Factor parameter-indenpendent code out of templates## Item 45 : 运用成员函数模板接受所有兼容类型> Use member function templates to accept "all compatible types"## Item 46 : 需要类型转化时请为模板定义非成员函数> Define non-member functions inside templates when type conversions are desired## Item 47 : 请使用 traits classes 表现类型信息> Use traits classes for information about types## Item 48 : 认识 template 元编程> Be aware of "template metaprogramming (TMP)"----->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前买了这本书后只是草草翻过，这半个多月以来，断断续续把这本书从头到尾看了一遍，虽然其中的一些条款内容早就熟记于心，但难免还有晦涩之处，所以打算在过年空闲期间把整本书的每个条款的重点进行系统的整理。&lt;br&gt;不得不说 C++ 是门不好学的语言，自认为也没那么聪明，整理总结对我来说不失为一个深入学习的好方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Cpp" scheme="http://koushiro.me/categories/Cpp/"/>
    
    
      <category term="tech" scheme="http://koushiro.me/tags/tech/"/>
    
      <category term="Cpp" scheme="http://koushiro.me/tags/Cpp/"/>
    
      <category term="note" scheme="http://koushiro.me/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>Deploy Hexo blog on Github Page</title>
    <link href="http://koushiro.me/2017/01/02/Deploy-hexo-blog-on-github-page/"/>
    <id>http://koushiro.me/2017/01/02/Deploy-hexo-blog-on-github-page/</id>
    <published>2017-01-02T14:56:05.000Z</published>
    <updated>2018-09-18T15:45:59.431Z</updated>
    
    <content type="html"><![CDATA[<center>This is a simple tutorial to deploy your hexo blog on Github Page. </center><a id="more"></a><h2 id="Deploy-Hexo-blog-on-Github-Page"><a href="#Deploy-Hexo-blog-on-Github-Page" class="headerlink" title="Deploy Hexo blog on Github Page"></a>Deploy Hexo blog on Github Page</h2><h3 id="Install-Node-js-and-Git"><a href="#Install-Node-js-and-Git" class="headerlink" title="Install Node.js and Git"></a>Install Node.js and Git</h3><ul><li><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node.js</a></li><li><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a></li></ul><p>具体情况可见 <a href="https://hexo.io/docs/index.html" target="_blank" rel="noopener">hexo official document</a>.</p><p>之前我本来想配置在archlinux上的，后来发现直接在windows上配置也是行得通的。</p><p>Node.js 就直接用 windows 的 Latest LTS version.</p><p>Git 就直接下个 <a href="https://git-for-windows.github.io/" target="_blank" rel="noopener">Git bash</a>.</p><p>打开 Git bash， 为本地 Git 配置全局 user 和 email 参数，当然你肯定要有 Github 账户.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"your github account name"</span></span><br><span class="line">git config --global user.email <span class="string">"your github account email"</span></span><br></pre></td></tr></table></figure><p>然后在本地生成 SSH 私钥，并将公钥保存到你的 GitHub 账户中去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"your github account email"</span></span><br></pre></td></tr></table></figure><p>生成过程会有提示要输入，直接一路enter.</p><p>进入Github 的 setting 界面，选择 SSH and GPG keys ，点击 New SSH key ，在展开的窗口中填写公钥信息。</p><p>title 可以随意起，key 那一栏则是把刚刚生成的 id_rsa.pub 的内容复制进去。最后点击按钮添加。</p><h3 id="Install-Hexo"><a href="#Install-Hexo" class="headerlink" title="Install Hexo"></a>Install Hexo</h3><p>Node.js 在 windows 上的安装默认会直接安装上 npm.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>使用 hexo 生成博客框架</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo init Blog</span><br><span class="line"><span class="built_in">cd</span> Blog</span><br><span class="line">npm install</span><br><span class="line">hexo generate (or hexo g)</span><br><span class="line">hexo server   (or hexo s)</span><br></pre></td></tr></table></figure><blockquote><p>hexo init blog 过程可能比较慢，因为过程中要远程从 github 上下载默认的主题。</p></blockquote><p>通过 hexo server 运行起 hexo 内置的服务器。<br>这时候就可以开始在本地访问了，默认地址为 localhost:4000 .</p><h3 id="Hexo-modules"><a href="#Hexo-modules" class="headerlink" title="Hexo modules"></a>Hexo modules</h3><ul><li><code>_config.yml</code> ：站点配置文件，可以修改网站的主题、标题、作者等信息。</li><li><code>public</code> ：由 hexo 根据 source 文件夹中的资源进行渲染生成的文件夹，里边存储着最终的静态网页文件。</li><li><code>scaffolds</code> ：模板文件，当要给博客添加新文章的时候，可以根据对应的模板进行创建。</li><li><code>source</code> ：用于存储用户资源，比如文章与新页面等。其中以 _ 开头的文件夹中除了 _posts 文件夹中的 markdown 或 HTML 文件会在执行 generate 操作的时候被渲染添加到 public 文件夹中之外，其他均被忽略。而且在初始化博客的过程中 _posts 目录底会自带一个 hello-world.md 的文件。</li><li><code>themes</code> ：主题文件，自带默认主题 landscape 。</li></ul><h3 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h3><p><a href="https://github.com/iissnan/hexo-theme-next/releases" target="_blank" rel="noopener">NexT 主题</a></p><p>下载你喜欢的版本并解压到 themes 目录下，将解压后的文件夹名称改名为 next.</p><p>打开 <code>_config.yml</code> （即站点配置文件），找到 <code>theme</code> 字段，将默认主题 landscape 改为 <code>next</code>，<br>通过之前的两条命令重新生成网页文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>应该就可以在本地浏览器看见新主题了。</p><p>主题更具体的配置请见 <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">NexT 的官方文档</a>，官方文档写得很有条理，而且里面还有各种第三方服务的配置。</p><h3 id="Deploy-to-Github-Page"><a href="#Deploy-to-Github-Page" class="headerlink" title="Deploy to Github Page"></a>Deploy to Github Page</h3><p>首先要创建一个 new repository，注意仓库名格式必须为 your_github_name.github.io ，这个仓库将作为你的静态博客文件的存放仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Hexo/blog</span><br><span class="line">git <span class="built_in">clone</span> git@github.com:your_github_name/your_github_name.github.io.git</span><br></pre></td></tr></table></figure><p>部署要做的事就是把 public 文件目录下的博客文件都复制到你的本地仓库中，<br>并将本地仓库 push 到 github 仓库上。这样当其他人访问你的博客链接的时候 github 将会自动将该仓库中的相应文件展示出来。</p><p>你可以把上面的部署方法写成 <code>shell</code> 脚本一键部署（个人更推荐脚本的方法）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cp -R public/* your_github_name.github.io/</span><br><span class="line">cp -R <span class="built_in">source</span>/* your_github_name.github.io/<span class="built_in">source</span>/</span><br><span class="line"><span class="built_in">cd</span> your_github_name.github.io</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">'update blog'</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>或者使用更方便的方法，即安装 <code>hexo-deployer-git</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>修改站点配置文件 <code>_config.yml</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:your_github_name/your_github_name.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><p>然后执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy (or hexo d)</span><br></pre></td></tr></table></figure><h3 id="Addtion：为-Github-Page-绑定独立域名"><a href="#Addtion：为-Github-Page-绑定独立域名" class="headerlink" title="Addtion：为 Github Page 绑定独立域名"></a>Addtion：为 Github Page 绑定独立域名</h3><p>首先当然要有自己的域名，接着就是域名解析，这类教程网上一抓一大把，这里就不细讲了。</p><p>在本地博客的 <code>source</code> 目录下（例如：Hexo/blog/source）<br>创建文件 <code>CNAME</code> （这个文件名一定要大写，并且没有文件后缀名），<br>编辑内容为你的域名，比如我的域名为 koushiro.me ，那么 <code>CNAME</code> 中就填写这个。<br>然后将这个 <code>CNAME</code> 文件放到 source 目录下，执行 <code>hexo g</code> 时会自动加入到 public 目录， 最后执行 <code>hexo d</code> 将 public 目录里的文件 push 到 github 的主页仓库当中。</p><p>ps: 我的域名解析是在 <a href="https://www.dnspod.cn" target="_blank" rel="noopener">DNSPOD</a> 上解析的，<br>只要在域名解析中加上一条记录类型是 <code>CNAME</code>，记录值为 your_github_name.github.io 的记录就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;This is a simple tutorial to deploy your hexo blog on Github Page. &lt;/center&gt;
    
    </summary>
    
      <category term="Configuration" scheme="http://koushiro.me/categories/Configuration/"/>
    
    
      <category term="tech" scheme="http://koushiro.me/tags/tech/"/>
    
      <category term="config" scheme="http://koushiro.me/tags/config/"/>
    
      <category term="Hexo" scheme="http://koushiro.me/tags/Hexo/"/>
    
      <category term="Github" scheme="http://koushiro.me/tags/Github/"/>
    
  </entry>
  
</feed>
